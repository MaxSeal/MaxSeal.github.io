<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SQL 基础（一）SQL 的概念</title>
    <link href="/2021/07/13/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/3.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89SQL%20%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/07/13/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/3.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89SQL%20%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>SQL（Structured Query Language）结构化查询语言，是专门操作关系型数据库的一种语言。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>SQL（Structured Query Language）结构化查询语言，是专门操作关系型数据库的一种语言。</p><p>SQL语言属于第四代编程语言： </p><ul><li>第一代编程语言，机器语言，是面向机器的，通过二进制代码对其计算机操作。</li><li>第二代编程语言， 汇编语言，使用指令对应的符号，来代替二进制代码。</li><li>第三代编程语言，高级开发语言 ，例如C、C++ Java等，语言更加简单，操作更方便。</li><li>第四代编程语言，只告诉计算机需要做什么，不需要告诉计算机怎么做，更加接近自然语言。</li></ul><br/><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><p>SQL 语句的分类：</p><ul><li><p>DQL (Data Query Language) 数据查询语言：<br>用于检索数据库中的数据，主要是 SELECT 语句 。</p></li><li><p>DML (Data Manipulation Language) 数据操纵语言：<br>用于改变数据库中的数据，主要是 INSERT , UPDATE , DELETE 语句。</p></li><li><p>DDL（Data Define Langage) 数据定义语言：<br>用来建立、修改、删除数据库对象，主要是 CREATE 、 ALTER 、 DROP 、 TRUNCATE 语句。</p></li><li><p>TCL (Transaction Control Language) 事务控制语言：<br>用于维护数据的一致性，主要是 COMMIT , ROLLBACK , SAVEPOINT 语句。</p></li><li><p>DCL（Data Control Language）数据控制功能：<br>用于执行权限授予和权限收回操作，主要是 GRANT , REVOKE 语句。</p></li></ul><br/><h2 id="3-SQLPLUS-和-PL-SQL"><a href="#3-SQLPLUS-和-PL-SQL" class="headerlink" title="3. SQLPLUS 和 PL/SQL"></a>3. SQLPLUS 和 PL/SQL</h2><ul><li><p>SQL： 结构化的查询语句，操作关系型数据库的语言。</p></li><li><p>SQLPLUS：Oracle 数据库软件自带工具，可以接收用户输入的 SQL 语句，然后将 SQL 执行结果显示出来。</p></li><li><p> PL/SQL：程序化的SQL语句，在SQL语句的基础上加入一定的逻辑操作，如 if for 等。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL 的概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（九）表和约束</title>
    <link href="/2021/07/13/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/11.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%E8%A1%A8%E5%92%8C%E7%BA%A6%E6%9D%9F/"/>
    <url>/2021/07/13/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/11.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%E8%A1%A8%E5%92%8C%E7%BA%A6%E6%9D%9F/</url>
    
    <content type="html"><![CDATA[<p>约束和表的基本概念以及操作。</p><span id="more"></span><h2 id="1-数据库设计"><a href="#1-数据库设计" class="headerlink" title="1. 数据库设计"></a>1. 数据库设计</h2><h3 id="1-1-ER-图转数据库表"><a href="#1-1-ER-图转数据库表" class="headerlink" title="1.1 ER 图转数据库表"></a>1.1 ER 图转数据库表</h3><p>数据建模完成之后，可以把 E-R 图转换成数据库中的表：</p><ul><li>实体的名字转换为表。</li><li>实体的属性转换为表中的列。</li><li>具有唯一特点的属性设置为表中的主键。</li><li>根据实体之间的关系，设置表中某列为外键列（主外键关联）。<ul><li>一对一关系：外键设可以设在任意一方。</li><li>一对多关系：外键设在多的一方。</li><li>多对多关系：需要建一张桥表。</li></ul></li></ul><br/><h3 id="1-2-主键（primary-key）"><a href="#1-2-主键（primary-key）" class="headerlink" title="1.2 主键（primary key）"></a>1.2 主键（primary key）</h3><p>表中经常有<strong>一个列或多列的组合</strong>，其值能<strong>唯一地标识表中的每一行</strong>。这样的一列或多列称为表的主键，通过它可强制表的实体完整性。</p><p>关系型数据库要求所有表都应该有主键，不过 Oracle 没有遵循此范例要求。Oracle 中的表可以没有主键（这种情况不多见）。</p><ul><li>作用：用来唯一标识一行数据的。</li><li>特点：<ul><li>非空且唯一，相当于 <code>not null + unique</code>。</li><li>主键所在列必须具有索引（主键的唯一约束通过索引来实现）。如果不存在，将会在索引添加的时候自动创建。</li></ul></li></ul><p>在表中可以使用一个有意义的列做主键。例如：学生表的学号、公民的身份证号。也可以使用没有意义的列做主键，因为主键的作用就是标识一行数据，<strong>大部分情况下都是用没有意义的列去做主键</strong>。此外，还能把多个列组合在一起作为表的主键。</p><br/><h3 id="1-3-外键（foreign-key）"><a href="#1-3-外键（foreign-key）" class="headerlink" title="1.3 外键（foreign key）"></a>1.3 外键（foreign key）</h3><p>外键是用于建立和加强两个表数据之间的链接的一列或多列。通过将保存表中主键值的一列或多列添加到另一个表中，可创建两个表之间的链接。这个列就成为第二个表的外键。</p><ul><li>作用：连接两张表，体现两张表之间的对应关系。</li><li>特点：<ul><li>表中的某一个声明为外键的列，一般是与之连接的表的主键（其实只要是<strong>具体唯一约束的列</strong>，就可以被另一种表的外键列所引用）。</li><li><strong>声明为外键的列和被引用的列，名字可以不同，但数据类型必须相同。</strong></li><li>如果外键列没有做主键或联合主键，那么<strong>外键列的值可以为空</strong>。</li><li>实际上，<strong>外键列和被引用的列可以在同一张表中</strong>。最常见的就是表示一棵树。</li><li>如果把 B 表中的联合主键，引用到 A 表中做外键，那么这个外键就是一个联合外键。</li></ul></li></ul><br/><h2 id="2-约束"><a href="#2-约束" class="headerlink" title="2. 约束"></a>2. 约束</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>列的约束，就是对这个列中的值的要求（限制）。</p><p>数据库中的约束有：</p><ul><li>主键约束 primary key</li><li>外键约束 foreign key</li><li>唯一约束 unique</li><li>非空约束 not null （不能作为表级约束）</li><li>check 约束 check</li></ul><p>按照约束位置的不同又可以分为：列级约束和表级约束。</p><p>如果要声明的约束为<strong>联合主键</strong>、<strong>联合外键</strong>、<strong>联合唯一</strong>的时候，一定要用表级约束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 声明联合主键</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer_tb(<br>id   number,<br>  name  varchar2(<span class="hljs-number">30</span>),<br>  <span class="hljs-keyword">primary</span> key(id, name)<br>);<br><br><span class="hljs-comment">-- 声明联合外键</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_tb(<br>id  number <span class="hljs-keyword">primary</span> key,<br>  content  varchar2(<span class="hljs-number">30</span>)  <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  customer_id number,<br>  customer_name varchar2(<span class="hljs-number">30</span>),<br>  <span class="hljs-keyword">foreign</span> key(customer_id, customer_name) <span class="hljs-keyword">references</span> customer_tb(id, name)<br>);<br></code></pre></td></tr></table></figure><br/><h3 id="2-2-constraint-关键字"><a href="#2-2-constraint-关键字" class="headerlink" title="2.2 constraint 关键字"></a>2.2 constraint 关键字</h3><p>在创建约束的时候，可以使用 constraint 关键字给约束命名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 列级约束</span><br><span class="hljs-keyword">column</span> [<span class="hljs-keyword">constraint</span> constraint_name] constraint_type<br><br><span class="hljs-comment">-- 表级约束</span><br>[<span class="hljs-keyword">constraint</span> constraint_name] constraint_type (column1, column2...)<br></code></pre></td></tr></table></figure><p>例：创建一个课程表和教师表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> teacher_tb(<br>id number <span class="hljs-keyword">constraint</span> pk_teacher_tb <span class="hljs-keyword">primary</span> key,<br>  teacher_name varchar2(<span class="hljs-number">20</span>) <span class="hljs-keyword">constraint</span> n_teacher_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-comment">-- 方式 1：定义列级约束</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> course_tb(<br>id  number <span class="hljs-keyword">constraint</span> pk_course_tb <span class="hljs-keyword">primary</span> key,<br>  course_name  varchar2(<span class="hljs-number">20</span>)  <span class="hljs-keyword">constraint</span> u_course_name <span class="hljs-keyword">unique</span>,<br>  description  varchar2(<span class="hljs-number">100</span>) <span class="hljs-keyword">constraint</span> n_description <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  teacher_id   number <span class="hljs-keyword">constraint</span> fk_course_tb <span class="hljs-keyword">references</span> teacher_tb(id)<br>);<br><br><span class="hljs-comment">-- 方式 2：定义表级约束</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> course_tb(<br>id  number,<br>  course_name  varchar2(<span class="hljs-number">20</span>),<br>  description  varchar2(<span class="hljs-number">100</span>) <span class="hljs-keyword">constraint</span> n_description <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  teacher_id   number,<br>  <span class="hljs-keyword">constraint</span> pk_course_tb <span class="hljs-keyword">primary</span> key (id),<br>  <span class="hljs-keyword">constraint</span> u_course_name <span class="hljs-keyword">unique</span> (course_name),<br>  <span class="hljs-keyword">constraint</span> fk_course_tb <span class="hljs-keyword">foreign</span> key(teacher_id) <span class="hljs-keyword">references</span> teacher_tb(id)<br>);<br></code></pre></td></tr></table></figure><br/><h3 id="2-3-操作约束"><a href="#2-3-操作约束" class="headerlink" title="2.3 操作约束"></a>2.3 操作约束</h3><h4 id="2-3-1-增加约束"><a href="#2-3-1-增加约束" class="headerlink" title="2.3.1 增加约束"></a>2.3.1 增加约束</h4><p>如果增加的是除 not null 以外的约束，需要使用 alter table 的 add 子句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name<br><span class="hljs-keyword">add</span> [<span class="hljs-keyword">constraint</span> constraint_name] constraint_type (column1, column2...);<br><br><span class="hljs-comment">-- 给 teacher_tb 表的 teacher_name 加上一个 unique 约束</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher_tb<br><span class="hljs-keyword">add</span> <span class="hljs-keyword">unique</span> (teacher_name);<br></code></pre></td></tr></table></figure><p>如果增加 not null 约束，那么必须使用 alter 语句的 modify 子句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name<br>modify column1 [<span class="hljs-keyword">constraint</span> constraint_name] <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">-- 给 course_tb 表的 course_name 加上一个 not null 约束</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> course_tb<br>modify course_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><br/><h4 id="2-3-2-修改约束名"><a href="#2-3-2-修改约束名" class="headerlink" title="2.3.2 修改约束名"></a>2.3.2 修改约束名</h4><p>在同一个方案中，约束名必须惟一，并且约束名也不能与其他对象同名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name<br>rename <span class="hljs-keyword">constraint</span> old_constraint_name <span class="hljs-keyword">to</span> new_constraint_name;<br><br><span class="hljs-comment">-- 修改 teacher_tb 表的 teacher_name 的约束的约束名</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher_tb<br>rename <span class="hljs-keyword">constraint</span> n_teacher_name <span class="hljs-keyword">to</span> un_teacher_name;<br><br><span class="hljs-comment">-- 修改 course_tb 表的 course_name 的约束的约束名</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> course_tb<br>rename <span class="hljs-keyword">constraint</span> u_course_name <span class="hljs-keyword">to</span> un_course_name;<br><br></code></pre></td></tr></table></figure><br/><h4 id="2-3-3-删除约束"><a href="#2-3-3-删除约束" class="headerlink" title="2.3.3 删除约束"></a>2.3.3 删除约束</h4><p>当删除特定表的主键约束时，如果该表具有相关的从表，那么在删除主键约束时必须带有 cascade 选项。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">constraint</span> constraint_name <span class="hljs-operator">|</span> <span class="hljs-keyword">primary</span> key [cascade];<br><br><span class="hljs-comment">-- 删除 teacher_tb 表中 teacher_name 的约束</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher_tb<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">constraint</span> un_teacher_name;<br><br><span class="hljs-comment">-- 删除 teacher_tb 表的主键约束</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> teacher_tb<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">primary</span> key cascade;<br><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> TEACHER_TB<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">constraint</span> pk_teacher_tb cascade ;<br></code></pre></td></tr></table></figure><br/><h4 id="2-3-4-禁用约束"><a href="#2-3-4-禁用约束" class="headerlink" title="2.3.4 禁用约束"></a>2.3.4 禁用约束</h4><p>禁止约束指使约束临时失效。当禁止了约束之后，约束规则将不再生效。在使用 sql * loader 或 insert 装载数据之前，为了加快数据装载速度，应该首先禁止约束，然后装载数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-comment">-- cascade 用于指定级联禁止从表的外键约束</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name<br>disable <span class="hljs-keyword">constraint</span> constraint_name [cascade];<br><br><span class="hljs-comment">-- 禁用 course_tb 表的 description 的约束</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> course_name<br>disable <span class="hljs-keyword">constraint</span> n_description;<br></code></pre></td></tr></table></figure><br/><h4 id="2-3-5-激活约束"><a href="#2-3-5-激活约束" class="headerlink" title="2.3.5 激活约束"></a>2.3.5 激活约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name<br>enable <span class="hljs-keyword">constraint</span> constraint_name;<br><br><span class="hljs-comment">-- 激活 course_tb 表的 description 的约束</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> course_name<br>enable <span class="hljs-keyword">constraint</span> n_description;<br><br></code></pre></td></tr></table></figure><br/><h3 id="2-4-约束的状态"><a href="#2-4-约束的状态" class="headerlink" title="2.4 约束的状态"></a>2.4 约束的状态</h3><h4 id="2-4-1-状态类型"><a href="#2-4-1-状态类型" class="headerlink" title="2.4.1 状态类型"></a>2.4.1 状态类型</h4><p>很多时候由于业务需要，比如我们有大量的历史数据，需要和现有数据合并。当前表存在数据库约束（如非空约束），而这些历史数据又包含违背非空约束的数据行，为了避免导入时由于违反约束而导入失败，我们通过调整约束状态来达到目的。</p><p>数据库约束有两类状态：</p><ul><li><p><strong>启用/禁用（enable/disable）</strong>：是否对新变更的数据启用约束验证。</p></li><li><p><strong>验证/非验证 (validate/novalidate)</strong> ：是否对表中已客观存在的数据进行约束验证。</p></li></ul><br/>这两类四种状态从语法角度讲可以随意组合，默认是 enable 和 validate。<table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>enable validate</td><td>默认的约束组合状态，无法添加违反约束的数据行，数据表中也不能存在违反约束的数据行。</td></tr><tr><td>enable  novalidate</td><td>无法添加违反约束的数据行，但对已存在的违反约束的数据行不做验证。</td></tr><tr><td>disable validate</td><td>可以添加违反约束的数据行，但对已存在的违反约束的数据行会做约束验证。从描述中可以看出来，这本来就是一种相互矛盾的约束组合，只不过是语法上支持这种组合罢了，造成的结果就是会导致 DML 失败。</td></tr><tr><td>disable novalidate</td><td>可以添加违法约束的数据行，对已存在的违反约束的数据行也不做验证。</td></tr></tbody></table><br/><h4 id="2-4-2-修改状态"><a href="#2-4-2-修改状态" class="headerlink" title="2.4.2 修改状态"></a>2.4.2 修改状态</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 语法</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name<br>modify <span class="hljs-keyword">constraint</span> constraint_name state1 state2;<br><br><span class="hljs-comment">-- 修改 course_tb 表的 description 的约束的状态为 disable novalidate</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> course_tb<br>modify <span class="hljs-keyword">constraint</span> n_description disable novalidate;<br></code></pre></td></tr></table></figure><br/><h2 id="3-表"><a href="#3-表" class="headerlink" title="3. 表"></a>3. 表</h2><h3 id="2-1-命名规则"><a href="#2-1-命名规则" class="headerlink" title="2.1 命名规则"></a>2.1 命名规则</h3><p>表和列的命名规则：</p><ul><li>名字中只能出现字母、数字、下划线（_）和井号（#）。</li><li>必须是字母开头。</li><li>不能是数据库中的关键字。</li><li>长度必须在 1 ~ 30 个字符之间。</li><li>不能和数据库中已有的对象重名。</li></ul><br/><h3 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h3><p>Oracle 数据库中常用的几种数据类型：</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td><code>char(size)</code></td><td>定长的字符串。size 用于指定字符串的最大长度，size 的值必须是正整数且不超过 32767。字符串长度没有达到 size 用空格填充。</td></tr><tr><td><code>varchar(size)</code></td><td>变长的字符串。size 用于指定字符串的最大长度，字符串长度没有达到 size 不会填充。可以存空字符串和 null。</td></tr><tr><td><code>varchar2(size)</code></td><td>变长的字符串。varchar2 是 Oracle 数据库特有的类型。用法和 varchar 一样，但是不能存储空字符串。</td></tr><tr><td><code>number(p, s)</code></td><td>数字。p 表示最大位数（整数位 + 小数位）。s 表示保留的小数位（四舍五入），也可以为负数。可以直接使用 number，不加参数。</td></tr><tr><td><code>date</code></td><td>日期类型。</td></tr><tr><td><code>blob</code></td><td>存二进制对象，例如视频，音频，图片等。</td></tr><tr><td><code>clob</code></td><td>存储大文本，例如很多很多文字。</td></tr></tbody></table><h3 id="3-3-创建表"><a href="#3-3-创建表" class="headerlink" title="3.3 创建表"></a>3.3 创建表</h3><p>创建表的格式有两种：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 格式1</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>    字段名 数据类型 [列约束类型],<br>    字段名 数据类型 [列约束类型],<br>    字段名 数据类型 [列约束类型],<br>    字段名 数据类型 [列约束类型],<br>    ...   ...      ...<br>    字段名 数据类型 [列约束类型]<br>);<br><br><span class="hljs-comment">-- 格式2</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(<br>    字段名 数据类型 [列约束类型],<br>    字段名 数据类型 [列约束类型],<br>    字段名 数据类型 [列约束类型],<br>    ...    ...      ...<br>    字段名 数据类型 [列约束类型],<br>    [表级约束],<br>    ...<br>    [表级约束]<br>);<br></code></pre></td></tr></table></figure><br/><p>例 1：创建一个学生表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 格式 1：使用列级约束</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student_tb(<br>id        number        <span class="hljs-keyword">primary</span> key,                    <span class="hljs-comment">-- 主键</span><br>  name      varchar2(<span class="hljs-number">30</span>)  <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,                       <span class="hljs-comment">-- 非空</span><br>  email     varchar2(<span class="hljs-number">30</span>)  <span class="hljs-keyword">unique</span>,                         <span class="hljs-comment">-- 唯一</span><br>  gender    <span class="hljs-type">char</span>(<span class="hljs-number">1</span>)       <span class="hljs-keyword">check</span>(gender <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)),    <span class="hljs-comment">-- check 约束</span><br>  age       number,<br>  birthday  <span class="hljs-type">date</span><br>);<br><br><span class="hljs-comment">-- 格式 2：使用表级约束</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student_tb(<br>id      number,<br>name    varchar2(<span class="hljs-number">30</span>)   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  age     number  <span class="hljs-keyword">default</span> <span class="hljs-number">20</span>,<br>  email   varchar2(<span class="hljs-number">30</span>),<br>  gender  <span class="hljs-type">char</span>,<br>  <br>  <span class="hljs-keyword">primary</span> key(id),       <span class="hljs-comment">-- 主键</span><br>  <span class="hljs-keyword">unique</span>(email),<span class="hljs-comment">-- 唯一 </span><br>  <span class="hljs-keyword">check</span>(gender <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>))  <span class="hljs-comment">-- check 约束</span><br>);<br><br><span class="hljs-comment">-- not null 只能是列级约束，不能是表级约束</span><br></code></pre></td></tr></table></figure><br/><p>例 2：顾客表和订单表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer_tb(<br>id    number         <span class="hljs-keyword">primary</span> key,<br>  name  varchar2(<span class="hljs-number">30</span>)   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-comment">-- 方式 1：使用列级约束声明外键</span><br>creat <span class="hljs-keyword">table</span> order_tb(<br>id           number          <span class="hljs-keyword">primary</span> key,<br>  content      varchar2(<span class="hljs-number">30</span>)    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  customer_id  number  <span class="hljs-keyword">references</span> customer_tb(id)<br>);<br><br><span class="hljs-comment">-- 方式 2：使用表级约束声明外键</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_tb(<br>id           number,<br>    content      varchar2(<span class="hljs-number">30</span>)  <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  customer_id  number,<br>  <span class="hljs-keyword">primary</span> key (id),<br>  <span class="hljs-keyword">foreign</span> key (customer_id) <span class="hljs-keyword">references</span> customer_tb (id)<br>);<br></code></pre></td></tr></table></figure><ul><li>一个顾客对应多分订单，所以外键在订单表中。订单表中的外键列 customer_id 的值，是引用自顾客表中的主键列 id 的值。</li><li>不能直接删除顾客表，因为订单表引用了顾客表的主键做外键。应当删除订单表再删除顾客表。</li></ul><br/><h3 id="3-4-修改表"><a href="#3-4-修改表" class="headerlink" title="3.4 修改表"></a>3.4 修改表</h3><h3 id="3-5-删除表"><a href="#3-5-删除表" class="headerlink" title="3.5 删除表"></a>3.5 删除表</h3><h3 id="3-4-操作表"><a href="#3-4-操作表" class="headerlink" title="3.4 操作表"></a>3.4 操作表</h3><h4 id="3-4-1-DML-语句"><a href="#3-4-1-DML-语句" class="headerlink" title="3.4.1 DML 语句"></a>3.4.1 DML 语句</h4><p>DML (Date Manipulation Language) 数据操作语言。</p><p>DML 用于改变数据库中的数据，主要包括：insert，update，delete。</p><br/><h4 id="3-4-2-insert-插入数据"><a href="#3-4-2-insert-插入数据" class="headerlink" title="3.4.2 insert 插入数据"></a>3.4.2 insert 插入数据</h4><p>向表中插入数据，语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name [(column1, column2...)] <span class="hljs-keyword">values</span> (val1, val2, ...);<br></code></pre></td></tr></table></figure><p><strong>插入的值的顺序和列声明的顺序一致，数据类型必须和列声明的数据类型一致，并且不能违背列的约束。</strong></p><br/><p>例 1：向学生表里插入数据（全部列）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 全部插入</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student_tb <br><span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;121@163.com&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">22</span>, to_date(<span class="hljs-string">&#x27;2021-07-14&#x27;</span>, <span class="hljs-string">&#x27;yyyy-mm-dd&#x27;</span>));<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student_tb <br><span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;123@163.com&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">21</span>, to_date(<span class="hljs-string">&#x27;2021-03-14&#x27;</span>, <span class="hljs-string">&#x27;yyyy-mm-dd&#x27;</span>));<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student_tb <br><span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;124@163.com&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">23</span>, to_date(<span class="hljs-string">&#x27;2021-04-14&#x27;</span>, <span class="hljs-string">&#x27;yyyy-mm-dd&#x27;</span>));<br></code></pre></td></tr></table></figure><br/><p>例 2：向学生表里插入数据（指定列）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 向指定列插入数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student_tb (id, name) <br><span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;赵六&#x27;</span>)；<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student_tb (id, name) <br><span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;王麻子&#x27;</span>)；<br></code></pre></td></tr></table></figure><p>没有插入数据的列的值为 null。</p><br/><p>例 3：向学生表里插入数据（特殊）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 把查询的结果，插入到学生表中</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t_user(id,name,birthday)<br><span class="hljs-keyword">select</span> id, last_name, start_date<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><h4 id="3-4-3-update-更新数据"><a href="#3-4-3-update-更新数据" class="headerlink" title="3.4.3 update 更新数据"></a>3.4.3 update 更新数据</h4><p>修改表中的数据，语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">update table_name <br><span class="hljs-keyword">set</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2 ... <br><span class="hljs-keyword">where</span> ...;<br></code></pre></td></tr></table></figure><p>使用 update 修改数据也不能违背列的约束。</p><br/><p>例：修改学生表中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改张三的名字和年龄</span><br>update student_tb<br><span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张山&#x27;</span>, age <span class="hljs-operator">=</span> <span class="hljs-number">30</span><br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 修改李四的邮箱</span><br>update student_tb<br><span class="hljs-keyword">set</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1234@163.com&#x27;</span><br><span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br></code></pre></td></tr></table></figure><br/><h4 id="3-4-5-delete-删除数据"><a href="#3-4-5-delete-删除数据" class="headerlink" title="3.4.5 delete 删除数据"></a>3.4.5 delete 删除数据</h4><p>删除表中的数据，语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> table_name [where...];<br></code></pre></td></tr></table></figure><p>如果不加条件，就表示把表中所有数据删除。加了条件就删除符合条件的所有数据。</p><br/><p>例：删除学生表中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除名字是张山的学生</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student_tb <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张山&#x27;</span>;<br><br><span class="hljs-comment">-- 删除年龄是 21 的所有学生</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student_tb <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">21</span>;<br><br><span class="hljs-comment">-- 删除表中的所有数据</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student_tb;<br></code></pre></td></tr></table></figure><br/><h3 id="3-5-有外键的表的-DML"><a href="#3-5-有外键的表的-DML" class="headerlink" title="3.5 有外键的表的 DML"></a>3.5 有外键的表的 DML</h3><p>创建两个表用于测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建客户表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> customer_tb(<br>id    number         <span class="hljs-keyword">primary</span> key,<br>  name  varchar2(<span class="hljs-number">30</span>)   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>);<br><br><span class="hljs-comment">-- 创建订单表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> order_tb(<br>id           number          <span class="hljs-keyword">primary</span> key,<br>  content      varchar2(<span class="hljs-number">30</span>)    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>  customer_id  number  <span class="hljs-keyword">references</span> customer_tb(id)<br>);<br></code></pre></td></tr></table></figure><br/><h4 id="3-5-1-insert-插入数据"><a href="#3-5-1-insert-插入数据" class="headerlink" title="3.5.1 insert 插入数据"></a>3.5.1 insert 插入数据</h4><p>向父表（外键所在的表）插入数据，外键列的值必须是子表（被引用的表）的被引用的列中有的数据，或者为 null （如果允许的话）。</p><p>例：向客户表中插入数据。<br>向客户表中插入数据不会对订单表有影响。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 向客户表中插入一些数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> customer_tb <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;张三&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> customer_tb <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;李四&#x27;</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> customer_tb <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;王五&#x27;</span>);<br></code></pre></td></tr></table></figure><br/><p>例：向订单表中插入数据。<br>要保证订单表中 customer_id 的数据是客户表中 id 列中存在的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_tb <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;内容&#x27;</span>, <span class="hljs-number">1</span>);  <br><span class="hljs-comment">-- 插入成功</span><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_tb <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;内容&#x27;</span>, <span class="hljs-number">4</span>); <br><span class="hljs-comment">-- 报错，因为客户表中没有 id = 4 的客户</span><br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> order_tb <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;内容&#x27;</span>, <span class="hljs-keyword">null</span>); <br><span class="hljs-comment">-- 插入成功，因为 customer_id 列可以为 null</span><br></code></pre></td></tr></table></figure><br/><h4 id="3-5-2-update-更新数据"><a href="#3-5-2-update-更新数据" class="headerlink" title="3.5.2 update 更新数据"></a>3.5.2 update 更新数据</h4><p>和插入数据一样，更新数据也必须保证：父表的外键列的值必须是子表的被引用的列中有的数据，或者为 null （如果允许的话）。</p><p>例：修改订单表中的数据。<br>要保证订单表中 customer_id 的数据是客户表中 id 列中存在的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">update order_tb <span class="hljs-keyword">set</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 报错，因为客户表中没有 id = 4 的客户</span><br><br>update order_tb <span class="hljs-keyword">set</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 成功，因为客户表中有 id = 3 的客户</span><br><br>update order_tb <span class="hljs-keyword">set</span> customer_id <span class="hljs-operator">=</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 成功，customer_id 列可以为 null</span><br></code></pre></td></tr></table></figure><br/><p>例：修改客户表中的数据。<br>如果修改了客户表中的 id，导致订单表里 customer_id 列的某个数据不在 id 列中，会报违反完整性约束的错误。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">update customer_tb <span class="hljs-keyword">set</span> id <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-comment">-- ORA-02292: 违反完整约束条件 (SEAL.SYS_C007501)</span><br></code></pre></td></tr></table></figure><br/><h4 id="3-5-3-delete-删除数据"><a href="#3-5-3-delete-删除数据" class="headerlink" title="3.5.3 delete 删除数据"></a>3.5.3 delete 删除数据</h4>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>表和约束</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（五）操作结果集</title>
    <link href="/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/7.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%9C%E9%9B%86/"/>
    <url>/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/7.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%9C%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>对结果集的操作：union (并集)、union all (合并)、minus (差集)、intersect (交集)。</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>每一条 select 语句查询出的一个结果，都可以被称为结果集。</p><p>如果有两条 SQL 语句，它们分别查询出的结果集，都包含完全一致的字段名称和类型，那么我们可以使用下面的关键字对两个结果集进行操作：</p><ul><li>union：取两个结果集的并集。</li><li>union all：把两个结果集在一起显示出来。</li><li>minus：第一个结果集去除第二个结果集和它相同的部分。</li><li>intersect：求两个结果集的交集。</li></ul><p>前提条件是，两个结果集中查询的列要完全一致（名称和类型）。</p><br/><p>创建两个表用于测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_A (<br>id   number,<br>name  VARCHAR2(<span class="hljs-number">10</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_B (<br>id   number,<br>name  VARCHAR2(<span class="hljs-number">10</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;C&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;D&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;E&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;AA&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;BB&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;CC&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;DD&#x27;</span>);<br><br></code></pre></td></tr></table></figure><br/><h2 id="2-union"><a href="#2-union" class="headerlink" title="2. union"></a>2. union</h2><p>去两个结果集的并集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name<br><span class="hljs-keyword">from</span> t_A<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> id, name<br><span class="hljs-keyword">from</span> t_B<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 结果为</span><br>id     name<br><span class="hljs-comment">----   -----</span><br><span class="hljs-number">1</span>      A<br><span class="hljs-number">1</span>      AA<br><span class="hljs-number">1</span>      BB<br><span class="hljs-number">1</span>      DD<br></code></pre></td></tr></table></figure><br/><h2 id="3-union-all"><a href="#3-union-all" class="headerlink" title="3. union all"></a>3. union all</h2><p>把两个结果集合在一起显示出来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name<br><span class="hljs-keyword">from</span> t_A<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> id, name<br><span class="hljs-keyword">from</span> t_B<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>id     name<br><span class="hljs-comment">----   -----</span><br><span class="hljs-number">1</span>      A<br><span class="hljs-number">1</span>      AA<br><span class="hljs-number">1</span>      BB<br><span class="hljs-number">1</span>      DD<br><span class="hljs-number">1</span>      A<br></code></pre></td></tr></table></figure><br/><h2 id="4-minus"><a href="#4-minus" class="headerlink" title="4. minus"></a>4. minus</h2><p>第一个结果集除去第二个结果集和它相同的部分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name<br><span class="hljs-keyword">from</span> t_A<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>minus<br><span class="hljs-keyword">select</span> id, name<br><span class="hljs-keyword">from</span> t_B<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>id     name<br><span class="hljs-comment">----   -----</span><br><span class="hljs-keyword">null</span>      <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><br/><h2 id="5-intersect"><a href="#5-intersect" class="headerlink" title="5. intersect"></a>5. intersect</h2><p>求两个结果集的交集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name<br><span class="hljs-keyword">from</span> t_A<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">intersect</span><br><span class="hljs-keyword">select</span> id, name<br><span class="hljs-keyword">from</span> t_B<br><span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>id     name<br><span class="hljs-comment">----   -----</span><br><span class="hljs-number">1</span>       A<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作结果集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（八）分页查询</title>
    <link href="/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/10.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/10.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>分页查询的基本用法。</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>因为表中数据过多，我们并不能一次全都查询出来交给前端去展示，而是需要每次按照提前设置好的要求，查询一部分数据给用户，当用户点击下一页的时候，再查出下一部分数据给用户。</p><p>实现分页的方式有很多，并且不同数据库，实现分页查询的方式也会不同，那么在 Oracle 中，可以使用伪列 rownum，再结合子查询来进行简单的实现。</p><br/><h2 id="2-伪列-rownum"><a href="#2-伪列-rownum" class="headerlink" title="2. 伪列 rownum"></a>2. 伪列 rownum</h2><p>Oracle 中有一个特殊的关键字 rownum，被称为伪列。rownum 就像表中的列一样，但是在表中并不存在。伪列并不能像表中真实的列一样随便操作，伪列只能用于查询。</p><p>伪列可以根据查询结果的条数，自动生成，并且一定是从 1 开始连续不断的数字。伪列 rownum的本质就是给查询的每一行的结果标上行号。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> rownum, last_name<br><span class="hljs-keyword">from</span> s_emp;<br><br><span class="hljs-comment">-- 查询结果：</span><br>ROWNUM     LAST_NAME<br><span class="hljs-comment">---------  ---------------</span><br>        <span class="hljs-number">1</span>  Velasquez<br>        <span class="hljs-number">2</span>  Ngao<br>        <span class="hljs-number">3</span>  Nagayama<br>        <span class="hljs-number">4</span>  Ropeburn<br></code></pre></td></tr></table></figure><br/><p>如果伪列用在 where 条件中，那么它只能有以下操作：</p><ul><li><p>rownum 如果是 ‘ = ’ 的条件，那么伪列只能等于 1。</p><p>如果等于其他值，那么就查询不出任何结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> last_name<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> rownum <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><br/></li><li><p>rownum 如果是 ‘ &gt; ’ 的条件，那么伪列只能大于0。</p><p>如果大于其他值，那么就查询不出任何结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> last_name<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> rownum <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><br/></li><li><p>rownum 可以小于任何数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> last_name<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> rownum <span class="hljs-operator">&lt;</span> <span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure></li></ul><p>将来在实际的使用中，伪列 rownum 最核心的作用就是完成分页查询。</p><br/><h2 id="3-使用例"><a href="#3-使用例" class="headerlink" title="3. 使用例"></a>3. 使用例</h2><p>在这 SQL 中，给 rownum 起一个别名 rn，然后把这个 SQL  语句作为第二条 SQL  语句的子查询，并且把它当做一张虚拟的表。那么这时候，这个虚拟表中的 rn 就可以当做普通的字段进行操作了。</p><p>例 1：查询出来 s_emp 表中的第 6~10 条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> t.id, t.last_name, t.dept_id<br><span class="hljs-keyword">from</span> (<br>      <span class="hljs-keyword">select</span> rownum rn, id, last_name, dept_id<br>      <span class="hljs-keyword">from</span> s_emp<br>      <span class="hljs-keyword">where</span> rownum<span class="hljs-operator">&lt;=</span><span class="hljs-number">10</span><br>) t<br><span class="hljs-keyword">where</span> t.rn <span class="hljs-operator">&gt;=</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><br/><p>例 2：查询 s_emp 表中，第 3~7 条数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> t.id, t.last_name, t.dept_id<br><span class="hljs-keyword">from</span> (<br>      <span class="hljs-keyword">select</span> rownum rn, id,last_name, dept_id<br>      <span class="hljs-keyword">from</span> s_emp<br>      <span class="hljs-keyword">where</span> rownum <span class="hljs-operator">&lt;=</span> <span class="hljs-number">7</span><br>) t<br><span class="hljs-keyword">where</span> t.rn <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分页查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（七）子查询</title>
    <link href="/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/9.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/9.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>子查询的基本用法。</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>子查询，也称嵌套查询，即一个 select 语句中嵌套了另外的一个或者多个 select 语句。</p><p>子查询的思路是：把第一个 SQL 语句的查询结果，在第二个 SQL  语句中使用，这时候第一条SQL 语句的结果，在第二条 SQL 中就可以充当一个 where 条件中的一个值，或者充当一张虚拟的表。</p><br/><h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h2><p>例 1：查询工资比 Smith 工资高的员工信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> last_name, salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> ( <br>    <span class="hljs-keyword">select</span> salary<br>    <span class="hljs-keyword">from</span> s_emp<br>    <span class="hljs-keyword">where</span> last_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Smith&#x27;</span><br>);<br></code></pre></td></tr></table></figure><br/><p>例 2：查询平均工资比 41 号部门的平均工资高的部门中员工的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> last_name,salary,dept_id<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span>(<br>    <span class="hljs-keyword">select</span> dept_id<br>    <span class="hljs-keyword">from</span> s_emp<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id<br>    <span class="hljs-keyword">having</span> <span class="hljs-built_in">avg</span>(salary) <span class="hljs-operator">&gt;</span> (<br>        <span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary)<br>        <span class="hljs-keyword">from</span> s_emp<br>        <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> <span class="hljs-number">41</span><br>  )<br>);<br></code></pre></td></tr></table></figure><br/><p>例 3：查询平均工资比 41号部门的平均工资高的部门中员工的信息，并且显示出当前部门的平均工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> se.last_name,se.salary,se.dept_id,temp.avgSal<br><span class="hljs-keyword">from</span> s_emp se,(<br>    <span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">avg</span>(salary) avgSal<br>    <span class="hljs-keyword">from</span> s_emp<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id<br>) temp<br><span class="hljs-keyword">where</span> se.dept_id <span class="hljs-keyword">in</span>(<br>    <span class="hljs-keyword">select</span> dept_id<br>    <span class="hljs-keyword">from</span> s_emp<br>    <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id<br>    <span class="hljs-keyword">having</span> <span class="hljs-built_in">avg</span>(salary)<span class="hljs-operator">&gt;</span>(<br>        <span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary)<br>        <span class="hljs-keyword">from</span> s_emp<br>        <span class="hljs-keyword">where</span> dept_id<span class="hljs-operator">=</span><span class="hljs-number">41</span><br>    )<br>) <span class="hljs-keyword">and</span> se.dept_id <span class="hljs-operator">=</span> temp.dept_id;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>子查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（六）聚合函数</title>
    <link href="/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/8.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"/>
    <url>/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/8.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>聚合函数的用法以及 select 各个子句的执行顺序。</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>聚合函数一般会操作多组数据，并对每一组中的某个列，执行计算并返回单一的值。<br>聚合函数经常与 select 语句的 group by 子句一同使用，所以也把其它称之为分组函数。</p><p>常用的聚合函数有：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>avg(列名)</code></td><td>求平均值。</td></tr><tr><td><code>count(列名)</code></td><td>计算有多少条数据。</td></tr><tr><td><code>max(列名)</code></td><td>求最大值。</td></tr><tr><td><code>min(列名)</code></td><td>求最小值。</td></tr><tr><td><code>sum(列名)</code></td><td>求和。</td></tr></tbody></table><br/><h2 id="2-执行顺序"><a href="#2-执行顺序" class="headerlink" title="2. 执行顺序"></a>2. 执行顺序</h2><p>一个完整的 select 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2.</span>..<br><span class="hljs-keyword">from</span> 表<br><span class="hljs-keyword">where</span> 条件<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 分组条件<br><span class="hljs-keyword">having</span> 分组筛选条件<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 排序条件<br></code></pre></td></tr></table></figure><br/><p>select 语句的执行顺序：</p><ul><li>from 子句</li><li>where 子句</li><li>group by 子句</li><li>聚合函数</li><li>having 子句</li><li>select 子句</li><li>order by 子句</li></ul><p>​       基本的工作原理：from 子句先被执行，通过 from 子句获得一个虚拟表，然后通过 where 子句从虚拟表中获取满足条件的记录，生成新的虚拟表。将新虚拟表中的记录通过 group by 子句分组后得到更新的虚拟表，而后 having 子句在最新的虚拟表中筛选出满足条件的记录组成另外一个虚拟表中，select 子句会将指定的列提取出来组成更新的虚拟表，最后 order by 子句对其进行排序得出最终的虚拟表。通常这个最终的虚拟表被称为查询结果集。</p><br/><h2 id="3-聚合函数的位置"><a href="#3-聚合函数的位置" class="headerlink" title="3. 聚合函数的位置"></a>3. 聚合函数的位置</h2><p>聚合函数能够出现的位置： </p><ul><li>select 后面 </li><li>having 后面 </li><li>order by后面</li></ul><p>如果 select、having 语句后面出现了聚合函数，那么 select、having 后面没有被组函数修饰的 列，就必须出现在 group by 后面。</p><br/><h2 id="4-各个子句的关系"><a href="#4-各个子句的关系" class="headerlink" title="4. 各个子句的关系"></a>4. 各个子句的关系</h2><h3 id="4-1-where-和-having"><a href="#4-1-where-和-having" class="headerlink" title="4.1 where 和 having"></a>4.1 where 和 having</h3><ul><li>where 和 having 都是做条件筛选的。 </li><li>where 执行的时间比 having 要早。</li><li>where 后面不能出现组函数。</li><li>having 后面可以出现组函数。</li><li>where 语句要紧跟 from 后面。</li><li>having 语句要紧跟 group by 后面。</li></ul><br/><h3 id="4-2-group-by-和-having"><a href="#4-2-group-by-和-having" class="headerlink" title="4.2 group by 和 having"></a>4.2 group by 和 having</h3><ul><li>group by 可以单独存在，后面可以不出现 having 语句。</li><li>having不能单独存在，如果需要出现，那么就必须出现在 group by 后面。</li></ul><br/><h3 id="4-3-order-by"><a href="#4-3-order-by" class="headerlink" title="4.3 order by"></a>4.3 order by</h3><ul><li>如果 SQL 语句中需要排序，那么就一定要写在 SQL 语句的最后面。</li><li>order by 后也可以出现组函数。</li></ul><br/><h2 id="5-实例"><a href="#5-实例" class="headerlink" title="5. 实例"></a>5. 实例</h2><h3 id="5-1-group-by"><a href="#5-1-group-by" class="headerlink" title="5.1 group by"></a>5.1 group by</h3><p>在使用聚合函数的时候： </p><ul><li>如果还使用了 group by 分组，那么就表示先分组，然后对每一个小组使用聚合函数。</li><li>如果没有使用 group by 分组，那么就表示全部数据是一个默认小组，然后对这个全部数据使用聚合函数。</li></ul><br/><p>例 1：查询 s_emp 表中所有员工的平均工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary)<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><p>例 2：查询 s_emp 表中每个部门的平均工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">avg</span>(salary)<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id;<br></code></pre></td></tr></table></figure><br/><p>例 3：查询 s_emp 表中每个部门员工的最高工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">max</span>(salary)<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id;<br></code></pre></td></tr></table></figure><br/><p>例 4：查询 s_emp 表中每个部门员工的工资总和。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">sum</span>(salary)<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id;<br></code></pre></td></tr></table></figure><br/><p>例 5：查询 s_emp 表中每个部门员工的人数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id;<br></code></pre></td></tr></table></figure><br/><h3 id="5-2-having"><a href="#5-2-having" class="headerlink" title="5.2 having"></a>5.2 having</h3><p>例 1：查询 s_emp 表中部门的平均工资大于等于 1400 的部门。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">avg</span>(salary)<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">avg</span>(salary)<span class="hljs-operator">&gt;=</span><span class="hljs-number">1400</span>;<br></code></pre></td></tr></table></figure><br/><p>例 2：查询 s_emp 表中部门的总工资大于等于 4000 的部门。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> dept_id,<span class="hljs-built_in">sum</span>(salary)<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">sum</span>(salary)<span class="hljs-operator">&gt;=</span><span class="hljs-number">4000</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>聚合函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（四）多表查询</title>
    <link href="/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/6.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/07/12/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/6.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>表相互连接的方式：等值连接、外连接和自连接。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>多表查询，又称表联合查询，即一条 SQL 语句涉及到的表有多张，表中的数据通过特定的连接，进行联合显示。</p><br/><h2 id="2-笛卡尔积"><a href="#2-笛卡尔积" class="headerlink" title="2. 笛卡尔积"></a>2. 笛卡尔积</h2><p>在数学中，两个集合 X 和 Y 的笛卡尓积表示为 X × Y。</p><p>在数据库中如果直接查询两张表，那么其查询结果就会产生笛卡尔积。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- s_emp表中25条数据，s_dept表中12条数据，查询两张表，数据两两组合，会得到300条数据。</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> s_emp,s_dept;<br></code></pre></td></tr></table></figure><p>其实 s_emp 表中的每一条数据和 s_dept 表中的每一条数据进行两两组合，这里面大多数的数据是没有意义的。为了这种避免笛卡尔积的产生，在多表查询的时候，可以使用连接查询来解决这个问题。</p><br/><h2 id="3-连接查询"><a href="#3-连接查询" class="headerlink" title="3. 连接查询"></a>3. 连接查询</h2><h3 id="3-1-等值连接"><a href="#3-1-等值连接" class="headerlink" title="3.1 等值连接"></a>3.1 等值连接</h3><p>利用一张表中某列的值和另一张表中某列的值相等的关系，把两张表连接起来，满足条件的数据才会组合。</p><p>例如：查询员工的名字、部门编号、部门名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> se.last_name, se.dept_id, sd.id, sd.name<br><span class="hljs-keyword">from</span> s_emp se, s_dept sd<br><span class="hljs-keyword">where</span> se.dept_id <span class="hljs-operator">=</span> sd.id;<br></code></pre></td></tr></table></figure><br/><h3 id="3-2-不等值连接"><a href="#3-2-不等值连接" class="headerlink" title="3.2 不等值连接"></a>3.2 不等值连接</h3><p>假设数据库中还有一张工资等级表 salgrade。</p><p>工资等级表 salgrade ：</p><ul><li>gradeName 列表示等级名称。</li><li>losal 列表示这个级别的最低工资数。 </li><li>hisal 列表示这个级别的最高工资数。</li></ul><p>假设，表中的数据类似于下面内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span> salgrade losal hisal<br><span class="hljs-attribute">1</span> 初级程序员 <span class="hljs-number">2000</span> <span class="hljs-number">4000</span><br><span class="hljs-attribute">2</span> 中级程序员 <span class="hljs-number">4000</span> <span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><br/><p>例如：查询出员工的名字、职位、工资、工资等级名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.last_name, e.title, e.salray, s.gradeName<br><span class="hljs-keyword">from</span> s_emp e, salgrade s<br><span class="hljs-keyword">where</span> e.salray betweeb s.losal <span class="hljs-keyword">and</span> s.hisal<br></code></pre></td></tr></table></figure><br/><h3 id="3-3-外连接"><a href="#3-3-外连接" class="headerlink" title="3.3 外连接"></a>3.3 外连接</h3><p>创建两张表用于测试：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_A (<br>    id number,<br>    name VARCHAR2(<span class="hljs-number">10</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_B (<br>    id  number,<br>    name VARCHAR2(<span class="hljs-number">10</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;B&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;C&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;D&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_A <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;E&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;AA&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;BB&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;CC&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t_B <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;DD&#x27;</span>);<br></code></pre></td></tr></table></figure><br/><h4 id="3-3-1-左外连接"><a href="#3-3-1-左外连接" class="headerlink" title="3.3.1 左外连接"></a>3.3.1 左外连接</h4><p>左外连接是以左表的记录为基础的，该表的内容会全部显示，然后加上左表和右表匹配的内容。</p><p>示例中 t_A 可以看成左表，t_B 可以看成右表。结果集是 t_A 表中的全部数据，再加上 t_A 表和t_B 表匹配后的数据。换句话说，左表 (t_A) 的记录将会全部表示出来，而右表 (t_B) 只会显示符合搜索条件的记录。t_B 表记录不足的地方均为 NULL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> t_A a <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> t_B b <br><span class="hljs-keyword">on</span> a.id <span class="hljs-operator">=</span> b.id;<br><br><span class="hljs-comment">-- 结果为</span><br>ID    NAME   ID    NAME<br><span class="hljs-comment">----  ----   ----  ----</span><br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    AA<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    BB<br> <span class="hljs-number">2</span>     B       <span class="hljs-number">2</span>    CC<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    DD<br> <span class="hljs-number">4</span>     D       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br> <span class="hljs-number">5</span>     E       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br> <span class="hljs-number">3</span>     C       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><BR/><p>也可以用 + 来实现。这个 + 号可以这样来理解： + 表示补充，即哪个表有加号，这个表就是匹配表。如果加号写在右表，左表就是全部显示，所以是左连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> t_A a, t_B b <br><span class="hljs-keyword">where</span> a.id <span class="hljs-operator">=</span> b.id(<span class="hljs-operator">+</span>);<br><br><span class="hljs-comment">-- 结果为</span><br>ID    NAME   ID    NAME<br><span class="hljs-comment">----  ----   ----  ----</span><br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    AA<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    BB<br> <span class="hljs-number">2</span>     B       <span class="hljs-number">2</span>    CC<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    DD<br> <span class="hljs-number">4</span>     D       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br> <span class="hljs-number">5</span>     E       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br> <span class="hljs-number">3</span>     C       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><br/><h4 id="3-3-2-右外连接"><a href="#3-3-2-右外连接" class="headerlink" title="3.3.2 右外连接"></a>3.3.2 右外连接</h4><p>与左外连接相反，右外连接是以右表的记录为基础的，该表的内容会全部显示，然后加上右表和左表匹配的内容。</p><p>示例中 t_A 可以看成左表，t_B 可以看成右表。结果集是 t_B 表中的全部数据，再加上 t_A 表和t_B 表匹配后的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> t_A a <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> t_B b <br><span class="hljs-keyword">on</span> a.id <span class="hljs-operator">=</span> b.id;<br><br><span class="hljs-comment">-- 结果为</span><br>ID    NAME   ID    NAME<br><span class="hljs-comment">----  ----   ----  ----</span><br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    AA<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    BB<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    DD<br> <span class="hljs-number">2</span>     B       <span class="hljs-number">2</span>    CC<br></code></pre></td></tr></table></figure><br/><p>用（+）来实现。这个 + 号可以这样来理解： + 表示补充，即哪个表有加号，这个表就是匹配表。如果加号写在左表，右表就是全部显示，所以是右连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> t_A a, t_B b <br><span class="hljs-keyword">where</span> a.id(<span class="hljs-operator">+</span>) <span class="hljs-operator">=</span> b.id;<br><br><span class="hljs-comment">-- 结果为</span><br>ID    NAME   ID    NAME<br><span class="hljs-comment">----  ----   ----  ----</span><br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    AA<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    BB<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    DD<br> <span class="hljs-number">2</span>     B       <span class="hljs-number">2</span>    CC<br></code></pre></td></tr></table></figure><br/><h4 id="3-3-3-全连接"><a href="#3-3-3-全连接" class="headerlink" title="3.3.3 全连接"></a>3.3.3 全连接</h4><p>左表和右表都不做限制，所有的记录都显示，两表不足的地方均为 NULL。 全外连接不支持（+）写法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">from</span> t_A a <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> t_B b <br><span class="hljs-keyword">on</span> a.id <span class="hljs-operator">=</span> b.id; <br><br><span class="hljs-comment">-- 结果为</span><br>ID    NAME   ID    NAME<br><span class="hljs-comment">----  ----   ----  ----</span><br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    AA<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    BB<br> <span class="hljs-number">2</span>     B       <span class="hljs-number">2</span>    CC<br> <span class="hljs-number">1</span>     A       <span class="hljs-number">1</span>    DD<br> <span class="hljs-number">4</span>     D       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br> <span class="hljs-number">5</span>     E       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br> <span class="hljs-number">3</span>     C       <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><br/><h3 id="3-4-自连接"><a href="#3-4-自连接" class="headerlink" title="3.4 自连接"></a>3.4 自连接</h3><p>自连接就是一张表，自己和自己连接后进行查询。</p><p>例如：查询每个员工的名字以及员工对应的管理者的名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s1.last_name, s2.last_name manager_name<br><span class="hljs-keyword">from</span> s_emp s1, s_emp s2<br><span class="hljs-keyword">where</span> s1.manager_id <span class="hljs-operator">=</span> s2.id;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多表查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（三）单行函数和转换函数</title>
    <link href="/2021/07/10/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/5.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2021/07/10/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/5.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>单行函数也被称为单值函数，每操作一行数据（某个字段值）都会返回结果。</p><p>转换函数可以将一个类型的数据，转换为另一种类型的数据。</p><span id="more"></span><h2 id="1-哑表"><a href="#1-哑表" class="headerlink" title="1. 哑表"></a>1. 哑表</h2><p>Oracle 数据库中有一张特殊的表：dual（哑表）。</p><p>dual 之所以被称为哑表，是因为它是一个 <strong>Oracle 内部自动创建的单行单列的虚拟表</strong>。这个表中只有一个列 dummy ，其数据类型为 verchar2(1)。Oracle 右内部逻辑保证 dual 表中永远只有一条数据，且<strong>只有 Oracle 数据库中有哑表</strong>。</p><br/><p>在实际的使用中，dual 表主要是用来选择系统变量或求一个表达式的值。</p><p>例如：求表达式 1+1 的结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">selet <span class="hljs-number">1</span><span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><p>按照 SQL 语句的要求，没有表就没法查询，而表达式 1+1 不属于任何表，那么可以使用哑表。</p><br/><h2 id="2-单行函数"><a href="#2-单行函数" class="headerlink" title="2. 单行函数"></a>2. 单行函数</h2><p>单行函数也被称为单值函数，每操作一行数据（某个字段值）都会返回员工结果。<br>单值函数可以分为：字符函数、日期函数和数值函数。</p><h3 id="2-1-字符函数"><a href="#2-1-字符函数" class="headerlink" title="2.1 字符函数"></a>2.1 字符函数</h3><p>常用的字符函数有：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>lower(x)</code></td><td>将字符串 x 转为小写。</td></tr><tr><td><code>upper(x)</code></td><td>将字符串 x 转为大写。</td></tr><tr><td><code>initcap(x)</code></td><td>将字符串 x 的首字母转为大写。</td></tr><tr><td><code>length(x)</code></td><td>获取字符串 x 的长度。</td></tr><tr><td><code>ascll(x)</code></td><td>返回字符串的 ASCII 码。</td></tr><tr><td><code>concat(x, y)</code></td><td>连接两个字符串 x 和 y。</td></tr><tr><td><code> replace(x, old_str, new_str)</code></td><td>在字符串 x 中用 new_str 替换 old_str。</td></tr><tr><td><code>lpad(x, width [,pad_str])</code></td><td>指定字符串 x 的长度。不够长度时，在左边填充。</td></tr><tr><td><code>rpad(x, width [,pad_str])</code></td><td>指定字符串 x 的长度。不够长度时，在右边填充。</td></tr><tr><td><code>trim([trim_str from] x)</code></td><td>把 x 的两边截去 trim_str 字符串，缺省截去空格。</td></tr><tr><td><code>ltrim(x [,trim_str])</code></td><td>把 x 的左边截取 trim_str 字符串，缺省截去空格。</td></tr><tr><td><code>rtrim(x [,trim_str])</code></td><td>把 x 的右边截取 trim_str 字符串，缺省截去空格。</td></tr><tr><td><code>instr(x, str [, start] [,n])</code></td><td>从 x 中查找 str。<br/>可以指定从 start 开始，也可以指定从 n 开始。</td></tr><tr><td><code>substr(x, start [,length])</code></td><td>在字符串 x 上截取一个子串。<br/>start 是开始位置，length 是截取的长度。<br/>缺省 length ，默认到结尾。</td></tr></tbody></table><br/><h4 id="2-1-1-lower"><a href="#2-1-1-lower" class="headerlink" title="2.1.1 lower"></a>2.1.1 lower</h4><p><code>lower(x)</code>：将字符串 x 转为小写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;HELLO WORLD&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为 </span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-----------</span><br>hello world<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-2-upper"><a href="#2-1-2-upper" class="headerlink" title="2.1.2 upper"></a>2.1.2 upper</h4><p><code>upper(x)</code>：将字符串 x 转为大写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为 </span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-----------</span><br>HELLO WORLD<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-3-initcap"><a href="#2-1-3-initcap" class="headerlink" title="2.1.3 initcap"></a>2.1.3 initcap</h4><p><code>initcap(x)</code>：将字符串 x 的首字母转为大写，其他字母小写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> initcap(<span class="hljs-string">&#x27;hELLO WORLD&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为 </span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-----------</span><br>Hello world<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-4-length"><a href="#2-1-4-length" class="headerlink" title="2.1.4 length"></a>2.1.4 length</h4><p><code>length(x)</code>：获取字符串 x 的长度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> length(<span class="hljs-string">&#x27;hello world&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为 </span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br>    <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-1-5-ascii"><a href="#2-1-5-ascii" class="headerlink" title="2.1.5 ascii"></a>2.1.5 ascii</h4><p><code>ascii(x)</code>：获取字符 x 的 ascii 码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ascii(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为 </span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">------</span><br>    <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-1-6-concat"><a href="#2-1-6-concat" class="headerlink" title="2.1.6 concat"></a>2.1.6 concat</h4><p><code>concat(x, y)</code>：连接连个字符串 x 和 y。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;world&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为 </span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-----------</span><br>helloworld<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-7-replace"><a href="#2-1-7-replace" class="headerlink" title="2.1.7 replace"></a>2.1.7 replace</h4><p><code>replace(x, old_str, new_str)</code>：在字符串 x 中用 new_str 替代 old_str。</p><p>情况 1：字符串 x 中不存在 old_str。则执行后的结果是 x。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> replace(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>hello<br></code></pre></td></tr></table></figure> <br/><p>情况 2：不写 new_str，执行结果为在 x 中去掉了 old_str。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> replace(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 相当于</span><br><span class="hljs-keyword">select</span> replace(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>hllo<br></code></pre></td></tr></table></figure><br/><p>情况 3：正常情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> replace(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>habcllo<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-8-lpad-和-rpad"><a href="#2-1-8-lpad-和-rpad" class="headerlink" title="2.1.8 lpad 和 rpad"></a>2.1.8 lpad 和 rpad</h4><p><code>lpad(x, width [,pad_str])</code>：指定字符串 x 的长度。不够长度时，如果没有指定填充字符，则使用空格在左边填充。如果指定了填充字符就使用填充字符在左边填充。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不指定 pad_str 将会用空格进行填充。</span><br><span class="hljs-keyword">select</span> lpad(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>     hello<br><br><span class="hljs-comment">-- 指定 pad_str</span><br><span class="hljs-keyword">select</span> lpad(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>aaaaahello<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-9-trim"><a href="#2-1-9-trim" class="headerlink" title="2.1.9 trim"></a>2.1.9 trim</h4><p><code>trim([trim_str from] x)</code>：把 x 的两边截去 trim_str 字符（1个），缺省截去空格。</p><p>情况 1：不指定 trim_str。截去 x 两边的所有空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;   hello   &#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>hello<br></code></pre></td></tr></table></figure><br/><p>情况 2：trim_str 为空字符串，执行的结果也为空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><br/><p>情况 3：trim_str 不为空串，但是 x 两边没有 trim_str。如果这时 x 两边有空格，则会两边各去掉一个空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 含有空格</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;h&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;  hello  &#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br> hello <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不含有空格</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>hello<br></code></pre></td></tr></table></figure><br/><p>情况 4：trim_str 不为空串，但是 x 只有一边含有 trim_str。如果这时 x 的另外边有空格，则会在这边去掉一个空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 含有空格</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;h&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hello  &#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>ello <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不含有空格</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;h&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;h&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;elloh&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>ello<br></code></pre></td></tr></table></figure><br/><p>情况 5：trim_str 不为空串，但是不是一个字符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;hel&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><span class="hljs-comment">-- 报错，ORA-30001: 截取集仅能有一个字符。</span><br></code></pre></td></tr></table></figure><br/><p>情况 6：正常情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27;h&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;helloh&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>ello<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-10-ltrim-和-rtrim"><a href="#2-1-10-ltrim-和-rtrim" class="headerlink" title="2.1.10 ltrim 和 rtrim"></a>2.1.10 ltrim 和 rtrim</h4><p><code>ltrim(x [,trim_str])</code>：把 x 的左边截取 trim_str 字符串，缺省截去空格。</p><p>情况 1：trim_str 的长度比 x 长。执行结果为 null。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ltrim(<span class="hljs-string">&#x27;h&#x27;</span> , <span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><br/><p>情况 2：trim_str 为空。执行结果为 null。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ltrim(<span class="hljs-string">&#x27;hello&#x27;</span> , <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><br/><p>情况 3：trim_str 与 x 相同。执行结果为 null。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ltrim(<span class="hljs-string">&#x27;hello&#x27;</span> , <span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><br/><p>情况 4：x 和 trim_str 从左边第一个字符开始一一比较，没有相同的部分。执行结果就是 x。但如果 x 的左边含有空格，则会截去一个空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不含有空格</span><br><span class="hljs-keyword">select</span> ltrim(<span class="hljs-string">&#x27;hello&#x27;</span> , <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>hello<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 含有空格</span><br><span class="hljs-keyword">select</span> ltrim(<span class="hljs-string">&#x27;   hello&#x27;</span> , <span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>  hello<br></code></pre></td></tr></table></figure><br/><p>情况 5：正常情况。</p><p>x 和 trim_str 从左边第一个字符开始一一比较，只会截去相同的部分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> ltrim(<span class="hljs-string">&#x27;hello&#x27;</span> , <span class="hljs-string">&#x27;ha&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">--------</span><br>ello<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-11-instr"><a href="#2-1-11-instr" class="headerlink" title="2.1.11 instr"></a>2.1.11 instr</h4><p><code>instr(x, str [, start] [,n])</code>：从 x 中查找 str。可以指定从 start 开始，也可以指定从 n 开始。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> instr(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>运行结果：<br><span class="hljs-keyword">RESULT</span><br><span class="hljs-comment">----------</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> instr(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">6</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 从前往后查找，从下标为6开始</span><br><span class="hljs-comment">-- 运行结果：</span><br><span class="hljs-keyword">RESULT</span><br><span class="hljs-comment">----------</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> instr(<span class="hljs-string">&#x27;Hello World&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">-1</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 从后往前查找，从最后一个开始</span><br><span class="hljs-comment">-- 运行结果：</span><br><span class="hljs-keyword">RESULT</span><br><span class="hljs-comment">----------</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-1-12-substr"><a href="#2-1-12-substr" class="headerlink" title="2.1.12 substr"></a>2.1.12 substr</h4><p><code>substr(x, start [,length])</code>：在字符串 x 上截取一个子串。start 是开始位置，length 是截取的长度。缺省 length ，默认到结尾。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> substr(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 运行结果：</span><br><span class="hljs-keyword">RESULT</span><br><span class="hljs-comment">------</span><br>ell<br></code></pre></td></tr></table></figure><br/><h3 id="2-2-数值函数"><a href="#2-2-数值函数" class="headerlink" title="2.2 数值函数"></a>2.2 数值函数</h3><p>专门操作数字的函数，常用的数字函数有：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>abs(x)</code></td><td>x 的绝对值。</td></tr><tr><td><code>cos(x)</code></td><td>x 的反余弦。</td></tr><tr><td><code>acos(x)</code></td><td>x 的余弦。</td></tr><tr><td><code>sin(x)</code></td><td>x 的正弦。</td></tr><tr><td><code>asin(x)</code></td><td>x 的反正弦。</td></tr><tr><td><code>ceil(x)</code></td><td>大于或等于X的最小值(整数)。</td></tr><tr><td><code>floor(x)</code></td><td>小于或等于X的最大值(整数)。</td></tr><tr><td><code>round(x [,y])</code></td><td>x 在第 y 位四舍五入。</td></tr><tr><td><code>trunc(x [,y])</code></td><td>x 在第 y 位截断。</td></tr><tr><td><code>power(x,y)</code></td><td>x 的 y 次幂。</td></tr><tr><td><code>sqrt(x)</code></td><td>x 的平方根。</td></tr><tr><td><code>log(x,y)</code></td><td>x 为底 y 的对数。</td></tr><tr><td><code>mod(x,y)</code></td><td>x 除以 y 的余数。</td></tr></tbody></table><br/><h4 id="2-2-1-ceil"><a href="#2-2-1-ceil" class="headerlink" title="2.2.1 ceil"></a>2.2.1 ceil</h4><p><code>ceil(x)</code>：大于或等于 X 的最小值(整数)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">3.14</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-2-2-floor"><a href="#2-2-2-floor" class="headerlink" title="2.2.2 floor"></a>2.2.2 floor</h4><p><code>floor(x)</code>：小于或等于 X 的最小值(整数)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">3.14</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="2-2-3-round"><a href="#2-2-3-round" class="headerlink" title="2.2.3 round"></a>2.2.3 round</h4><p><code>round(x [, y])</code>：x 在 y 为四舍五入。</p><ul><li>x 表示要进行四舍五入操作的数字。</li><li>y 表示要保留到哪一位，默认是 0 ，即保留到个位。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 保留到小数点后两位。</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-number">3.1415926</span> , <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">3.14</span><br><br><span class="hljs-comment">-- 保留到个位</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-number">3.1415926</span>, <span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">3</span><br><br><span class="hljs-comment">-- 保留到十位</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-number">31.4</span>, <span class="hljs-number">-1</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-2-4-trunc"><a href="#2-2-4-trunc" class="headerlink" title="2.2.4 trunc"></a>2.2.4 trunc</h4><p><code>trunc(x [,y])</code>：x 在第 y 位截断。</p><p>trunc 的用法和 round 基本一样，但是 trunc 只会舍去不会进位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 截取到小数点后面两位</span><br><span class="hljs-keyword">select</span> trunc(<span class="hljs-number">3.141526</span> , <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-2-5-mod"><a href="#2-2-5-mod" class="headerlink" title="2.2.5 mod"></a>2.2.5 mod</h4><p><code>mod(x, y)</code>：x 除以 y 的余数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 10 除以 3 的余数</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 结果为</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br/><h3 id="2-3-日期函数"><a href="#2-3-日期函数" class="headerlink" title="2.3 日期函数"></a>2.3 日期函数</h3><h4 id="2-3-1-sysdate"><a href="#2-3-1-sysdate" class="headerlink" title="2.3.1 sysdate"></a>2.3.1 sysdate</h4><p>sysdate 是 Oracle 中用来表示当前时间的关键字，并且可以使用它来参与时间运算。 sysdate 参与时间的加减操作的时候，单位是天。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 显示当前时间</span><br><span class="hljs-keyword">select</span> sysdate <span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 显示明天这个时候的时间</span><br><span class="hljs-keyword">select</span> sysdate <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 显示昨天这个时候的时间</span><br><span class="hljs-keyword">select</span> sysdate <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 显示 1 小时之后的时间</span><br><span class="hljs-keyword">select</span> sysdate <span class="hljs-operator">+</span> <span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">24</span> <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><br/><h4 id="2-3-2-常用的日期函数"><a href="#2-3-2-常用的日期函数" class="headerlink" title="2.3.2 常用的日期函数"></a>2.3.2 常用的日期函数</h4><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>months_between(x, y)</code></td><td>求两个日期之间相差的月数。</td></tr><tr><td><code>add_months(x, y)</code></td><td>返回一个日期数据：表示一个时间点，往后推 x 月的日期。</td></tr><tr><td><code>next_day(x, 星期 y)</code></td><td>返回一个日期数据：表示一个时间点后的下一个星期几在哪一天。</td></tr><tr><td><code>last_day(x)</code></td><td>返回一个日期数据：表示一个日期所在月份的最后一天。</td></tr><tr><td><code>round(x, y)</code></td><td>对日期进四舍五入，返回操作后的日期数据。</td></tr><tr><td><code>trunc(x, y)</code></td><td>对日期进行截取和 round 类似，但是只舍弃不进位。</td></tr></tbody></table><br/><h4 id="2-3-3-months-between"><a href="#2-3-3-months-between" class="headerlink" title="2.3.3 months_between"></a>2.3.3 months_between</h4><p><code>months_between(x, y)</code>：求两个日期之间相差的月数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 31 天之后和现在相差了多少个月。</span><br><span class="hljs-keyword">select</span> months_between(sysdate<span class="hljs-operator">+</span><span class="hljs-number">31</span> , sysdate) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 运行结果</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-3-4-add-months"><a href="#2-3-4-add-months" class="headerlink" title="2.3.4 add_months"></a>2.3.4 add_months</h4><p><code>add_months(x, y)</code>：返回一个日期数据：表示一个时间点，往后推 x 月的日期。 y 也可以是负数，表示之前多少月</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 两个月后的日期</span><br><span class="hljs-keyword">select</span> add_months(sysdate , <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span> <br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 运行结果</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">2021</span><span class="hljs-number">-09</span><span class="hljs-number">-11</span> <span class="hljs-number">10</span>:<span class="hljs-number">18</span>:<span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-3-5-next-day"><a href="#2-3-5-next-day" class="headerlink" title="2.3.5 next_day"></a>2.3.5 next_day</h4><p><code>next_day(x, 星期)</code>：返回一个日期数据：表示一个时间点后的下一个星期几在哪一天。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 离当前时间最近的下一个星期5是哪一个天</span><br><span class="hljs-keyword">select</span> next_day(sysdate, <span class="hljs-string">&#x27;星期五&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-keyword">alter</span> session <span class="hljs-keyword">set</span> nls_language<span class="hljs-operator">=</span>english;<br><span class="hljs-keyword">select</span> next_day(sysdate, <span class="hljs-string">&#x27;FRIDAY&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 运行结果</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">2021</span><span class="hljs-number">-07</span><span class="hljs-number">-16</span> <span class="hljs-number">10</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-3-6-last-day"><a href="#2-3-6-last-day" class="headerlink" title="2.3.6 last_day"></a>2.3.6 last_day</h4><p><code>last_day(x)</code>：返回一个日期数据：表示一个日期所在月份的最后一天。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 当前月的最后一天</span><br><span class="hljs-keyword">select</span> last_day(sysdate)<br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 运行结果</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">2021</span><span class="hljs-number">-07</span><span class="hljs-number">-31</span> <span class="hljs-number">10</span>:<span class="hljs-number">27</span>:<span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-3-7-round"><a href="#2-3-7-round" class="headerlink" title="2.3.7 round"></a>2.3.7 round</h4><p><code>round(x, y)</code>：对日期进四舍五入，返回操作后的日期数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 把当前日期四舍五入到月</span><br><span class="hljs-keyword">select</span> round(sysdate, <span class="hljs-string">&#x27;MONTH&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 运行结果</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">2021</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br><br><br><span class="hljs-comment">-- 把当前日期四舍五入到年</span><br><span class="hljs-keyword">select</span> round(sysdate, <span class="hljs-string">&#x27;YEAR&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 运行结果</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><br/><h4 id="2-3-8-trunc"><a href="#2-3-8-trunc" class="headerlink" title="2.3.8 trunc"></a>2.3.8 trunc</h4><p><code>trunc(x, y)</code>：对日期进行截取和 round 类似，但是只舍弃不进位。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> trunc(sysdate,<span class="hljs-string">&#x27;MONTH&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-comment">-- 运行结果</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">2021</span><span class="hljs-number">-07</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br><br><br><span class="hljs-keyword">select</span> trunc(sysdate,<span class="hljs-string">&#x27;YEAR&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br><span class="hljs-comment">-- 运行结果</span><br><span class="hljs-keyword">result</span><br><span class="hljs-comment">-------</span><br><span class="hljs-number">2022</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><br/><h2 id="3-转换函数"><a href="#3-转换函数" class="headerlink" title="3. 转换函数"></a>3. 转换函数</h2><p>转换函数可以将一个类型的数据，转换为另一种类型的数据。</p><p>转换函数主要有三种： </p><ul><li>to_char 把一个数字或日期数据转换为字符。</li><li>to_number 把字符转换为数字。</li><li>to_date 把字符转换为日期。</li></ul><br/><h3 id="3-1-to-char"><a href="#3-1-to-char" class="headerlink" title="3.1 to_char"></a>3.1 to_char</h3><h4 id="3-1-1-数字转换为字符"><a href="#3-1-1-数字转换为字符" class="headerlink" title="3.1.1 数字转换为字符"></a>3.1.1 数字转换为字符</h4><p>数字转为字符的常用格式：</p><table><thead><tr><th>格式</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>9</td><td>999</td><td>指定位置处显示数字。</td></tr><tr><td>.</td><td>9.9</td><td>指定位置显示小数点。</td></tr><tr><td>，</td><td>99,999</td><td>指定位置显示逗号。</td></tr><tr><td>$</td><td>$999</td><td>数字开头显示一个美元符号。</td></tr><tr><td>L</td><td>L999</td><td>数字开头显示一个本地的货币符号。</td></tr><tr><td>PR</td><td>999PR</td><td>如果数字式负数则用尖括号进行表示。</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> to_char(salary,<span class="hljs-string">&#x27;$999,999.00&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> s_emp;<br><br><span class="hljs-keyword">select</span> to_char(salary,<span class="hljs-string">&#x27;L999,999.00&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> s_emp;<br><br><span class="hljs-keyword">select</span> to_char(<span class="hljs-number">-10</span>,<span class="hljs-string">&#x27;999PR&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><br/><h4 id="3-1-2-日期转换为字符"><a href="#3-1-2-日期转换为字符" class="headerlink" title="3.1.2 日期转换为字符"></a>3.1.2 日期转换为字符</h4><p>日期转换为字符的常用格式：</p><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>yyyy</td><td>四位数的年份。</td></tr><tr><td>rrrr</td><td>四位数的年份。</td></tr><tr><td>yy</td><td>两位数的年份。</td></tr><tr><td>rr</td><td>两位数的年份。</td></tr><tr><td>mm</td><td>两位数的月份（数据）。</td></tr><tr><td>D</td><td>一周的星期几。</td></tr><tr><td>DD</td><td>一个月的第几天。</td></tr><tr><td>DDD</td><td>一年的第几天。</td></tr><tr><td>YEAR</td><td>英文的年份。</td></tr><tr><td>MONTH</td><td>英文的全称月份。</td></tr><tr><td>mon</td><td>英文的简称月份。</td></tr><tr><td>ddsp</td><td>英文的第几天（一个月的）。</td></tr><tr><td>ddspth</td><td>英文序列数的第几天（一个月的）。</td></tr><tr><td>DAY</td><td>英文的全称星期（monday, tuesday…）</td></tr><tr><td>DY</td><td>英文的简称星期（mon, tues…）</td></tr><tr><td>hh</td><td>小时</td></tr><tr><td>mi</td><td>分钟</td></tr><tr><td>ss</td><td>秒</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> to_char(sysdate,<span class="hljs-string">&#x27;yyyy mm MONTH mon MON D DD DDD DAY DY&#x27;</span>)<br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-keyword">select</span> to_char(sysdate,<span class="hljs-string">&#x27;dd-mm-yy&#x27;</span>)<br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-keyword">select</span> to_char(sysdate,<span class="hljs-string">&#x27;yy-mm-dd&#x27;</span>)<br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-keyword">select</span> to_char(sysdate,<span class="hljs-string">&#x27;yy-mm-dd hh:mi:ss&#x27;</span>)<br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-keyword">select</span> to_char(sysdate,<span class="hljs-string">&#x27;yy-mm-dd hh24:mi:ss&#x27;</span>)<br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-keyword">select</span> to_char(sysdate,<span class="hljs-string">&#x27;yy-mm-dd hh:mi:ss AM&#x27;</span>)<br><span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><br/><h3 id="3-2-to-number"><a href="#3-2-to-number" class="headerlink" title="3.2 to_number"></a>3.2 to_number</h3><p><code>to_number(字符)</code>：把字符转换为数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> to_number(<span class="hljs-string">&#x27;1000&#x27;</span>)<br><span class="hljs-keyword">from</span> dual;<br><br><span class="hljs-keyword">select</span> to_number(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><br/><h3 id="3-3-to-date"><a href="#3-3-to-date" class="headerlink" title="3.3 to_date"></a>3.3 to_date</h3><p><code>to_date(字符串, 日期格式)</code>：把字符转换为日期。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> to_date(<span class="hljs-string">&#x27;10-12-2022&#x27;</span>,<span class="hljs-string">&#x27;dd-mm-yyyy&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">alter</span> session <span class="hljs-keyword">set</span> nls_language<span class="hljs-operator">=</span><span class="hljs-string">&#x27;simplified chinese&#x27;</span>;<br><span class="hljs-keyword">select</span> to_date(<span class="hljs-string">&#x27;25-5月-22&#x27;</span>,<span class="hljs-string">&#x27;dd-month-yy&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> session <span class="hljs-keyword">set</span> nls_language<span class="hljs-operator">=</span><span class="hljs-string">&#x27;simplified chinese&#x27;</span>;<br><span class="hljs-keyword">select</span> to_date(<span class="hljs-string">&#x27;22/5月/25&#x27;</span>,<span class="hljs-string">&#x27;yy/month/dd&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> session <span class="hljs-keyword">set</span> nls_language<span class="hljs-operator">=</span>english;<br><span class="hljs-keyword">select</span> to_date(<span class="hljs-string">&#x27;25-MAY-22&#x27;</span>,<span class="hljs-string">&#x27;dd-MONTH-yy&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><br/><h3 id="3-4-千年虫问题"><a href="#3-4-千年虫问题" class="headerlink" title="3.4 千年虫问题"></a>3.4 千年虫问题</h3><p>在早期的计算机的程序中，规定了的年份仅用两位数来表示。 假如是 1971 年，在计算机里就会被表示为 71。 但是到了 2000 年的时候这个情况就出现了问题，计算机读取出之前存的一个日期88，结果就是 2088 年。 这样的话，计算机内部对年份的计算就会出现问题，这个事情当时被称为千年虫。</p><p>为了处理这个问题，后面就有了一种新的日期格式：rr 。<br>如果在存储日期数据的时候，年份采用的格式为 rr，并且只提供了最后 2 位年份，那么年份中的前两位数字就由两部分共同确定，其规则如下：</p><ul><li><p>规则 1：<br>如果指定年在 00 ~ 49 之间，并且当前年份在 00 ~ 49 之间，那么指定年的世纪就与当前年份的世纪相同。因此，指定年的前两位数字就等于当前年份的前两位数字。例如：如果指定年为15，而当前年 份为 2007，那么指定年就是 2015。</p></li><li><p>规则 2：<br>如果指定年在 50 ~ 99 之间，并且当前年份在 00 ~ 49 之间，那么指定年的世纪就等于当前年份的世纪减去1。因此，指定年的前两位数字等于当前年份的前两位数字减去 1。例如：如果指定年为 75，而当 前年份为 2007，那么指定年就是 1975 。</p></li><li><p>规则 3：<br>如果指定年在 00 ~ 49 之间，并且当前年份在 50 ~ 99 之间，那么指定年的世纪就等于当前年份的世纪加 上1。因此，指定年的前两位数字等于当前年份的前两位数字加上 1。例如：如果指定年为 15，而当 前年份为 2075，那么指定年就是 2115。</p></li><li><p>规则 4：<br>如果指定年在 50 ~ 99 之间，并且当前年份在 50~99 之间，那么指定年的世纪就与当前年份的世纪相同。因此，指定年的前两位数字就等于当前年份的前两位数字。例如：如果指定年为 55，而当前年 份为 2075，那么指定年就是 2055。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单行函数和转换函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（二）查询</title>
    <link href="/2021/07/09/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/4.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%20%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/07/09/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/4.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%20%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>select 的基本用法。</p><span id="more"></span><h2 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h2><p>select 语句，可以通过列名，把一行行的数据给查询出来，语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> [<span class="hljs-keyword">distinct</span>] <span class="hljs-operator">*</span>&#123;col_name1,col_name2,..&#125; <span class="hljs-keyword">from</span> tb_name;<br></code></pre></td></tr></table></figure><ul><li>语法中出现的中括号[ ]，表示该部分可有可无。</li><li>*号表示所有列。</li><li> col_name1，col_name2 代表列名，如果有多个可以逗号分开。</li></ul><br/><p>创建 3 个表做示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- s_dept 表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> s_dept(<br>  id NUMBER(<span class="hljs-number">7</span>) <span class="hljs-keyword">CONSTRAINT</span> s_dept_id_nn <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  name VARCHAR2(<span class="hljs-number">25</span>) <span class="hljs-keyword">CONSTRAINT</span> s_dept_name_nn <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  region_id NUMBER(<span class="hljs-number">7</span>),<br>  <span class="hljs-keyword">CONSTRAINT</span> s_dept_id_pk <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>  <span class="hljs-keyword">CONSTRAINT</span> s_dept_name_region_id_uk <span class="hljs-keyword">UNIQUE</span> (name, region_id)<br>);<br><br><span class="hljs-comment">-- s_emp 表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> s_emp(<br>  id NUMBER(<span class="hljs-number">7</span>) <span class="hljs-keyword">CONSTRAINT</span> s_emp_id_nn <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  last_name VARCHAR2(<span class="hljs-number">25</span>) <span class="hljs-keyword">CONSTRAINT</span> s_emp_last_name_nn <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  first_name VARCHAR2(<span class="hljs-number">25</span>),<br>  userid VARCHAR2(<span class="hljs-number">8</span>),<br>  start_date <span class="hljs-type">DATE</span>,<br>  comments VARCHAR2(<span class="hljs-number">255</span>),<br>  manager_id NUMBER(<span class="hljs-number">7</span>),<br>  title VARCHAR2(<span class="hljs-number">25</span>),<br>  dept_id NUMBER(<span class="hljs-number">7</span>),<br>  salary NUMBER(<span class="hljs-number">11</span>, <span class="hljs-number">2</span>),<br>  commission_pct NUMBER(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>),<br>  <span class="hljs-keyword">CONSTRAINT</span> s_emp_id_pk <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>  <span class="hljs-keyword">CONSTRAINT</span> s_emp_userid_uk <span class="hljs-keyword">UNIQUE</span> (userid),<br>  <span class="hljs-keyword">CONSTRAINT</span> s_emp_commission_pct_ck<br>  <span class="hljs-keyword">CHECK</span> (commission_pct <span class="hljs-keyword">IN</span> (<span class="hljs-number">10</span>, <span class="hljs-number">12.5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17.5</span>, <span class="hljs-number">20</span>))<br>);<br><br><span class="hljs-comment">-- s_region 表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> s_region(<br>  id NUMBER(<span class="hljs-number">7</span>) <span class="hljs-keyword">CONSTRAINT</span> s_region_id_nn <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  name VARCHAR2(<span class="hljs-number">50</span>) <span class="hljs-keyword">CONSTRAINT</span> s_region_name_nn <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">CONSTRAINT</span> s_region_id_pk <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>  <span class="hljs-keyword">CONSTRAINT</span> s_region_name_uk <span class="hljs-keyword">UNIQUE</span> (name)<br>);<br></code></pre></td></tr></table></figure><br/><p>例 1：查看 s_dept 表中的所有记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> s_dept;<br></code></pre></td></tr></table></figure><br/><p>例 2：查看 s_dept 表中的指定字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, name, region_id<br><span class="hljs-keyword">from</span> s_dept;<br></code></pre></td></tr></table></figure><br/><p>例 3：查看所有员工的 id，名字和薪水。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><h3 id="1-1-运算"><a href="#1-1-运算" class="headerlink" title="1.1 运算"></a>1.1 运算</h3><p>在查询的同时可以对列进行运算，但是 select 语句永远不会对原始数据进行修改。</p><p>例 1：查询每个员工的id，姓名和年薪。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<span class="hljs-operator">*</span><span class="hljs-number">12</span><br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><p>例 2：查看每个员工的 id，名字和月薪涨100以后的年薪。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, (salary <span class="hljs-operator">+</span> <span class="hljs-number">100</span>)<span class="hljs-operator">*</span><span class="hljs-number">12</span><br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><h3 id="1-2-别名"><a href="#1-2-别名" class="headerlink" title="1.2 别名"></a>1.2 别名</h3><p>可以使用 as 为表和列起别名。as 可以省略。</p><p>例 1：查询员工的 id，名字和年薪 annual。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<span class="hljs-operator">*</span><span class="hljs-number">12</span> <span class="hljs-keyword">as</span> annual<br><span class="hljs-keyword">from</span> s_emp;<br><br><span class="hljs-comment">-- 也可以省略 as </span><br><span class="hljs-keyword">select</span> id, last_name, salary<span class="hljs-operator">*</span><span class="hljs-number">12</span> annual<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><h3 id="1-3-拼接"><a href="#1-3-拼接" class="headerlink" title="1.3 拼接"></a>1.3 拼接</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col_name<span class="hljs-operator">||</span><span class="hljs-string">&#x27;spe_char&#x27;</span><span class="hljs-operator">||</span>col_name <span class="hljs-keyword">from</span> tb_name;<br></code></pre></td></tr></table></figure><p>例 1：查看员工的 id 和全名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, first_name <span class="hljs-operator">||</span> last_name<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><p>例 2：查看员工的 id，全名和职位名称。全名和职位名称合并成一列显示，且格式为：姓名，职位名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, first_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-operator">||</span> last_name <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;,&#x27;</span> title <span class="hljs-keyword">as</span> name<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><h3 id="1-4-nvl-函数"><a href="#1-4-nvl-函数" class="headerlink" title="1.4 nvl 函数"></a>1.4 nvl 函数</h3><p>使用 nvl 函数可以将 null 进行替换。语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> nvl(col_name, change_value) <span class="hljs-keyword">from</span> tb_name;<br></code></pre></td></tr></table></figure><br/><p>例 1：查看所有员工的 id，名字和提成。如果提成为空，显示为 0。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, nvl(commission_pct , <span class="hljs-number">0</span>) commission_pct<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><h3 id="1-5-distinct-关键字"><a href="#1-5-distinct-关键字" class="headerlink" title="1.5 distinct 关键字"></a>1.5 distinct 关键字</h3><p>使用 distinct 关键字可以对查询的结果进行去重。语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> col_name, col_name...<br><span class="hljs-keyword">from</span> tb_name;<br></code></pre></td></tr></table></figure><p>如果 distinct 关键词后面如果出现多列，表示多列联合去重，即多列的值都相同的时候才会认为是重复的记录。</p><br/><p>例 1：查看所有员工的职位名称和部门id，同职位同部门的只显示一次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> dept_id , title<br><span class="hljs-keyword">from</span> s_emp;<br></code></pre></td></tr></table></figure><br/><h2 id="2-排序-order-by"><a href="#2-排序-order-by" class="headerlink" title="2. 排序 order by"></a>2. 排序 order by</h2><p>查询数据的时候进行排序，就是根据某个字段的值，按照升序或者降序的情况将记录显示出来。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col_name, col_name...<br><span class="hljs-keyword">from</span> tb_name<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> col_name [<span class="hljs-keyword">asc</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">desc</span>];<br></code></pre></td></tr></table></figure><ul><li>order by 语句只对查询记录显示调整，并不改变查询结果，所以执行权最低，最后执行。</li><li>排序的默认值是 asc 表示升序，desc 表示降序。</li><li>如果有多个列排序，后面的列排序的前提是前面的列排好序以后有重复（相同）的值。</li></ul><br/><p>例 1：查看员工的id，名字和薪资。按照薪资的降序排序显示，工资相同就按名字升序排。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> salary <span class="hljs-keyword">desc</span> , last_name <span class="hljs-keyword">asc</span>;<br></code></pre></td></tr></table></figure><br/><h2 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h2><h3 id="3-1-基础"><a href="#3-1-基础" class="headerlink" title="3.1 基础"></a>3.1 基础</h3><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> col_name...<br><span class="hljs-keyword">from</span> tb_name<br><span class="hljs-keyword">where</span> col_name ;<br></code></pre></td></tr></table></figure><ul><li>限制查询条件，使用 where 子句。</li><li>条件可以多个，使用逻辑操作符或者小括号进行条件的逻辑整合。</li><li>where 子句的优先级别最高。</li><li>比较操作表达式由操作符和值组成。</li></ul><p>逻辑比较符：<code>=  &gt;  &lt;  &gt;=  &lt;=  !=</code><br>不等比较符：<code>!=  &lt;&gt;  ^=</code></p><br/><p>例 1：查询工资小于 1000 的员工的 id 和名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-operator">&lt;</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><br/><h3 id="3-2-between-and-操作符"><a href="#3-2-between-and-操作符" class="headerlink" title="3.2 between and 操作符"></a>3.2 between and 操作符</h3><p><code>between and</code> 操作符表示在两个值之间。</p><p>例 1：查询工资在 700-1500 之间的员工的 id 和名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> salary <span class="hljs-keyword">between</span> <span class="hljs-number">700</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1500</span>;<br></code></pre></td></tr></table></figure><br/><h3 id="3-3-in-操作符"><a href="#3-3-in-操作符" class="headerlink" title="3.3 in 操作符"></a>3.3 in 操作符</h3><p><code>in()</code> 表示值在一个指定的列表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure><br/><h3 id="3-4-模糊查询"><a href="#3-4-模糊查询" class="headerlink" title="3.4 模糊查询"></a>3.4 模糊查询</h3><p>使用 <code>like</code> 关键字可以用来模糊查询。</p><ul><li><code>%</code> 通配 0 到多个字符。</li><li><code>-</code>通配一个字符，并且是一定要有一个字符。</li><li><code>\</code>转义字符，需要使用 escape 关键字指定。转义字符只能转义后面的一个字符。</li></ul><p>例 1：查看名字以 C 开头的员工 id ，工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> last_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;C%&#x27;</span>;<br></code></pre></td></tr></table></figure><br/><p>例 2：查看名字长度不小于 5，且第 4 个字母为 n 的员工 id 和工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> last_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;---n_%&#x27;</span>;<br></code></pre></td></tr></table></figure> <br/><p>例 3：查看员工名字中包换一个_的员工 id 和工资。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, salary<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> last_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%\-%&#x27;</span> <span class="hljs-keyword">escape</span> <span class="hljs-string">&#x27;\&#x27;</span>;<br></code></pre></td></tr></table></figure><br/><h3 id="3-5-判空"><a href="#3-5-判空" class="headerlink" title="3.5 判空"></a>3.5 判空</h3><p>null 值的判断不能使用等号，必须使用 <code>is null</code>。类似的还有 <code>is not null</code>。</p><p>例 1：查看员工提成为空的员工的 id 和名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, commission_pct<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> commission_pct <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><br/><p>例 2：查看员工提成不为空的员工的 id 和名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id, last_name, commission_pct<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span> commission_pct <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><br/><h3 id="3-6-逻辑操作符"><a href="#3-6-逻辑操作符" class="headerlink" title="3.6 逻辑操作符"></a>3.6 逻辑操作符</h3><p>当条件有多个的时候可以使用逻辑操作符 and（且）和 or（或）。and 的优先级比 or 高。</p><br/><p>例 1：查看员工部门 id 为41且职位名称为 Stock Clerk（存库管理员）的员工 id 和名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,last_name,dept_id,title<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span><br>dept_id <span class="hljs-operator">=</span> <span class="hljs-number">41</span><br><span class="hljs-keyword">and</span><br>title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Stock Clerk&#x27;</span>;<br></code></pre></td></tr></table></figure><br/><p>例 2：查看员工部门为 41 或者 44 号部门，且工资大于 1000 的员工 id 和名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,last_name,dept_id,title<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span><br>salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">and</span><br>( dept_id <span class="hljs-operator">=</span> <span class="hljs-number">41</span> <span class="hljs-keyword">or</span> dept_id <span class="hljs-operator">=</span> <span class="hljs-number">44</span> );<br></code></pre></td></tr></table></figure><br/><p>例 3：查看员工部门为 41 且工资大于 1000，或者 44 号部门的员工 id 和名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,last_name,dept_id,title<br><span class="hljs-keyword">from</span> s_emp<br><span class="hljs-keyword">where</span><br>salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">1000</span><br><span class="hljs-keyword">and</span><br>dept_id <span class="hljs-operator">=</span> <span class="hljs-number">41</span><br><span class="hljs-keyword">or</span><br>dept_id <span class="hljs-operator">=</span> <span class="hljs-number">44</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（十）权限和用户</title>
    <link href="/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/12.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%E6%9D%83%E9%99%90%E5%92%8C%E7%94%A8%E6%88%B7/"/>
    <url>/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/12.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%E6%9D%83%E9%99%90%E5%92%8C%E7%94%A8%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<p>权限管理和角色管理。</p><span id="more"></span><h2 id="1-Oracle-权限分类"><a href="#1-Oracle-权限分类" class="headerlink" title="1. Oracle 权限分类"></a>1. Oracle 权限分类</h2><ul><li>系统权限：系统规定用户使用数据库的权限。（系统权限是对用户而言)。</li><li>实体权限：某种权限用户对其它用户的表或视图的存取权限。（是针对表或视图而言的）。</li></ul><br/><h2 id="2-系统权限管理"><a href="#2-系统权限管理" class="headerlink" title="2. 系统权限管理"></a>2. 系统权限管理</h2><h3 id="2-1-系统权限分类"><a href="#2-1-系统权限分类" class="headerlink" title="2.1 系统权限分类"></a>2.1 系统权限分类</h3><ul><li>DBA：拥有全部特权，是系统最高权限，只有 DBA 才可以创建数据库结构。</li><li>RESOURCE：拥有 RESOURCE 权限的用户只可以创建实体，不可以创建数据库结构。</li><li>CONNECT：拥有 CONNECT 权限的用户只可以登录 Oracle 数据库，不可以创建实体，也不可以创建数据库结构。</li></ul><br/><h3 id="2-2-系统权限授权命令"><a href="#2-2-系统权限授权命令" class="headerlink" title="2.2 系统权限授权命令"></a>2.2 系统权限授权命令</h3><p>系统权限只能由 DBA 用户授出：sys, system (最开始只能是这两个用户)。</p><p>权限授予的 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">connect</span>, resource, dba <span class="hljs-keyword">to</span> username1 [,username2...];<br></code></pre></td></tr></table></figure><p><strong>普通用户通过授权可以具有与 system 相同的用户权限，但永远不能达到与 sys 用户相同的权限，system 用户的权限也可以被回收。</strong></p><br/><h3 id="2-3-系统权限传递"><a href="#2-3-系统权限传递" class="headerlink" title="2.3 系统权限传递"></a>2.3 系统权限传递</h3><p>增加 <code>WITH ADMIN OPTION</code> 选项，则得到的权限可以传递。即被授予权限的用户可以把被授予的权限再次授予其他用户。例如： A 授予 B 权限，B 可以把权限授予 C 权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">connect</span>, resorce <span class="hljs-keyword">to</span> username1 <span class="hljs-keyword">with</span> admin option;<br></code></pre></td></tr></table></figure><br/><h3 id="2-4-系统权限回收"><a href="#2-4-系统权限回收" class="headerlink" title="2.4 系统权限回收"></a>2.4 系统权限回收</h3><p><strong>系统权限只能由DBA用户回收。</strong>其 SQL 语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Revoke</span> <span class="hljs-keyword">connect</span>, resource <span class="hljs-keyword">from</span> username1;<br></code></pre></td></tr></table></figure><br/><p>（1）如果使用 <code>WITH ADMIN OPTION</code> 为某个用户授予系统权限，那么对于被这个用户授予相同权限的所有用户来说，回收该用户的系统权限并不会级联回收这些用户的相同权限。</p><p>（2）<strong>系统权限无级联</strong>，即 A 授予 B 权限，B 授予 C 权限，如果 A 收回 B 的权限，C 的权限不受影响；<strong>系统权限可以跨用户回收</strong>，即 A 可以直接收回 C 用户的权限。</p><br/><h2 id="3-实体权限管理"><a href="#3-实体权限管理" class="headerlink" title="3. 实体权限管理"></a>3. 实体权限管理</h2><h3 id="3-1-实体权限分类"><a href="#3-1-实体权限分类" class="headerlink" title="3.1 实体权限分类"></a>3.1 实体权限分类</h3><p>实体权限有：select, update, insert, alter, index, delete, all (all包括所有权限)，execute (执行存储过程权限)。 <strong>DBA 用户可以操作全体用户的任意基表(无需授权，包括删除)。</strong></p><br/><h3 id="3-2-授予实体权限"><a href="#3-2-授予实体权限" class="headerlink" title="3.2 授予实体权限"></a>3.2 授予实体权限</h3><p>授予实体权限的 SQL 语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> 权限<span class="hljs-number">1</span>, 权限<span class="hljs-number">2</span>,.. <span class="hljs-keyword">on</span> [schema.]对象 <span class="hljs-keyword">to</span> 用户;<br></code></pre></td></tr></table></figure><p>例 1：将 table1 的查询、更新、插入权限授予 user1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>, update, <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> table1 <span class="hljs-keyword">to</span> user1;<br></code></pre></td></tr></table></figure><p>例 2：将 table1 的所有权限授予 user2。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> table1 <span class="hljs-keyword">to</span> user2;<br></code></pre></td></tr></table></figure><p>例 3：将 table1 的所有权限授予所有用户。public 表示是所有的用户，但是这里的 all 权限不包括 drop。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> table1 <span class="hljs-keyword">to</span> public;<br></code></pre></td></tr></table></figure><br/><h3 id="3-3-实体权限的传递"><a href="#3-3-实体权限的传递" class="headerlink" title="3.3 实体权限的传递"></a>3.3 实体权限的传递</h3><p>和系统权限一样，实体权限也可以是使用 <code>with grant option</code> 来实现权限的传递。</p><p>例：将 table1 的查询和更新权限授予 user3。user3 可以将这些权限再授予其他用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>, update <span class="hljs-keyword">on</span> table1 <span class="hljs-keyword">to</span> user3 <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> option; <br></code></pre></td></tr></table></figure><br/><h3 id="3-4-实体权限回收"><a href="#3-4-实体权限回收" class="headerlink" title="3.4 实体权限回收"></a>3.4 实体权限回收</h3><p>回收实体权限的 SQL 语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> 权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2.</span>.. <span class="hljs-keyword">on</span> [schema.]对象 <span class="hljs-keyword">from</span> 用户;<br></code></pre></td></tr></table></figure><br/><p>例 1：回收 user1 对 table1 的查询和更新权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span>, update <span class="hljs-keyword">on</span> table1 <span class="hljs-keyword">from</span> user3;<br></code></pre></td></tr></table></figure><p>如果取消某个用户的对象权限，那么对于这个用户使用 <code>WITH GRANT OPTION</code>授予权限的用户来说，同样还会回收这些用户的相同权限，也就是说回收实体权限授权是级联的。</p><br/><h2 id="4-用户管理"><a href="#4-用户管理" class="headerlink" title="4. 用户管理"></a>4. 用户管理</h2><h3 id="4-1-创建用户的-profile-文件"><a href="#4-1-创建用户的-profile-文件" class="headerlink" title="4.1 创建用户的 profile 文件"></a>4.1 创建用户的 profile 文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br></code></pre></td></tr></table></figure><br/><h3 id="4-2-创建用户"><a href="#4-2-创建用户" class="headerlink" title="4.2 创建用户"></a>4.2 创建用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Create</span> <span class="hljs-keyword">User</span> username     <span class="hljs-comment">-- 用户名</span><br>Identified <span class="hljs-keyword">by</span> password   <span class="hljs-comment">-- 用户的登录口令</span><br><span class="hljs-keyword">Default</span> Tablespace tablespace  <span class="hljs-comment">-- 用户的默认表空间</span><br>Temporary Tablespace tablespace  <span class="hljs-comment">-- 用户的暂时表空间</span><br>Profile profile   <span class="hljs-comment">-- 用户的 profile 文件</span><br>Quota <span class="hljs-type">integer</span><span class="hljs-operator">/</span>unlimited <span class="hljs-keyword">on</span> tablespace; <span class="hljs-comment">-- 拥有表空间</span><br></code></pre></td></tr></table></figure><br/><p>例 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Create</span> <span class="hljs-keyword">user</span> user1<br>identified <span class="hljs-keyword">by</span> user1<br><span class="hljs-keyword">default</span> tablespace account  <br>temporary tablespace temp<br>profile <span class="hljs-keyword">default</span><br>quota <span class="hljs-number">50</span>m <span class="hljs-keyword">on</span> account;<br></code></pre></td></tr></table></figure><br/><h3 id="4-3-修改用户"><a href="#4-3-修改用户" class="headerlink" title="4.3 修改用户"></a>4.3 修改用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">User</span> 用户名<br>Identified 口令<br><span class="hljs-keyword">Default</span> Tablespace tablespace<br>Temporary Tablespace tablespace<br>Profile profile<br>Quota <span class="hljs-type">integer</span><span class="hljs-operator">/</span>unlimited <span class="hljs-keyword">on</span> tablespace;<br></code></pre></td></tr></table></figure><br/><p>例 1：修改口令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">user</span> user1 identified <span class="hljs-keyword">by</span> <span class="hljs-number">12345</span>;<br></code></pre></td></tr></table></figure><br/><p>例 2：修改用户的默认表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">user</span> user1 <span class="hljs-keyword">default</span> tablespace users;<br></code></pre></td></tr></table></figure><br/><p>例 3：修改用户的临时表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">user</span> user1 temporary tablespace temp_data;<br></code></pre></td></tr></table></figure><br/><p>例 4：强制修改用户口令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">user</span> user1 password expire;<br></code></pre></td></tr></table></figure><br/><p>例 5：将用户加锁 / 解锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">user</span> acc01 account lock;  <span class="hljs-comment">-- 加锁</span><br><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">user</span> acc01 account unlock; <span class="hljs-comment">-- 解锁</span><br></code></pre></td></tr></table></figure><br/><h3 id="4-4-删除用户"><a href="#4-4-删除用户" class="headerlink" title="4.4 删除用户"></a>4.4 删除用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> 用户名;  <span class="hljs-comment">-- 用户没有建任何实体</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> 用户名 CASCADE;  <span class="hljs-comment">-- 将用户及其所建实体全部删除</span><br></code></pre></td></tr></table></figure><p><strong>当前正连接的用户不得删除。</strong></p><br/><h3 id="4-5-监视用户"><a href="#4-5-监视用户" class="headerlink" title="4.5 监视用户"></a>4.5 监视用户</h3><p>查询用户会话信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> username, sid, serial#, machine <span class="hljs-keyword">from</span> v$session;<br></code></pre></td></tr></table></figure><br/><p>删除用户会话信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Alter</span> <span class="hljs-keyword">system</span> kill session <span class="hljs-string">&#x27;sid, serial#&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询用户 SQ L语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> user_name, sql_text <span class="hljs-keyword">from</span> v$open_cursor;<br></code></pre></td></tr></table></figure><br/><h2 id="5-角色管理"><a href="#5-角色管理" class="headerlink" title="5. 角色管理"></a>5. 角色管理</h2><p>角色是一组权限的集合，将角色赋给一个用户，这个用户就拥有了这个角色中的所有权限。</p><h3 id="5-1-系统预定义的角色"><a href="#5-1-系统预定义的角色" class="headerlink" title="5.1 系统预定义的角色"></a>5.1 系统预定义的角色</h3><p>预定义角色是在数据库安装后，系统自动创建的一些常用的角色。下介简单的介绍一下这些预定角色。角色所包含的权限可以用以下语句查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> role_sys_privs <span class="hljs-keyword">where</span> role<span class="hljs-operator">=</span><span class="hljs-string">&#x27;角色名&#x27;</span>;<br></code></pre></td></tr></table></figure><br/><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CONNECT</span>, RESOURCE, DBA<br></code></pre></td></tr></table></figure><p>这些预定义角色主要是为了向后兼容。其主要是用于数据库管理。Oracle 建议用户自己设计数据库管理和安全的权限规划，而不要简单的使用这些预定角色。将来的版本中这些角色可能不会作为预定义角色。</p><br/><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELETE_CATALOG_ROLE， EXECUTE_CATALOG_ROLE， SELECT_CATALOG_ROLE<br></code></pre></td></tr></table></figure><p>这些角色主要用于访问数据字典视图和包。</p><br/><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXP_FULL_DATABASE， IMP_FULL_DATABASE<br></code></pre></td></tr></table></figure><p>这两个角色用于数据导入导出工具的使用。</p><br/><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">AQ_USER_ROLE， AQ_ADMINISTRATOR_ROLE<br></code></pre></td></tr></table></figure><p>这两个角色用于 Oracle 高级查询功能。</p><br/><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">SNMPAGENT<br></code></pre></td></tr></table></figure><p>用于oracle enterprise manager 和 Intelligent Agent。</p><br/><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">RECOVERY_CATALOG_OWNER<br></code></pre></td></tr></table></figure><p>用于创建拥有恢复库的用户。关于恢复库的信息。</p><br/><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">HS_ADMIN_ROLE<br></code></pre></td></tr></table></figure><br/><h3 id="5-2-管理角色"><a href="#5-2-管理角色" class="headerlink" title="5.2 管理角色"></a>5.2 管理角色</h3><h4 id="5-2-1-创建角色"><a href="#5-2-1-创建角色" class="headerlink" title="5.2.1 创建角色"></a>5.2.1 创建角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> role 角色名;<br></code></pre></td></tr></table></figure><br/><h4 id="5-2-2-授权给角色"><a href="#5-2-2-授权给角色" class="headerlink" title="5.2.2 授权给角色"></a>5.2.2 授权给角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">any</span> <span class="hljs-keyword">table</span>,<span class="hljs-keyword">create</span> <span class="hljs-keyword">procedure</span> <span class="hljs-keyword">to</span> 角色名;<br></code></pre></td></tr></table></figure><br/><h4 id="5-2-3-授予角色给用户"><a href="#5-2-3-授予角色给用户" class="headerlink" title="5.2.3 授予角色给用户"></a>5.2.3 授予角色给用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> 角色名 <span class="hljs-keyword">to</span> 用户名;<br></code></pre></td></tr></table></figure><br/><h4 id="5-2-4-查看角色所包含的权限"><a href="#5-2-4-查看角色所包含的权限" class="headerlink" title="5.2.4 查看角色所包含的权限"></a>5.2.4 查看角色所包含的权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> role_sys_privs;<br></code></pre></td></tr></table></figure><br/>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>权限和用户</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（十一）同义词</title>
    <link href="/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/13.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%90%8C%E4%B9%89%E8%AF%8D/"/>
    <url>/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/13.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%90%8C%E4%B9%89%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>同义词的概念与基本使用方式。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>​        Oracle 数据库中提供了同义词管理的功能。<strong>同义词是数据库对象的一个别名</strong>，经常用于简化对象访问和提高对象访问的安全性。在使用同义词时，Oracle 数据库将它翻译成对应方案对象的名字。与视图类似，同义词并不占用实际存储空间，只有在数据字典中保存了同义词的定义。在Oracle 数据库中的大部分数据库对象，如表、视图、物化视图、序列、函数、存储过程、包、同义词等等，数据库管理员都可以根据实际情况为他们定义同义词。</p><br/><h2 id="2-同义词分类"><a href="#2-同义词分类" class="headerlink" title="2. 同义词分类"></a>2. 同义词分类</h2><p>​        Oracle 同义词有两种类型，分别是公用同义词和私有同义词。普通用户创建的同义词一般都是私有同义词，公有同义词一般由数据库管理员创建，普通用户如果希望创建同义词，则需要 <code>CREATE PUBLIC SYNONYM</code> 这个系统权限。</p><p>公用同义词：由一个特殊的用户组 Public 所拥有。顾名思义，数据库中所有的用户都可以使用公用同义词。公用同义词往往用来标示一些比较普通的数据库对象，这些对象往往大家都需要引用。但是公共的意思并不是所有的用户都可以访问它，必须被授权后才能进行。</p><p>私有同义词：它是跟公用同义词所对应，他是由创建他的用户所有。当然，这个同义词的创建者，可以通过授权控制其他用户是否有权使用属于自己的私有同义词。</p><br/><h2 id="3-同义词的作用"><a href="#3-同义词的作用" class="headerlink" title="3. 同义词的作用"></a>3. 同义词的作用</h2><p>​        <strong>为分布式数据库的远程对象提供位置透明性。</strong></p><p>​        <strong>在数据库连接中提供位置透明性。</strong></p><p>​        <strong>简化 SQL 语句。</strong>如果自己建的表的名字很长，可以为这个表创建一个同义词来简化开发。</p><p>​        <strong>多用户协同开发中，可以屏蔽对象的名字及其持有者。</strong>如果没有同义词，当操作其他用户的表时，必须通过<code>用户名.对象名</code>的形式。采用了同义词之后就可以隐蔽掉用户名。当然这里要注意的是：公用同义词只是为数据库对象定义了一个公共的别名，其他用户能否通过这个别名访问这个数据库对象，还要看是否已经为这个用户授权。</p><br/><h2 id="4-同义词的操作"><a href="#4-同义词的操作" class="headerlink" title="4. 同义词的操作"></a>4. 同义词的操作</h2><h3 id="4-1-创建同义词"><a href="#4-1-创建同义词" class="headerlink" title="4.1 创建同义词"></a>4.1 创建同义词</h3><p>创建同义词的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [ PUBLIC ] SYNONYM synonym_name <span class="hljs-keyword">FOR</span> [ schema .] object [ <span class="hljs-variable">@db</span>_link ];<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建公有同义词：</span><br><span class="hljs-keyword">create</span> public synonym table_a <span class="hljs-keyword">for</span> test.table_a;<br><br><span class="hljs-comment">-- 创建私有同义词：</span><br><span class="hljs-keyword">create</span> synonym table_b <span class="hljs-keyword">for</span> test.table_b;<br></code></pre></td></tr></table></figure><br/><h3 id="4-2-使用同义词"><a href="#4-2-使用同义词" class="headerlink" title="4.2 使用同义词"></a>4.2 使用同义词</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 使用同义词</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table_a;<br><br><span class="hljs-comment">-- 相当于</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test.table_a<br></code></pre></td></tr></table></figure><ul><li>使用同义词可以保证当数据库的位置或对象名称发生改变时，应用程序的代码保持稳定不变，仅需要改变同义词。</li><li>当使用一个没有指定 schema 的同义词是，首先在用户自己的 schema 中寻找，然后再公共同义词中寻找。</li></ul><br/><h3 id="4-3-编译同义词"><a href="#4-3-编译同义词" class="headerlink" title="4.3 编译同义词"></a>4.3 编译同义词</h3><p>​        当同义词的原对象被重新建立时，同义词需要重新编译。对原对象进行 DDL 操作后，同义词的状态会变成 INVALID；当再次引用这个同义词时，同义词会自动编译，状态会变成VALID，无需人工干预，当然前提是不改变原对象的名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span>  SYNONYM T COMPILE;<br></code></pre></td></tr></table></figure><h3 id="4-4-删除同义词"><a href="#4-4-删除同义词" class="headerlink" title="4.4 删除同义词"></a>4.4 删除同义词</h3><p>删除同义词的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> [ PUBLIC ] SYNONYM [ schema. ] synonym_name [ FORCE ];<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> public synonym table_a;<br><span class="hljs-keyword">drop</span> synonym table_b;<br></code></pre></td></tr></table></figure><p><strong>当同义词的原对象被删除是，同义词并不会被删除。</strong></p><br/><h2 id="5-同义词的权限管理"><a href="#5-同义词的权限管理" class="headerlink" title="5. 同义词的权限管理"></a>5. 同义词的权限管理</h2><p>与同义词相关的权限有 <code>CREATE SYNONYM</code>、<code>CREATE ANY SYNONYM</code>、<code>CREATE PUBLIC SYNONYM</code>。</p><p>（1）用户在自己的模式下创建私有同义词，这个用户必须拥有<code>CREATE SYNONYM</code>权限，否则不能创建私有同义词。</p><p>（2）如果需要在其它模式下创建同义词，则必须具有<code>CREATE ANY SYNONYM</code>的权限。</p><p>（3）创建公有同义词则需要 CREATE PUBLIC SYNONYM 系统权限。</p><br/><h2 id="6-相关的一些问题"><a href="#6-相关的一些问题" class="headerlink" title="6. 相关的一些问题"></a>6. 相关的一些问题</h2><p>（1）公用同义词与私有同义词能否同名呢？如果可以，访问同义词时，是共有同义词还是私有同义词优先？<br>答：可以，如果存在公用同义词和私有同义词同名的情况，在访问同义词是，访问的是私有同义词的指向的对象。</p><br/><p>（2）为什么 OE 用户创建的公用同义词，HR 用户不能访问呢？</p><p>答：因为HR没有访问OE模式下对象的权限，如果OE模式给HR用户赋予了SELECT对象等权限，那么HR用户即可访问。</p>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同义词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 基础（十二）序列</title>
    <link href="/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/14.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%BA%8F%E5%88%97/"/>
    <url>/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/14.%20SQL%20%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>序列的基本概念与使用方法。</p><span id="more"></span><p>在 Oracle 中 sequence 就是序号，每次提取完都会自动增加，步幅固定，它与表没有直接关系！</p><h2 id="1-创建序列"><a href="#1-创建序列" class="headerlink" title="1. 创建序列"></a>1. 创建序列</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> SEQUENCE sequence_name<br>[<span class="hljs-keyword">START</span> <span class="hljs-keyword">WITH</span> num]<br>[INCREMENT <span class="hljs-keyword">BY</span> increment]<br>[MAXVALUE num<span class="hljs-operator">|</span>NOMAXVALUE]<br>[MINVALUE num<span class="hljs-operator">|</span>NOMINVALUE]<br>[<span class="hljs-keyword">CYCLE</span><span class="hljs-operator">|</span>NOCYCLE]<br>[CACHE num<span class="hljs-operator">|</span>NOCACHE]<br></code></pre></td></tr></table></figure><br/><p>START WITH：从某一个整数开始，升序默认值是 1，降序默认值是 -1。</p><p>INCREMENT BY：增长数。如果是正数则升序生成，如果是负数则降序生成。升序默认值是 1，降序默认值是 -1。</p><p>MAXVALUE：指最大值。</p><p>NOMAXVALUE：这是最大值的默认选项，升序的最大值是 1027，降序默认值是 -1。</p><p>MINVALUE：指最小值。</p><p>NOMINVALUE：这是默认值选项，升序默认值是1，降序默认值是-1026。</p><p>CYCLE：表示如果升序达到最大值后，从最小值重新开始；如果是降序序列，达到最小值后，从最大值重新开始。</p><p>NOCYCLE：表示不重新开始，序列升序达到最大值、降序达到最小值后就报错。默认不重新开始。</p><p>CACHE：使用 CACHE 选项时，该序列会根据序列规则预生成一组序列号。保留在内存中，当使用下一个序列号时，可以更快的响应。当内存中的序列号用完时，系统再生成一组新的序列号，并保存在缓存中，这样可以提高生成序列号的效率。Oracle 默认会生产 20 个序列号。使用 CACHE 或许会跳号， 比如数据库突然不正常关掉，内存中的序列号就会丢失。</p><p>NOCACHE：不预先在内存中生成序列号。</p><br/><p>此外，序列中还有个 ORDER 概念，参数分别是：</p><ul><li>ORDER ：保证序列号按请求顺序产生。如果想以序列号作为时间戳类型的话，可以采用该选项。对于将序列用于生成主键来说，约定顺序通常并不重要。</li><li>NOORDER ：此选项跟 ORDER 相对应，并不按照请求的顺序进行生成。</li></ul><br/><h2 id="2-修改序列"><a href="#2-修改序列" class="headerlink" title="2. 修改序列"></a>2. 修改序列</h2><p>​        使用 Alter 可以修改序列的步幅、最大/最小值、是否循环、缓存个数等参数。 但不能修改序列的初始值，且修改的最小值不能大于当前值，最大值不能小于当前值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Alter</span> Sequence seq_name  <br>Increment  <span class="hljs-keyword">By</span>  <span class="hljs-number">2</span> <br>Maxvalue <span class="hljs-number">9999</span><br><span class="hljs-keyword">Cycle</span><br>Cache <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><br/><h2 id="3-使用序列"><a href="#3-使用序列" class="headerlink" title="3. 使用序列"></a>3. 使用序列</h2><p>序列创建完成后，就可以使用其两个参数 currval、nextval；</p><ul><li>currval：返回序列的当前值。</li><li>nextval：增加序列的值，然后返回序列的值。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> seq_name.currval <span class="hljs-keyword">from</span> dual;<br><span class="hljs-keyword">select</span> seq_name.nextval <span class="hljs-keyword">from</span> dual;<br></code></pre></td></tr></table></figure><p>currval 是取当前值，所以一个新的计数器必须先使用 nextval 后才可以使用 currval 否则会报错；</p><p>nextval 是取下一个值，但第一次使用时取的是初始值，之后正常取下一个，且如果一个语句(不同的子句)里面有多个 nextval，它们的取值可能是不同的；</p><br/><h2 id="4-删除序列"><a href="#4-删除序列" class="headerlink" title="4. 删除序列"></a>4. 删除序列</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> sequence seq_name;<br></code></pre></td></tr></table></figure><br/><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><p>​        序列(SEQUENCE)其实是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。</p>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oracle 基础（二）</title>
    <link href="/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/2.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/2.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>方案、模式、用户、表空间、表之间的关系。</p><span id="more"></span><h2 id="1-方案"><a href="#1-方案" class="headerlink" title="1. 方案"></a>1. 方案</h2><p>​        <strong>方案就是某用户拥有的所有的数据库对象的逻辑集合</strong>，可以看做是 SQL Server 或 MySQL 中的一个数据库。</p><p>​        在 SQL Server 或者 MySQL 中，一般情况下（暂不考虑多租户等特殊情况），一个项目对应DBMS 中的一个数据库，连接字符串中是用 “用户名+密码+数据库名” 来唯一标识数据库，一个用户可以管理多个数据库；而连接 Oracle 中的字符串主要是用 “户名+密码” 来标识数据库，即一个用户管理一个方案。</p><p>​        通俗来说，除了数据库地址，一个程序连接 MySQL 或 SQLServer 需要提供用户名、密码和它需要连接的数据库名，而连接 Oracle 只需要提供用户名和密码。</p><br/><h2 id="2-模式-Schema"><a href="#2-模式-Schema" class="headerlink" title="2. 模式 Schema"></a>2. 模式 Schema</h2><p>schema 的定义：<br>A <strong>schema</strong> is a collection of database objects (used by a user.).<br><strong>Schema objects</strong> are the logical structures that directly refer to the database’s data.<br>A <strong>user</strong> is a name defined in the database that can connect to and access objects.<br><strong>Schemas and users</strong> help database administrators manage database security.</p><p>​        从定义中我们可以看出 schema 为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字。这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个 schema，schema 里面包含了各种对象，如：tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。</p><p>​        一个用户一般对应一个 schema，该用户的 schema 名等于用户名，并作为该用户默认 schema。这也就是我们在企业管理器的方案下看到 schema 名都为数据库用户名的原因。Oracle 数据库中不能新创建一个 schema，要想创建一个 schema，只能通过创建一个用户的方法解决(Oracle中虽然有 create schema 语句，但是它并不是用来创建一个 schema 的)。在创建一个用户的同时为这个用户创建一个与用户名同名的 schema 并作为该用户的默认 shcema。<strong>即 schema 的个数同 user 的个数相同，而且 schema 名字同 user 名字一一对应并且相同</strong>，所有我们可以称schema 为 user 的别名，虽然这样说并不准确，但是更容易理解一些。</p><p>​        <strong>一个用户有一个默认的 schema，其 schema 名就等于用户名。</strong>当然一个用户还可以使用其他的 schema。<strong>如果我们访问一个表时，没有指明该表属于哪一个 schema 中的，系统就会自动给我们在表上加上默认的 sheman 名。</strong>比如我们在访问数据库时，访问 scott 用户下的 emp 表，通过 <code>select * from emp;</code> 其实，这 sql 语句的完整写法为 <code>select * from scott.emp</code>。<strong>在数据库中一个对象的完整名称为 <code>schema.object</code>，而不属 <code>user.object</code>。</strong>类似如果我们在创建对象时不指定该对象的 schema，在该对象的 schema 为用户的默认 schema。这就像一个用户有一个默认的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在默认表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。</p><br/><h2 id="2-模式对象"><a href="#2-模式对象" class="headerlink" title="2. 模式对象"></a>2. 模式对象</h2><p>​        Oracle 数据库对象又称模式对象。数据库对象包括表，视图，同义词，约束、索引，序列，游标，触发器，函数，变量，（控制块，异常），存储过程，包。对数据库的操作可以基本归结为对数据对象的操作，常常用 CREATE 命令进行创建，可以使用 ALTER 命令修改，用 DROP 执行删除操作等。数据库对象是逻辑结构的集合，最基本的数据库对象是表。</p><br/><h2 id="3-用户、表和表空间"><a href="#3-用户、表和表空间" class="headerlink" title="3. 用户、表和表空间"></a>3. 用户、表和表空间</h2><p>下面通过一个在 Oracle 中建立方案的例子来说明 Oracle 中表空间、用户、表之间的关系。</p><h3 id="3-1-建立方案"><a href="#3-1-建立方案" class="headerlink" title="3.1 建立方案"></a>3.1 建立方案</h3><p>​        一般在 Oracle 中建立方案的步骤为：创建表空间、创建用户并设置其表空间和权限、创建数据库对象。</p><p>步骤 1：使用 system 用户登录 Oracle 数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">SQLPLUS<br>输入用户名:<span class="hljs-keyword">system</span><br>输入口令：<br></code></pre></td></tr></table></figure><br/><p>步骤 2：创建表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span>space demo_tablespace<br>datafile <span class="hljs-string">&#x27;D:\app\MaxSeal\oradata\TableSpace\DemoTablespace.dbf&#x27;</span>   <br>size <span class="hljs-number">50</span>M   <br>autoextend <span class="hljs-keyword">on</span> next <span class="hljs-number">5</span>M maxsize <span class="hljs-number">100</span>M; <br></code></pre></td></tr></table></figure><br/><p>步骤 3：新建用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> MaxSeal identified <span class="hljs-number">123456</span>;<br></code></pre></td></tr></table></figure><br/><p>步骤 4：为用户赋予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">connect</span>, resource <span class="hljs-keyword">to</span> MaxSeal;<br></code></pre></td></tr></table></figure><br/><p>步骤 5：为用户分配表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> MaxSeal quota unlimited <span class="hljs-keyword">on</span> demo_tablespace;  <br></code></pre></td></tr></table></figure><br/><p>步骤 6：创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">connect</span> MaxSeal;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> s_dept(<br>  id NUMBER(<span class="hljs-number">7</span>) <span class="hljs-keyword">CONSTRAINT</span> s_dept_id_nn <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  name VARCHAR2(<span class="hljs-number">25</span>) <span class="hljs-keyword">CONSTRAINT</span> s_dept_name_nn <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  region_id NUMBER(<span class="hljs-number">7</span>),<br>  <span class="hljs-keyword">CONSTRAINT</span> s_dept_id_pk <span class="hljs-keyword">PRIMARY</span> KEY (id),<br>  <span class="hljs-keyword">CONSTRAINT</span> s_dept_name_region_id_uk <span class="hljs-keyword">UNIQUE</span> (name, region_id)<br>) tablespace demo_tablespace;<br></code></pre></td></tr></table></figure><p>当然也可以不指定表空间，建表时如果不指定表空间，表自动放到用户默认表空间下。</p><br/><h3 id="3-2-关系总结"><a href="#3-2-关系总结" class="headerlink" title="3.2 关系总结"></a>3.2 关系总结</h3><p>下面用一张图来分析一下上面的过程：</p><img src="C:\Users\MaxSeal\AppData\Roaming\Typora\typora-user-images\image-20210708191935243.png" alt="image-20210708191935243" style="zoom:50%;" /><p>​        一个方案对应一个项目，对应一个用户；每个用户可以管理多个表空间，每个表空间由一个或多个数据文件组成，一个用户可以分配多个表空间，但只能有一个默认表空间，每张表可以存在于一个或多个表空间中。</p><p>​        实际上多个用户可以共享一个表空间，只不过这些用户都只有权查看和管理属于自己的数据库对象。但是一般不会这么做，因为如果多个用户都共享一个表空间的话，那就体现不了表空间的意义啦！</p>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Oracle 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oracle 基础（一）</title>
    <link href="/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/1.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/07/08/Oracle%20%E6%95%B0%E6%8D%AE%E5%BA%93/1.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Oracle 数据库的组成部分和结构。</p><span id="more"></span><h2 id="1-Oracle-简介"><a href="#1-Oracle-简介" class="headerlink" title="1. Oracle 简介"></a>1. Oracle 简介</h2><p>1977年6月，Larry Ellison（拉里，埃里森）与Bob Miner 和 Ed Oates 在硅谷共同创办了一家名为软件开发 实验室（Software Development Laboratories，SDL）的计算机公司，这就是 ORACLE公司的前身。</p><p>如今，ORACLE（甲骨文）公司，已经是全球最大的企业级软件公司，它的软件和硬件产品众多，其中 oracle 数据库更是其核心的软件产品，同时它还收购了 SUN 公司，从而获取了对 Java 的“掌控权”。 </p><p>作为企业级数据库的主打产品，Oracle 数据库在众多关系型数据库之中表现突出，性能优越。但是 Oracle 数据库的价格昂贵，如果再考虑到搭载 Oracle 的服务器和存储设备的话，那么需要付出的成本也会更高。 Oracle 的版本很多，除了这些商用的收费版本之后，还有一些免费版本。</p><br/><h2 id="2-服务"><a href="#2-服务" class="headerlink" title="2. 服务"></a>2. 服务</h2><p>Oracle 数据库安装成功后，系统中会增加几个和 Oracle 相关的服务：</p><ul><li>OracleServiceXE 服务：如果不启动的话，Oracle 无法正常使用，也不能使用 sqlplus 登录到Oracle 数据库中 </li><li>OracleXETNSListener 服务：如果不启动的话，就无法使用 Oracle 自带管理系统登录到数据库中，之后也无法在代码中使用 JDBC 连接到数据库中。</li></ul><br/><h2 id="3-Oracle-数据的组成部分"><a href="#3-Oracle-数据的组成部分" class="headerlink" title="3. Oracle 数据的组成部分"></a>3. Oracle 数据的组成部分</h2><p>​        Oracle DataBase 是一款关系型数据库管理系统。同类的产品还有 mySql，sqlServer 等，很多时候，我们会把那个承载我们核心数据的系统笼统地成为数据库服务器，但从严格意义上来讲Oracle DataBase 是由两个部分组成:　</p><ul><li>实例：实例是数据库启动时初始化的一组进程和内存结构。</li><li>数据库：数据库则指的是用户存储数据的一些物理文件。</li></ul><p>​        从实例和数据库的概念上来看，我们能知道：<strong>实例暂时的</strong>，它不过是一组逻辑划分的内存结构和进程结构，它会<strong>随着数据库的关闭而消失</strong>；而<strong>数据库其实就是一堆物理文件</strong>（控制文件，数据文件，日志文件等等），它是<strong>永久存在的</strong>（除非磁盘损坏）。<strong>数据库和实例通常是一对一的</strong>，这种结构我们成为单实例体系结构；当然还有一些复杂的分布式的结构，一个数据库可以对多个实例，像 Oracle 的 RAC。</p><br/><h2 id="4-Oracle-数据库的物理结构"><a href="#4-Oracle-数据库的物理结构" class="headerlink" title="4. Oracle 数据库的物理结构"></a>4. Oracle 数据库的物理结构</h2><p> <strong>物理结构是由构成数据库的操作系统文件所决定</strong>，Oracle 数据库文件包括：</p><ul><li><p>数据文件（Data File）：</p><p>数据文件<strong>用来存储数据库中的全部数据</strong>，例如数据库表中的数据和索引数据通常为<code>*.dbf</code>格式，例如: <code>userCIMS.dbf </code>。</p><br/></li><li><p>日志文件（Redo Log File）：</p><p>日志文件<strong>用于记录数据库所做的全部变更（如增加、删除、修改），以便在系统发生故障时，用它对数据库进行恢复</strong>。名字通常为<code>Log*.dbf</code>格式，如：<code>Log1CIMS.dbf,Log2CIMS.dbf</code> </p><br/></li><li><p>控制文件（Control File）:</p><p>每个 Oracle 数据库都有相应的控制文件，它们是较小的二进制文件，<strong>用于记录数据库的物理结构</strong>，如：数据库名、数据库的数据文件和日志文件的名字和位置等信息。用于打开、存取数据库。名字通常为 <code>Ctrl*.ctl</code> 格式，如 <code>Ctrl1CIMS.ctl</code>。　　</p><br/></li><li><p>配置文件：</p><p>配置文件用于<strong>记录 Oracle 数据库运行时的一些重要参数</strong>，如：数据块的大小，内存结构的配置等。名字通常为 <code>init*.ora</code> 格式，如：<code>initCIMS.ora</code> 。　　</p></li></ul><br/><h2 id="5-Oracle-数据库的逻辑结构"><a href="#5-Oracle-数据库的逻辑结构" class="headerlink" title="5. Oracle 数据库的逻辑结构"></a>5. Oracle 数据库的逻辑结构</h2><p>​        <strong>Oracle 数据库的逻辑结构描述了数据库从逻辑上如何来存储数据的</strong>。逻辑结构包括表空间、段、区、数据块和模式对象。</p><p>　　数据库由表空间构成，而表空间又是由段构成，而段又是由区构成，而区又是由 Oracle 块构成，即块→区→段→表空间→数据库。</p><p><img src="C:\Users\MaxSeal\AppData\Roaming\Typora\typora-user-images\image-20210708162054120.png" alt="image-20210708162054120"></p><br/><h3 id="5-1-数据库（Database）"><a href="#5-1-数据库（Database）" class="headerlink" title="5.1 数据库（Database）"></a>5.1 数据库（Database）</h3><p>​        一个数据库是由多个表空间组成，也可以说多个不同类型的表空间组成了一个数据库。</p><br/><h3 id="5-2-表空间（TableSpace）"><a href="#5-2-表空间（TableSpace）" class="headerlink" title="5.2 表空间（TableSpace）"></a>5.2 表空间（TableSpace）</h3><p>​        数据库中的基本逻辑结构，也是最大的逻辑结构。数据库的所有对象和方案都被逻辑的保存在表空间中。从物理上说数据库的数据被存放在数据文件中，而从逻辑上说是被存放在表空间中的。 </p><br/><h4 id="5-2-1-表空间的特性"><a href="#5-2-1-表空间的特性" class="headerlink" title="5.2.1 表空间的特性"></a>5.2.1 表空间的特性</h4><ul><li>一个数据库可以有多个表空间。可以在数据库中创建、删除表空间； </li><li>一个表空间只属于一个数据库； </li><li>一个表空间必须要有一个数据文件； </li><li>一个表空间的大小等于其中所有数据文件的大小之和，数据库的大小等于其中所有表空间的大小之和； </li><li>表空间可以被联机和脱机，但 SYSTEM 表空间不能被脱机； </li><li>表空间可以在读写、只读状态之间切换；</li><li>每个表空间由一个或多个物理存在的操作系统的数据文件组成。这种数据文件可以具有固定的大小，或允许其自动变大。可以在表空间中添加、删除数据文件； </li><li>方案对象、表、索引的数据都被存储在表空间的数据文件中。一个数据文件存储不下，就存储在另一个数据文件中，只要该数据文件是本表空间中的就可以； </li><li>一个用户默认使用一个表空间，但他的不同方案对象的数据可以被存储在不同表空间中； </li><li>.一个用户使用的表空间的数量是有一定配额的，不能超出这个配额； </li><li>可以根据使用目的，创建不同类型的表空间，如永久表空间、临时表空间、撤销表空间、大表空间等。不同类型的表空间的格式、使用方式及目的是不同的。</li></ul><br/><h4 id="5-2-2-表空间的分类"><a href="#5-2-2-表空间的分类" class="headerlink" title="5.2.2 表空间的分类"></a>5.2.2 表空间的分类</h4><p>​        一个数据库通常有 SYSTEM 、SYSAUX、TEMP 三个默认表空间，一个或多个临时表空间，而且还有一个撤销表空间和几个应用程序专用的应用表空间。 </p><br/><h5 id="5-2-2-1-系统表空间"><a href="#5-2-2-1-系统表空间" class="headerlink" title="5.2.2.1 系统表空间"></a>5.2.2.1 系统表空间</h5><p>​        系统表空间包括 SYSTEM 表空间和 SYSAUX 表空间，其余的表空间就是非系统表空间。系统表空间在所有数据库中都是必须的。一般存放 Oracle 的数据字典及其数据。</p><br/><h5 id="5-2-2-2-临时表空间"><a href="#5-2-2-2-临时表空间" class="headerlink" title="5.2.2.2 临时表空间"></a>5.2.2.2 临时表空间</h5><p>​        撤了撤销(UNDO)表空间、相对于临时(TEMPORARY)空间而言，其他表空间就是永久(PERMANENT) 表空间。</p><p>​        当执行排序(ORDER BY)、分组汇总(GROUP BY)、索引(CREATE INDEX)等功能的SQL语句时，会产生大量的临时数据。服务器进程首先将临时数据存放到内存结构的PGA区的排序区中，当排序区不够用时，服务器进程就会在临时表空间中建立临时段，并将这些临时数据存放到临时段中。 </p><p>​        临时表空间对应的是临时文件，它与数据文件是有区别的。数据文件在创建时就被完全分配和初始化，而临时文件不一定保证被分配到指定的磁盘空间。这种延迟式的分配方法允许临时文件被快速创建，但如果没有预留出实际运行时所需的磁盘空间，就可能在运行时发生问题。 </p><p>​        临时表空间可以被所有用户共享使用，如TEMP表空间可以被所有用户共享使用。在 ORACLE 8I 中可以使用其他表空间作为临时表空间，而在 ORACLE 9I 中就开始引入默认临时表空间(DEFAULT TEMPORARY TABLESPACE)的设计了，使用户不能使用其他表空间作为临时表空间。 </p><p>​        如果在创建用户时没有为用户指定一个临时表空间，那么就会使用SYSTEM表空间来说创建临时段，存放临时数据。这样做的结果是： </p><ul><li>占用了SYSTEM表空间的存储空间，使可用的存储空间下降； </li><li>频繁的分配和释放临时段，会在SYSTEM表空间中产生大量的存储碎片，使磁盘的读取效率下降。</li></ul><p>​       如果在数据运行过程中，经常有大量的并发排序，那么为了避免在SYSTEM表空间中存储临时数据，数据库管理员应该在数据库中创建一个专门的用来存储临时数据的临时表空间。 </p><br/><h5 id="5-2-2-3-撤销表空间"><a href="#5-2-2-3-撤销表空间" class="headerlink" title="5.2.2.3 撤销表空间"></a>5.2.2.3 撤销表空间</h5><p>​        从 Oracle 9I 开始，引入了一个全新的概念，即自动撤销管理 (AUTOMATIC UNDO MANAGEMENT)。用撤销 (UNDO) 表空间取代已经使用了20年的回退段。</p><p>​        实际上是将回退段 (撤销段) 放入了撤销表空间，而由例程自动处理撤销表空间中的回退段。使用自动撤销管理方式后，不仅可以减轻 DBA 的工作负担，而且还可以获得较好的回退性能。通过查询数据字典视图 DBA_ROLLBACK_SEGS，可以得到撤销表空间中回退段的信息。 </p><br/><p>撤销表空间存储撤销段，撤销段主要用于入下目的: </p><ol><li><p>用一条ROLLBACK语句明确的回退一个事务； </p></li><li><p>隐含的回退一个事务； </p></li><li><p>重构数据的一个读一致图像； </p></li><li><p>从逻辑错误中恢复。</p></li></ol><br/><p>​        在 Oracle 中可以创建多个撤销表空间，但同一时刻值允许激活一个撤销表空间。在初始化参数文件中用 UNDO_TABLESPACE 指出要激活的撤销表空间。撤销表空间的组织与管理由Oracle 内部自动完成。当回退段不足时，一个事务可以使用多个回退段，不会中止事务的运行。数据库管理员只需了解撤销表空间是否有足够的空间，而不必为每个事务设置回退段。</p><br/><h5 id="5-2-2-4-大表空间和小表空间"><a href="#5-2-2-4-大表空间和小表空间" class="headerlink" title="5.2.2.4 大表空间和小表空间"></a>5.2.2.4 大表空间和小表空间</h5><p>​        大文件(BIGFILE)表空间是 ORACLE 10G 新引进的表空间。大文件表空间只能放置一个数据文件(或临时文件)。但其数据文件可以包括 4G 个数据块。</p><p>​        大文件表空间都是为超大型数据库设计的。如果一个超大型数据库具有上千个数据文件的话，更新数据文件头部信息的操作就会花费很长时间。如果使用了大文件表空间，就可以使用大数据文件来减少数据文件的数量，使更新数据文件头部信息的操作更快一些。 </p><p>​        小文件(SMALLFILE)表空间是以前 ORACLE 表空间的新命名。在小文件表空间中可以放置多个数据文件。一个数据库可以放置多达 64K 个数据文件。 SYSTEM 和 SYSAUX 表空间总是被创建为小文件表空间。 </p><br/><h3 id="5-3-段（Segment）"><a href="#5-3-段（Segment）" class="headerlink" title="5.3 段（Segment）"></a>5.3 段（Segment）</h3><p>​        对象在数据库中占用的空间。当在数据库中创建表或索引时，系统就会创建对应的段。段是由多个可以不连续的区组成，所以段是可以跨数据文件的。当段空间不足时，系统将以区为单位为段分配空间。段按照类型可以分为数据段、索引段、Undo段、临时段等。</p><br/><h4 id="5-3-1-数据段"><a href="#5-3-1-数据段" class="headerlink" title="5.3.1 数据段"></a>5.3.1 数据段</h4><p>​        每个非集群的、不按索引组织的表都有一个数据段，但外部表、全局临时表和分区表除外。这些表中的每个表都有一个或多个段。表中的所有数据都存储在相应数据段的区中。对于分区表，每个分区都有一个数据段。每个集群也都有一个数据段。集群中每个表的数据都存储在集群的数据段中。</p><br/><h4 id="5-3-2-索引段"><a href="#5-3-2-索引段" class="headerlink" title="5.3.2 索引段"></a>5.3.2 索引段</h4><p>​        每个索引都有一个索引段，存储其所有数据。对于分区索引，每个分区都有一个索引段。</p><br/><h4 id="5-3-3-Undo-段"><a href="#5-3-3-Undo-段" class="headerlink" title="5.3.3 Undo 段"></a>5.3.3 Undo 段</h4><p>​        Oracle 为每个数据库实例创建一个 Undo 表空间，该表空间包含大量用于临时存储还原信息的 Undo 段。Undo 段中的信息用于生成读一致性数据库信息，并且在数据库恢复过程中，用于为用户回滚未提交的事务处理。</p><br/><h4 id="5-3-4-临时段"><a href="#5-3-4-临时段" class="headerlink" title="5.3.4 临时段"></a>5.3.4 临时段</h4><p>​       临时段是在需要临时工作区来执行 SQL 语句时，由 Oracle 数据库创建的。在语句执行完成后，临时段的区将返回到实例以备将来使用。Oracle 会为每个用户指定一个默认临时表空间，或指定一个在数据库范围内使用的默认临时表空间。 </p><br/><h3 id="5-4-区（Extent）"><a href="#5-4-区（Extent）" class="headerlink" title="5.4 区（Extent）"></a>5.4 区（Extent）</h3><p>​        区为数据一次性预留的一个较大的存储空间。区是一个空间分配单位，当数据库对象空间不足时，通常会以区为单位进行分配空间。区是由多个连续的数据块组成，由此可知区是不能跨数据文件的。</p><br/><h3 id="5-5-块（Block）"><a href="#5-5-块（Block）" class="headerlink" title="5.5 块（Block）"></a>5.5 块（Block）</h3><p>​        块是 Oracle 最基本的存储单位。在建立数据库的时候指定 DB_BLOCK_SIZE 值，该参数表示数据库标准数据块的大小，默认大小为8K，它是数据库一次标准 I/O 的大小。</p><p>​        一个标准的 Oracle 数据块是由连续的操作系统数据块组成的。1 个 8K 的数据块理论上最多可存储 700 多行。所以，块越大，在相同情况下存储的行就越多，而 Oracle 是以块为单位进行访问的，那么产生的逻辑读就越小。需要注意的是，块越大，不同的会话访问不同的数据落在同一个块的几率就增加了，这就容易产生热点块竞争，所以，在OLAP中，可以适当将块调大。</p>]]></content>
    
    
    <categories>
      
      <category>SQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Oracle 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/07/CoreJava/35.%20String%20%E7%B1%BB3/"/>
    <url>/2021/07/07/CoreJava/35.%20String%20%E7%B1%BB3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-String-与-StringBuilder"><a href="#1-String-与-StringBuilder" class="headerlink" title="1. String 与 StringBuilder"></a>1. String 与 StringBuilder</h2><p>String 类型 和 StringBuilder 类型的主要性能区别在于 String 是不可变的对象。 </p><p>事实上，在对 String 类型进行 “改变” 时，实质上等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。由于频繁的生成对象会对系统性能产生影响，特别是当内存中没有引用指向的对象多了以后，JVM 的垃圾回收器就会开始工作，继而会影响到程序的执行效率。</p><p>所以，对于经常改变内容的字符串，最好不要声明为 String 类型。但如果我们使用的是 StringBuilder 类，那么情形就不一样了。因为，我们的每次修改都是针对 StringBuilder 对象本身的，而不会像对String操作那样去生成新的对象并重新给变量引用赋值。所以，在一般情况下，推荐使用 StringBuilder ，特别是字符串对象经常改变的情况下。</p><p>在某些特别情况下，String 对象的字符串拼接可以直接被 JVM 在编译期确定下来，这时，StringBuilder 在速度上就不占任何优势了。</p><p>因此，在绝大部分情况下， 在效率方面：StringBuilder &gt; String </p><br/><h2 id="2-StringBuffer-与-StringBuilder"><a href="#2-StringBuffer-与-StringBuilder" class="headerlink" title="2. StringBuffer 与 StringBuilder"></a>2. StringBuffer 与 StringBuilder</h2><p>StringBuffer 始于 JDK 1.0，而 StringBuilder 始于 JDK 5.0；此外，从 JDK 1.5 开始，对含有字符串变量 (非字符串字面值) 的连接操作(+)，JVM 内部是采用 StringBuilder 来实现的，而在这之前，这个操作是采用 StringBuffer 实现的。</p><p>JDK的实现中 StringBuffer 与 StringBuilder 都继承自 AbstractStringBuilder。AbstractStringBuilder 的实现原理为：AbstractStringBuilder 中采用一个 char 数组来保存需要append 的字符串，char 数组有一个初始大小，当 append 的字符串长度超过当前 char 数组容量时，则对 char 数组进行动态扩展，即重新申请一段更大的内存空间，然后将当前 char 数组拷贝到新的位置，因为重新分配内存并拷贝的开销比较大，所以每次重新申请内存空间都是采用申请大于当前需要的内存空间的方式，这里是 2 倍。</p><p>StringBuffer 和 StringBuilder 都是可变的字符序列，但是二者最大的一个不同点是：StringBuffer 是线程安全的，而 StringBuilder 则不是。StringBuilder 提供的 API 与 StringBuffer 的 API 是完全兼容的，即 StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，但是后者一般要比前者快。因此，可以这么说，StringBuilder 的提出就是为了在单线程环境下替换 StringBuffer 。</p><p>在单线程环境下，优先使用 StringBuilder。</p><br/><h2 id="3-字符串连接符的本质"><a href="#3-字符串连接符的本质" class="headerlink" title="3. 字符串连接符的本质"></a>3. 字符串连接符的本质</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String s = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;<br>        String s1 = <span class="hljs-string">&quot;a&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;b&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;c&quot;</span>;<br>        String s4 = s1 + s2 + s3;<br><br>        System.out.println(s);<br>        System.out.println(s4);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由上面的叙述，我们可以知道，变量s的创建等价于 String s = “abc”; 而变量s4的创建相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder temp = <span class="hljs-keyword">new</span> StringBuilder(s1);<br>temp.append(s2).append(s3);<br>String s4 = temp.toString();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/07/CoreJava/34.%20String%20%E7%B1%BB2/"/>
    <url>/2021/07/07/CoreJava/34.%20String%20%E7%B1%BB2/</url>
    
    <content type="html"><![CDATA[<h2 id="1-字符串常量池"><a href="#1-字符串常量池" class="headerlink" title="1. 字符串常量池"></a>1. 字符串常量池</h2><p>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价。JVM 为了提高性能和减少内存开销，在实例化字符串字面值的时候进行了一些优化。</p><p>为了减少在 JVM 中创建的字符串的数量，字符串类维护了一个字符串常量池，<strong>每当以字面值形式创建一个字符串时，JVM 会首先检查字符串常量池</strong>：如果字符串已经存在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放到池中。JVM 能够进行这样的优化是因为字符串是不可的，可以不用担心数据冲突进行共享。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>       String str1 = <span class="hljs-string">&quot;Hello&quot;</span>;  <br>       String str2 = <span class="hljs-string">&quot;Hello&quot;</span>; <br>       System.out.print(str1 == str2);   <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个初始为空的字符串池，它由类 String 私有地维护。<strong>当以字面值形式创建一个字符串时，总是先检查字符串池是否含存在该对象，若存在，则直接返回。</strong>此外，<strong>通过 new 操作符创建的字符串对象不指向字符串池中的任何对象。</strong></p><br/><h2 id="2-手动入池"><a href="#2-手动入池" class="headerlink" title="2 手动入池"></a>2 手动入池</h2><p>一个初始为空的字符串池，它由类 String 私有地维护。 当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。</p><br/><p>**对于任意两个字符串 s 和 t ，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    String str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br>    String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>    String str3 = s2.intern();<br><br>    System.out.println( str1 == str2 );   <span class="hljs-comment">//false</span><br>    System.out.println( str1 == str3 );   <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于 String str1 = “abc”，str1 引用的是 <strong>常量池（方法区）</strong> 的对象；而 String str2 = new String(“abc”)，str2引用的是 <strong>堆</strong> 中的对象，所以内存地址不一样。但是由于内容一样，所以 str1 和 str3 指向同一对象。</p><br/><h2 id="3-实例题型"><a href="#3-实例题型" class="headerlink" title="3. 实例题型"></a>3. 实例题型</h2><h3 id="3-1-字符串常量池"><a href="#3-1-字符串常量池" class="headerlink" title="3.1 字符串常量池"></a>3.1 字符串常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-string">&quot;abc&quot;</span>;     <br><span class="hljs-comment">//在字符串池创建了一个对象  </span><br><br>String s2 = <span class="hljs-string">&quot;abc&quot;</span>;     <br><span class="hljs-comment">//字符串 pool 已经存在对象“abc”(共享)，所以创建0个对象，累计创建一个对象  </span><br><br>System.out.println(<span class="hljs-string">&quot;s1 == s2 : &quot;</span>+(s1==s2));    <br><span class="hljs-comment">//true 指向同一个对象</span><br><br>System.out.println(<span class="hljs-string">&quot;s1.equals(s2) : &quot;</span> + (s1.equals(s2)));    <br><span class="hljs-comment">//true 值相等  </span><br></code></pre></td></tr></table></figure><br/><h3 id="3-2-new-String-“…”"><a href="#3-2-new-String-“…”" class="headerlink" title="3.2 new String(“…”)"></a>3.2 new String(“…”)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);  <br><span class="hljs-comment">// 创建了两个对象，一个存放在字符串池中，一个存在与堆区中；  </span><br><span class="hljs-comment">// 还有一个对象引用 s3 存放在栈中  </span><br><br>String s4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);  <br><span class="hljs-comment">// 字符串池中已经存在“abc”对象，所以只在堆中创建了一个对象  </span><br><br>System.out.println(<span class="hljs-string">&quot;s3 == s4 : &quot;</span>+(s3==s4));  <br><span class="hljs-comment">//false  s3和s4栈区的地址不同，指向堆区的不同地址；  </span><br><br>System.out.println(<span class="hljs-string">&quot;s3.equals(s4) : &quot;</span>+(s3.equals(s4)));  <br><span class="hljs-comment">//true  s3和s4的值相同  </span><br><br></code></pre></td></tr></table></figure><br/><h3 id="3-3-通过-“-”-连接字符串"><a href="#3-3-通过-“-”-连接字符串" class="headerlink" title="3.3 通过 “+” 连接字符串"></a>3.3 通过 “+” 连接字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String str2 = <span class="hljs-string">&quot;ab&quot;</span>;  <span class="hljs-comment">//1个对象  </span><br>String str3 = <span class="hljs-string">&quot;cd&quot;</span>;  <span class="hljs-comment">//1个对象                                         </span><br>String str4 = str2+str3;                                        <br>String str5 = <span class="hljs-string">&quot;abcd&quot;</span>;    <br>System.out.println(<span class="hljs-string">&quot;str4 = str5 : &quot;</span> + (str4==str5)); <span class="hljs-comment">// false  </span><br></code></pre></td></tr></table></figure><p>局部变量 str2，str3 指向字符串常量池中的两个对象。在运行时，<strong>第三行代码(str2+str3)实质上会被分解成五个步骤，分别是：</strong></p><ol><li><p>调用 String 类的静态方法 <code>String.valueOf()</code> 将 str2 转换为字符串表示；</p></li><li><p>JVM 在堆中创建一个 StringBuilder 对象，同时用 str2 指向转换后的字符串对象进行初始化；　</p></li><li><p>调用 StringBuilder 对象的 append 方法完成与 str3 所指向的字符串对象的合并；</p></li><li><p>调用 StringBuilder 的 toString() 方法在堆中创建一个 String 对象；</p></li><li><p>将刚刚生成的 String 对象的堆地址存赋给局部变量引用 str4。</p></li></ol><p>而引用 str5 指向的是字符串常量池中字面值 ”abcd” 所对应的字符串对象。由上面的内容我们可以知道，引用 str4 和 str5 指向的对象的地址必定不一样。这时，内存中实际上会存在五个字符串对象： 三个在字符串常量池中的 String 对象、一个在堆中的 String 对象和一个在堆中的StringBuilder 对象。</p><br/><h3 id="3-4-字符串的编译期优化"><a href="#3-4-字符串的编译期优化" class="headerlink" title="3.4 字符串的编译期优化"></a>3.4 字符串的编译期优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;ab&quot;</span> + <span class="hljs-string">&quot;cd&quot;</span>;  <span class="hljs-comment">//1个对象  </span><br>String str11 = <span class="hljs-string">&quot;abcd&quot;</span>;   <br>System.out.println(<span class="hljs-string">&quot;str1 = str11 : &quot;</span>+ (str1 == str11));   <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">final</span> String str8 = <span class="hljs-string">&quot;cd&quot;</span>;  <br>String str9 = <span class="hljs-string">&quot;ab&quot;</span> + str8;  <br>String str89 = <span class="hljs-string">&quot;abcd&quot;</span>;  <br>System.out.println(<span class="hljs-string">&quot;str9 = str89 : &quot;</span>+ (str9 == str89));     <span class="hljs-comment">// true</span><br><span class="hljs-comment">//↑str8为常量变量，编译期会被优化  </span><br><br>String str6 = <span class="hljs-string">&quot;b&quot;</span>;  <br>String str7 = <span class="hljs-string">&quot;a&quot;</span> + str6;  <br>String str67 = <span class="hljs-string">&quot;ab&quot;</span>;  <br>System.out.println(<span class="hljs-string">&quot;str7 = str67 : &quot;</span>+ (str7 == str67));     <span class="hljs-comment">// false</span><br><span class="hljs-comment">//↑str6为变量，在运行期才会被解析。</span><br></code></pre></td></tr></table></figure><p>Java 编译器对于类似 “常量+字面值” 的组合，其值在编译的时候就能够被确定了。在这里，str1 和 str9 的值在编译时就可以被确定，因此它们分别等价于： <code>String str1 = “abcd”;</code> 和 <code>String str9 = “abcd”;</code></p><p>Java 编译器对于含有 “String引用” 的组合，则在运行期会产生新的对象 (通过调用 StringBuilder 类的 toString() 方法)，因此这个对象存储在堆中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/07/CoreJava/33.%20String%20%E7%B1%BB1/"/>
    <url>/2021/07/07/CoreJava/33.%20String%20%E7%B1%BB1/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java-存储模型与常量池"><a href="#1-Java-存储模型与常量池" class="headerlink" title="1. Java 存储模型与常量池"></a>1. Java 存储模型与常量池</h2><h3 id="1-1-java-存储模型"><a href="#1-1-java-存储模型" class="headerlink" title="1.1 java 存储模型"></a>1.1 java 存储模型</h3><p><img src="https://i.loli.net/2021/07/07/pc6SEhlIqPMsRGy.png" alt="Java 内存模型.jpg"></p><h4 id="1-1-1程序计数器"><a href="#1-1-1程序计数器" class="headerlink" title="1.1.1程序计数器"></a>1.1.1程序计数器</h4><p>　多线程时，当线程数超过 CPU 数量或 CPU 内核数量，线程之间就要根据时间片轮询抢夺 CPU 时间资源。因此，每个线程要有一个独立的程序计数器，记录下一条要运行的指令，其为线程私有的内存区域。如果执行的是 Java 方法，计数器记录正在执行的 Java 字节码地址，如果执行的是native方法，则计数器为空。</p><br/><h4 id="1-1-2-虚拟机栈"><a href="#1-1-2-虚拟机栈" class="headerlink" title="1.1.2 虚拟机栈"></a>1.1.2 虚拟机栈</h4><ul><li><strong>线程私有的，与线程在同一时间创建，是管理 Java 方法执行的内存模型</strong>。</li><li><strong>栈中主要存放一些基本类型的变量数据和对象引用</strong>。</li><li>每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。</li><li>栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。</li><li>栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverflowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出OutofMemoryError。使用 jclasslib 工具可以查看 class 类文件的结构。</li></ul><br/><h4 id="1-1-3-本地方法区"><a href="#1-1-3-本地方法区" class="headerlink" title="1.1.3 本地方法区"></a>1.1.3 本地方法区</h4><p>和虚拟机栈功能相似，但管理的不是 Java 方法，而是 native 方法，本地方法是用 C 实现的。</p><br/><h4 id="1-1-4-Java-堆"><a href="#1-1-4-Java-堆" class="headerlink" title="1.1.4 Java 堆"></a>1.1.4 Java 堆</h4><ul><li><p><strong>堆线程共享的，用于存放所有对象实例和数组，是垃圾回收的主要区域</strong>。</p></li><li><p>堆是一个运行时数据区，类的对象从中分配空间，这些对象通过new、newarray、 anewarray 和 multianewarray 等指令建立，它们不需要程序代码来显式的释放。</p></li><li><p>堆可以分为新生代和老年代 (tenured)。</p><ul><li><p>新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，老年对象就会被移入老年代。</p></li><li><p>新生代又可进一步细分为 eden(伊甸园)、survivorSpace0(s0,from space)、survivorSpace1(s1,tospace)。刚创建的对象都放入 eden，s0 和 s1 都至少经过一次 GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代 (tenured)。</p></li></ul></li></ul><br/><h4 id="1-1-5-方法区"><a href="#1-1-5-方法区" class="headerlink" title="1.1.5 方法区"></a>1.1.5 方法区</h4><p><strong>方法区是线程共享的，用于存放被虚拟机加载的类的元数据信息</strong>：如常量、静态变量、即时编译器编译后的代码，也成为永久代。</p><p>如果 hotspot 虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的 ClassLoader 被回收。</p><br/><h3 id="1-2-常量池"><a href="#1-2-常量池" class="headerlink" title="1.2 常量池"></a>1.2 常量池</h3><p>常量池属于类信息的一部分，而类信息反映到 JVM 内存模型中对应于方法区，也就是说，<strong>常量池位于方法区</strong>。</p><p>常量池主要存放两大常量：字面量(Literal) 和 符号引用(Symbolic References)：</p><ul><li><p>字面量主要包括：</p><ul><li>字符串字面量</li><li>整型字面量</li><li>声明为 final 的常量值</li></ul></li><li><p>符号引用则属于编译原理方面的概念，包括了下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul><br/><h2 id="2-常量与变量"><a href="#2-常量与变量" class="headerlink" title="2. 常量与变量"></a>2. 常量与变量</h2><p>我们一般把<strong>内存地址不变，值可以改变的东西称为变量</strong>。换句话说，在内存地址不变的前提下内存的内容是可变的。</p><p>我们一般把若<strong>内存地址不变，则值也不可以改变的东西称为常量。</strong>典型的 String 就是不可变的，所以称之为常量。此外，我们可以通过 final 关键字来定义常量，但严格来说，只有基本类型被其修饰后才是常量（对基本类型来说是其值不可变，而对于引用类型变量来说其引用不可指向其他对象）。</p><br/><h2 id="3-String-的不可变性"><a href="#3-String-的不可变性" class="headerlink" title="3. String 的不可变性"></a>3. String 的不可变性</h2><h3 id="3-1-不可变对象"><a href="#3-1-不可变对象" class="headerlink" title="3.1 不可变对象"></a>3.1 不可变对象</h3><p>在Java中，String 类是不可变类 (基本类型的包装类都是不可改变的) 的典型代表，也是 Immutable 设计模式的典型应用。String 变量一旦初始化后就不能更改，禁止改变对象的状态，从而增加共享对象的坚固性、减少对象访问的错误，同时还避免了在多线程共享时进行同步的需要。</p><p>那么，到底什么是不可变的对象呢？ 可以这样认为：如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。不能改变状态指的是不能改变对象内的成员变量，包括：</p><ul><li><p>基本数据类型的值不能改变;</p></li><li><p>引用类型的变量不能指向其他的对象;</p></li><li><p>引用类型指向的对象的状态也不能改变;</p></li></ul><p>除此之外，还应具有以下特点：</p><ul><li><strong>除了构造函数之外，不应该有其它任何函数（至少是任何public函数）修改任何成员变量;</strong></li><li><strong>任何使成员变量获得新值的函数</strong>都应该<strong>将新的值保存在新的对象中，而保持原来的对象不被修改。</strong></li></ul><br/><h3 id="3-2-为什么-String-是不可变的"><a href="#3-2-为什么-String-是不可变的" class="headerlink" title="3.2 为什么 String 是不可变的"></a>3.2 为什么 String 是不可变的</h3><p>JDK 1.8 中的 String 的成员变量有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <br></code></pre></td></tr></table></figure><p>由以上的代码可以看出， 在 Java 中，<strong>String 类其实就是对字符数组的封装</strong>。value 是 private 的，且没有提供 setValue 方法来修改 value 的值。而且 value 是被 final 修饰的，所以 value 一旦被初始化就不能再被改变了。所以可以认为 String 对象是不可变的。</p><p>那么在String中，明明存在一些方法，调用他们可以得到改变后的值。这些方法包括 substring， replace， replaceAll， toLowerCase等。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;ABCabc&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a);    <span class="hljs-comment">// a = ABCabc</span><br><br>a = a.replace(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br>System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a);    <span class="hljs-comment">//a = a</span><br></code></pre></td></tr></table></figure><p>那么 a 的值看似改变了，但其实并不是。a 只是一个引用， 不是真正的字符串对象，在调用<code>a.replace(‘A’, ‘a’)</code> 时， 方法内部创建了一个新的 String 对象，并把这个新的对象重新赋给了引用 a。</p><br/><h3 id="3-3-String-对象真的不可变吗"><a href="#3-3-String-对象真的不可变吗" class="headerlink" title="3.3 String 对象真的不可变吗"></a>3.3 String 对象真的不可变吗</h3><p>value 是 final 修饰的，也就是说 value 不能再指向其他数组对象，那么我能改变 value 指向的数组吗？ 至少在我们自己写的普通代码中不能够做到，因为我们根本不能够访问到这个 value 引用，更不能通过这个引用去修改数组。那么，用什么方式可以访问私有成员呢？ 没错，用反射可以反射出 String 对象中的 value 属性， 进而改变通过获得的 value 引用改变数组的结构。下面是实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testReflection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-comment">//创建字符串&quot;Hello World&quot;， 并赋给引用s</span><br>    String s = <span class="hljs-string">&quot;Hello World&quot;</span>; <br><br>    System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s); <span class="hljs-comment">//Hello World</span><br><br>    <span class="hljs-comment">//获取String类中的value字段</span><br>    Field valueFieldOfString = String.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br><br>    <span class="hljs-comment">//改变value属性的访问权限</span><br>    valueFieldOfString.setAccessible(<span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-comment">//获取s对象上的value属性的值</span><br>    <span class="hljs-keyword">char</span>[] value = (<span class="hljs-keyword">char</span>[]) valueFieldOfString.get(s);<br><br>    <span class="hljs-comment">//改变value所引用的数组中的第5个字符</span><br>    value[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;_&#x27;</span>;<br><br>    System.out.println(<span class="hljs-string">&quot;s = &quot;</span> + s);  <span class="hljs-comment">//Hello_World</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个过程中，s 始终引用的同一个 String 对象，但是再反射前后，这个 String 对象发生了变化。也就是说，<strong>通过反射是可以修改所谓的 “不可变” 对象的</strong>。但是一般我们不这么做。</p><p>这个反射的实例还可以说明一个问题：如果一个对象，他组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个 Car 对象，它组合了一个 Wheel 对象，虽然这个Wheel 对象声明成了private final 的，但是这个 Wheel 对象内部的状态可以改变， 那么就不能很好的保证 Car 对象不可变。</p><br/><h2 id="4-String-对象创建方式"><a href="#4-String-对象创建方式" class="headerlink" title="4. String 对象创建方式"></a>4. String 对象创建方式</h2><h3 id="4-1-直接赋值"><a href="#4-1-直接赋值" class="headerlink" title="4.1 直接赋值"></a>4.1 直接赋值</h3><p>字面值形式： <strong>JVM会自动根据字符串常量池中字符串的实际情况来决定是否创建新对象。</strong>(要么不创建，要么创建一个对象，关键要看常量池中有没有)</p><p>以下两种创建 String 对象的方式是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法1：</span><br>String s = <span class="hljs-string">&quot;abc&quot;</span>;<br><br><span class="hljs-comment">//方法2：</span><br><span class="hljs-keyword">char</span> data[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String str = <span class="hljs-keyword">new</span> String(data);<br></code></pre></td></tr></table></figure><p>该种方式先在栈中创建一个对 String 类的对象引用变量 s，然后去查找  “abc” 是否被保存在字符串常量池中。若 ”abc” 已经被保存在字符串常量池中，则在字符串常量池中找到值为 ”abc” 的对象，然后将 s 指向这个对象; 否则，在堆中创建 char 数组 data，然后在堆中创建一个 String 对象 object，它由 data 数组支持，紧接着这个 String 对象 object 被存放进字符串常量池，最后将 s 指向这个对象。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;  <br>    String s0 = <span class="hljs-string">&quot;kvill&quot;</span>;        <span class="hljs-comment">// 1</span><br>    String s1 = <span class="hljs-string">&quot;kvill&quot;</span>;        <span class="hljs-comment">// 2</span><br>    String s2 = <span class="hljs-string">&quot;kv&quot;</span> + <span class="hljs-string">&quot;ill&quot;</span>;     <span class="hljs-comment">// 3</span><br><br>    System.out.println(s0 == s1);       <span class="hljs-comment">// true  </span><br>    System.out.println(s0 == s2);       <span class="hljs-comment">// true  </span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-2-使用-new-关键字"><a href="#4-2-使用-new-关键字" class="headerlink" title="4.2 使用 new 关键字"></a>4.2 使用 new 关键字</h3><p>通过 new 创建字符串对象：一概在堆中创建新对象，无论字符串字面值是否相等。 (要么创建一个，要么创建两个对象，关键要看常量池中有没有)</p><p>以下两种创建 String 对象的方式是等价的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法1</span><br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);  <br><br><span class="hljs-comment">// 方法2</span><br>String original = <span class="hljs-string">&quot;abc&quot;</span>; <br>String s = <span class="hljs-keyword">new</span> String(original);<br></code></pre></td></tr></table></figure><p>所以，通过 new 操作产生一个字符串（“abc”）时，会先去常量池中查找是否有 “abc” 对象。如果没有，则创建一个此字符串对象并放入常量池中。然后，在堆中再创建 “abc” 对象，并返回该对象的地址。所以，对于 <code>String str=new String(“abc”)</code>如果常量池中原来没有 ”abc”，则会产生两个对象（一个在常量池中，一个在堆中）；否则，产生一个对象。</p><br/><p>用 new String() 创建的字符串对象位于堆中，而不是常量池中。它们有自己独立的地址空间。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;  <br>    String s0 = <span class="hljs-string">&quot;kvill&quot;</span>;  <br>    String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;kvill&quot;</span>);  <br>    String s2 = <span class="hljs-string">&quot;kv&quot;</span> + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ill&quot;</span>);  <br><br>    String s = <span class="hljs-string">&quot;ill&quot;</span>;<br>    String s3 = <span class="hljs-string">&quot;kv&quot;</span> + s;    <br><br>    System.out.println(s0 == s1);       <span class="hljs-comment">// false  </span><br>    System.out.println(s0 == s2);       <span class="hljs-comment">// false  </span><br>    System.out.println(s1 == s2);       <span class="hljs-comment">// false  </span><br>    System.out.println(s0 == s3);       <span class="hljs-comment">// false  </span><br>    System.out.println(s1 == s3);       <span class="hljs-comment">// false  </span><br>    System.out.println(s2 == s3);       <span class="hljs-comment">// false  </span><br>&#125;  <br></code></pre></td></tr></table></figure><ul><li>s0 还是常量池中 ”kvill” 的引用，s1 指向运行时创建的新对象”kvill”，二者指向不同的对象。</li><li>对于 s2，因为后半部分是 new String(“ill”)，所以无法在编译期确定，在运行期会 new 一个 StringBuilder 对象， 并由 StringBuilder 的 append 方法连接并调用其 toString 方法返回一个新的 “kvill” 对象。</li><li>此外，s3 的情形与 s2 一样，均含有编译期无法确定的元素。因此，以上四个 “kvill” 对象互不相同。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/06/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/5.%20Optional/"/>
    <url>/2021/07/06/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/5.%20Optional/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><code>java.util.Optional</code> 类，是用来防止 <code>NullPointerException</code> 异常的辅助类型， Optional 对象中封装的值，可以是 null ，也可以不是 null。</p><p>在 Java8 之前，一个函数可能因为代码逻辑问题，最终返回一个 null，这时候程序中很可能出现空指针异常。而在 Java8 中，不推荐返回 null ，而是返回 Optional。</p><br/><h2 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h2><h3 id="2-1-of-方法"><a href="#2-1-of-方法" class="headerlink" title="2.1 of 方法"></a>2.1 of 方法</h3><p>of 方法为非null的值创建一个 Optional对象。如果传入参数为 null，则抛出 <code>NullPointerException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T value)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Optional&lt;&gt;(value);<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-2-ofNullable-方法"><a href="#2-2-ofNullable-方法" class="headerlink" title="2.2 ofNullable 方法"></a>2.2 ofNullable 方法</h3><p>ofNullable 与 of 方法相似，唯一的区别是可以接受参数为 null 的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">ofNullable</span><span class="hljs-params">(T value)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> value == <span class="hljs-keyword">null</span> ? empty() : of(value);<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-3-isPresent-方法"><a href="#2-3-isPresent-方法" class="headerlink" title="2.3 isPresent 方法"></a>2.3 isPresent 方法</h3><p> 如果值存在返回 true，否则返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPresent</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-4-isEmpty-方法"><a href="#2-4-isEmpty-方法" class="headerlink" title="2.4 isEmpty 方法"></a>2.4 isEmpty 方法</h3><p>如果值为空返回 true，否则返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> value == <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-5-ifPresent-方法"><a href="#2-5-ifPresent-方法" class="headerlink" title="2.5 ifPresent 方法"></a>2.5 ifPresent 方法</h3><p>如果值不为 null，则调用 Consumer 接口的 accept 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ifPresent</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;<br>      action.accept(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-6-get-方法"><a href="#2-6-get-方法" class="headerlink" title="2.6 get 方法"></a>2.6 get 方法</h3><p>如果值不为空就返回其值，否则抛出 <code>NoSuchElementException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">&quot;No value present&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-7-orElse-方法"><a href="#2-7-orElse-方法" class="headerlink" title="2.7 orElse 方法"></a>2.7 orElse 方法</h3><p>如果值不为空就返回其值，否则为其赋一个指定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">orElse</span><span class="hljs-params">(T other)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> ? value : other;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-8-orElseGet-方法"><a href="#2-8-orElseGet-方法" class="headerlink" title="2.8. orElseGet 方法"></a>2.8. orElseGet 方法</h3><p>功能和 orElse 方法相同。只是赋值的方法不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">orElseGet</span><span class="hljs-params">(Supplier&lt;? extends T&gt; supplier)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> ? value : supplier.get();<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-9-map-方法"><a href="#2-9-map-方法" class="headerlink" title="2.9. map 方法"></a>2.9. map 方法</h3><p>如果有值，则调用 mapper 的函数处理并得到返回值。返回值依然是 Optional 包裹起来的，其泛型和返回值的类型一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">Optional&lt;U&gt; <span class="hljs-title">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;<br>    Objects.requireNonNull(mapper);<br>    <span class="hljs-keyword">if</span> (!isPresent()) &#123;<br>      <span class="hljs-keyword">return</span> empty();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> Optional.ofNullable(mapper.apply(value));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-10-flatMap-方法"><a href="#2-10-flatMap-方法" class="headerlink" title="2.10 flatMap 方法"></a>2.10 flatMap 方法</h3><p>如果有值，则调用 mapper 的函数返回 Optional 类型返回值，否则返回空 Optional。</p><p>调用结束时，flatMap 不会对结果用 Optional 封装，需要我们自己把返回值封装为 Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; <span class="hljs-function">Optional&lt;U&gt; <span class="hljs-title">flatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends Optional&lt;? extends U&gt;&gt; mapper)</span> </span>&#123;<br>    Objects.requireNonNull(mapper);<br>    <span class="hljs-keyword">if</span> (!isPresent()) &#123;<br>      <span class="hljs-keyword">return</span> empty();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>      Optional&lt;U&gt; r = (Optional&lt;U&gt;) mapper.apply(value);<br>      <span class="hljs-keyword">return</span> Objects.requireNonNull(r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-11-filter-方法"><a href="#2-11-filter-方法" class="headerlink" title="2.11 filter 方法"></a>2.11 filter 方法</h3><p>如果有值并且满足断言条件返回包含该值的 Optional，否则返回空 Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span> </span>&#123;<br>    Objects.requireNonNull(predicate);<br>    <span class="hljs-keyword">if</span> (!isPresent()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> predicate.test(value) ? <span class="hljs-keyword">this</span> : empty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="3-使用例"><a href="#3-使用例" class="headerlink" title="3. 使用例"></a>3. 使用例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Optional&lt;String&gt; op1 = Optional.of(<span class="hljs-string">&quot;hello&quot;</span>);<br>    Optional&lt;String&gt; op2 = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br>    <br>    <span class="hljs-keyword">if</span>(op1.isPresent())&#123;<br>      System.out.println(op1.get());<br>    &#125;<br>    <span class="hljs-keyword">if</span>(op2.isPresent())&#123;<br>      System.out.println(op2.get());<br>    &#125;<br><br>    op1.ifPresent(str-&gt;System.out.println(str));<br>    op2.ifPresent(str-&gt;System.out.println(str));<br>    <br>    System.out.println(op1.orElse(<span class="hljs-string">&quot;如果op1中的值为null则返回这句话&quot;</span>));<br>    System.out.println(op2.orElse(<span class="hljs-string">&quot;如果op2中的值为null则返回这句话&quot;</span>));<br><br>    System.out.println(op1.orElseGet(()-&gt;<span class="hljs-string">&quot;自己定义的返回值&quot;</span>));<br>    System.out.println(op2.orElseGet(()-&gt;<span class="hljs-string">&quot;自己定义的返回值&quot;</span>));<br><br>    Optional&lt;Integer&gt; map1 = op1.map(str-&gt;<span class="hljs-number">1</span>);<br>    System.out.println(map1.orElse(<span class="hljs-number">0</span>));<br>    Optional&lt;Double&gt; map2 = op2.map(str-&gt;<span class="hljs-number">1.2</span>);<br>    System.out.println(map2.orElse(<span class="hljs-number">0D</span>));<br><br>    Optional&lt;String&gt; flatMap = op1.flatMap(str-&gt;Optional.of(str+<span class="hljs-string">&quot;_s&quot;</span>));<br>    System.out.println(flatMap.get());<br><br>    op1 = op1.filter(str-&gt;str.length()&lt;<span class="hljs-number">10</span>);<br>    System.out.println(op1.orElse(<span class="hljs-string">&quot;值为null&quot;</span>));<br>    op1 = op1.filter(str-&gt;str.length()&gt;<span class="hljs-number">10</span>);<br>    System.out.println(op1.orElse(<span class="hljs-string">&quot;值为null&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/06/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/4.%20Stream/"/>
    <url>/2021/07/06/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/4.%20Stream/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>java.util.stream.Stream</code> 接口，表示能应用在一组元素上，一次执行的操作序列，也就是可以对一组数据进行连续的多次操作。</p><p>Stream 在使用的时候，需要指定一个数据源，比如 <code>java.util.Collection</code> 的子类， List 或者 Set 都可以，但是 Map 类型的集合不支持。</p><p>Stream 是对集合功能的增强，它提供了各种非常便利、高效的聚合操作，可以大批量数据操作，同时再 结合Lambda表达式，就可以极大的提高编程效率。</p><p>Stream 的 API 提供了串行和并行两种模式进行操作数据。</p><br/><h2 id="2-其他转-Stream"><a href="#2-其他转-Stream" class="headerlink" title="2. 其他转 Stream"></a>2. 其他转 Stream</h2><p>可以将现有的数据，转换为 Stream 对象，然后再使用 Stream 的 API 对数据进行一些系列操作。</p><h3 id="2-1-值"><a href="#2-1-值" class="headerlink" title="2.1 值"></a>2.1 值</h3><p>可以通过 Stream.of 方法转为 Stream 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        Stream&lt;Integer&gt; stream1 = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>        Stream&lt;Character&gt; stream2 = Stream.of(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>);<br>        Stream&lt;Double&gt; stream3 = Stream.of(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>);<br>        Stream&lt;Boolean&gt; stream4 = Stream.of(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>Stream.of 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T... values)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Arrays.stream(values);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上是调用 Arrays.Stream 方法把传入的数据转换为了 Stream。</p><br/><p>Arrays.Stream 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">stream</span><span class="hljs-params">(T[] array)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> stream(array, <span class="hljs-number">0</span>, array.length);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-数组"><a href="#2-2-数组" class="headerlink" title="2.2 数组"></a>2.2 数组</h3><p>可以通过 Arrays.Stream 方法或 Stream.of 方法把数组转为 Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] arr = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>        Stream&lt;String&gt; stream1 = Arrays.stream(arr);<br>        Stream&lt;String&gt; stream2 = Stream.of(arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-3-集合"><a href="#2-3-集合" class="headerlink" title="2.3 集合"></a>2.3 集合</h3><p>只要是 Collection 类型的集合，都可以调用 stream 方法，将集合转换为 Stream 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Collections.addAll(list,<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        Stream&lt;String&gt; stream = list.stream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>stream 方法是 Collection 接口里的一个默认方法。所以只要是 Collection 类型的集合，就可以调用 stream 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-4-基本类型"><a href="#2-4-基本类型" class="headerlink" title="2.4 基本类型"></a>2.4 基本类型</h3><p>对于基本数值类型，有专门的三种Stream类型： </p><ul><li>IntStream </li><li>LongStream </li><li>DoubleStream </li></ul><p>虽然也可以用Stream类型，并指定泛型。但是，在数据量较大的时候，自动拆箱/装箱会比较消耗性能，所以提供了上面三种专门针对基本类型的 Stream。</p><br/><h2 id="3-Stream-转其他"><a href="#3-Stream-转其他" class="headerlink" title="3. Stream 转其他"></a>3. Stream 转其他</h2><p>使用 Stream 的 API 对数据操作后，还可以把结果转换为其他类型。</p><h3 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h3><p>通过 toArray 方法可以把 Stream 转为数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;briup&quot;</span>);<br>String[] strArray = stream.toArray(String[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><br/><h3 id="3-2-集合"><a href="#3-2-集合" class="headerlink" title="3.2 集合"></a>3.2 集合</h3><p>通过 collect 方法可以把 Stream 转为对应的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;  <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;briup&quot;</span>);<br>List&lt;String&gt; list1 = stream.collect(Collectors.toList());<br></code></pre></td></tr></table></figure><br/><h3 id="3-3-字符串"><a href="#3-3-字符串" class="headerlink" title="3.3 字符串"></a>3.3 字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>String result = stream.collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>));<br>System.out.println(result);<br></code></pre></td></tr></table></figure><br/><h2 id="4-Stream-操作"><a href="#4-Stream-操作" class="headerlink" title="4. Stream 操作"></a>4. Stream 操作</h2><p>Stream操作分为中间操作或者最终操作两种： </p><ul><li>中间操作，返回Stream本身，这样就可以将多个操作依次串起来。</li><li>最终操作，返回一特定类型的计算结果。</li></ul><br/><h3 id="4-1-中间操作"><a href="#4-1-中间操作" class="headerlink" title="4.1 中间操作"></a>4.1 中间操作</h3><p>常用的中间操作，有以下几种：</p><h4 id="4-1-1-filter"><a href="#4-1-1-filter" class="headerlink" title="4.1.1 filter"></a>4.1.1 filter</h4><p>过滤方法，返回满足 predicate 指定的条件的所有元素的一个新流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>stream.filter(e-&gt;e.contains(<span class="hljs-string">&quot;o&quot;</span>)).forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-2-map"><a href="#4-1-2-map" class="headerlink" title="4.1.2 map"></a>4.1.2 map</h4><p>对调用流中的元素，应用 Function 所指定的操作，然后返回一个新流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">Stream&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends R&gt; mapper)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;briup&quot;</span>);<br>List&lt;Integer&gt; list = stream.map(str -&gt; str.length())<br> .collect(Collectors.toList());<br>list.forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-3-reduce"><a href="#4-1-3-reduce" class="headerlink" title="4.1.3 reduce"></a>4.1.3 reduce</h4><p>reduce 方法是将一组数据俩俩合并，最后得出一个结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">IntStream stream = IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">int</span> result = stream.reduce(<span class="hljs-number">0</span>, (a, b) -&gt; a + b);<br>System.out.println(result);<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-4-sorted"><a href="#4-1-4-sorted" class="headerlink" title="4.1.4 sorted"></a>4.1.4 sorted</h4><p>将流里的数据进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">sorted</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>stream.sorted((o1, o2) -&gt; o1.compareTo(o2))<br>  .forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-5-limit"><a href="#4-1-5-limit" class="headerlink" title="4.1.5 limit"></a>4.1.5 limit</h4><p>返回 Stream 的前面 n 个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">limit</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxSize)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream =<br>Stream.of(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;javap&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;javascript&quot;</span>);<br>stream.limit(<span class="hljs-number">5</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-6-skip"><a href="#4-1-6-skip" class="headerlink" title="4.1.6 skip"></a>4.1.6 skip</h4><p>跳过前 n 个元素只要后面的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">skip</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream =<br>Stream.of(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;javap&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;javascript&quot;</span>);<br>stream.skip(<span class="hljs-number">5</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-7-distinct"><a href="#4-1-7-distinct" class="headerlink" title="4.1.7 distinct"></a>4.1.7 distinct</h4><p>去除重复数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">distinct</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream =<br>Stream.of(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>);<br>stream.distinct().forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-8-Stream-concat"><a href="#4-1-8-Stream-concat" class="headerlink" title="4.1.8 Stream.concat"></a>4.1.8 Stream.concat</h4><p>拼接两个流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Stream&lt;T&gt; <span class="hljs-title">concat</span><span class="hljs-params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">  //...  </span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>Stream&lt;String&gt; stream2 = Stream.of(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>Stream&lt;String&gt; result = Stream.concat(stream1, stream2);<br>result.forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-9-Stream-generate"><a href="#4-1-9-Stream-generate" class="headerlink" title="4.1.9 Stream.generate"></a>4.1.9 Stream.generate</h4><p>通过 Supplier 接口,可以自己来控制数据的生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title">generate</span><span class="hljs-params">(Supplier&lt;T&gt; s)</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br><span class="hljs-comment">//生成100个随机数,并输出</span><br>Stream.generate(()-&gt;random.nextInt(<span class="hljs-number">100</span>))<br>  .limit(<span class="hljs-number">100</span>)<br>  .forEach(System.out::println);<br><br><span class="hljs-comment">//生成100个随机数,并存放到集合中</span><br>List&lt;Integer&gt; list = Stream.generate(()-&gt;random.nextInt(<span class="hljs-number">100</span>))<br>  .limit(<span class="hljs-number">100</span>)<br>  .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><br/><h4 id="4-1-10-Stream-iterate"><a href="#4-1-10-Stream-iterate" class="headerlink" title="4.1.10 Stream.iterate"></a>4.1.10 Stream.iterate</h4><p>它跟 reduce 操作很像，需要接受一个起始值（种子），然后通过函数得出一个 结果，再把结果当做参数传给函数，再得出第二个结果，依次类推，其实就是一个递归操作。</p><p>假设起始值为seed，函数为f，那么第一个元素是seed，第二个元素是f(seed)，第三个元素是f(f(seed)) ， 第四个元素是f(f(f(seed)))，以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title">iterate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T seed, <span class="hljs-keyword">final</span> UnaryOperator&lt;T&gt; f)</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成一个等差数列，公差为3，从0开始获取前10个数字</span><br>Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">3</span>)<br>  .limit(<span class="hljs-number">10</span>)<br>       .forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h3 id="4-2-最终操作"><a href="#4-2-最终操作" class="headerlink" title="4.2 最终操作"></a>4.2 最终操作</h3><h4 id="4-2-1-iterator"><a href="#4-2-1-iterator" class="headerlink" title="4.2.1 iterator"></a>4.2.1 iterator</h4><p>返回迭代器对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>    Iterator&lt;String&gt; it = stream.iterator();<br>    <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>        System.out.println(it.next());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="4-2-2-forEach"><a href="#4-2-2-forEach" class="headerlink" title="4.2.2 forEach"></a>4.2.2 forEach</h4><p>将调 Stream 中的每个元素，交给一个 Consumer 函数处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;briup&quot;</span>);<br>stream.forEach(System.out::println);<br></code></pre></td></tr></table></figure><br/><h4 id="4-2-3-count"><a href="#4-2-3-count" class="headerlink" title="4.2.3 count"></a>4.2.3 count</h4><p>统计流中的元素数，并返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;briup&quot;</span>);<br>System.out.println(stream.count())<br></code></pre></td></tr></table></figure><br/><h4 id="4-2-4-max-amp-min"><a href="#4-2-4-max-amp-min" class="headerlink" title="4.2.4 max &amp; min"></a>4.2.4 max &amp; min</h4><p>返回流中基于 comparator 所指定的比较规则，比较出的最大值/最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">max</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">min</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; comparator)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;briup&quot;</span>);<br><br>Optional&lt;String&gt; max = stream.max(String::compareTo);<br>System.out.println(max.get());<br><br>Optional&lt;String&gt; min = stream.min(String::compareTo);<br>System.out.println(min.get());<br></code></pre></td></tr></table></figure><br/><h4 id="4-2-5-toArray"><a href="#4-2-5-toArray" class="headerlink" title="4.2.5 toArray"></a>4.2.5 toArray</h4><p>使用调用流中的元素，生成数组返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] toArray();<br>&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>String[] strArray = stream.toArray(String[]::<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><br/><h4 id="4-2-6-collect"><a href="#4-2-6-collect" class="headerlink" title="4.2.6 collect"></a>4.2.6 collect</h4><p>将元素收集到一个可以修改的容器中，并返回该容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream1 = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>List&lt;String&gt; list1 = stream1.collect(Collectors.toList());<br><br>Stream&lt;String&gt; stream2 =<br>Stream2.of(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;javascript&quot;</span>);<br>Map&lt;Integer, List&lt;String&gt;&gt; map =<br>stream2.collect(Collectors.groupingBy(String::length));<br>map.forEach((k,v)-&gt; System.out.println(k+<span class="hljs-string">&quot; : &quot;</span>+v));<br></code></pre></td></tr></table></figure><br/><h4 id="4-2-7-xxxMatch"><a href="#4-2-7-xxxMatch" class="headerlink" title="4.2.7 xxxMatch"></a>4.2.7 xxxMatch</h4><p>匹配操作，Stream 中提供了多种匹配模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">anyMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">allMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">noneMatch</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream =<br>Stream.of(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;javascript&quot;</span>);<br><br><span class="hljs-comment">//以下这些操作不能同时执行，因为一个Stream只能使用一次</span><br><span class="hljs-comment">//所有元素匹配成功才返回true 否则返回false</span><br><span class="hljs-keyword">boolean</span> allMatch = stream.allMatch((s)-&gt;s.startsWith(<span class="hljs-string">&quot;j&quot;</span>));<br>System.out.println(allMatch);<br><br><span class="hljs-comment">//任意一个匹配成功就返回true 否则返回false</span><br><span class="hljs-keyword">boolean</span> anyMatch = stream.anyMatch((s)-&gt;s.startsWith(<span class="hljs-string">&quot;j&quot;</span>));<br>System.out.println(anyMatch);<br><br><span class="hljs-comment">//没有一个匹配的就返回true 否则返回false</span><br><span class="hljs-keyword">boolean</span> noneMatch = stream.noneMatch((s)-&gt;s.startsWith(<span class="hljs-string">&quot;j&quot;</span>));<br>System.out.println(noneMatch);<br></code></pre></td></tr></table></figure><br/><h4 id="4-28-findFirst"><a href="#4-28-findFirst" class="headerlink" title="4.28 findFirst"></a>4.28 findFirst</h4><p>返回 Stream 的第一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">findFirst</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream =<br>Stream.of(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;javascript&quot;</span>);<br>Optional&lt;String&gt; first = stream.findFirst();<br>System.out.println(first.get());<br></code></pre></td></tr></table></figure><br/><h2 id="5-并行流"><a href="#5-并行流" class="headerlink" title="5. 并行流"></a>5. 并行流</h2><p>Stream 有串行和并行两种。串行 Stream 上的操作是在一个线程中依次完成，而并行 Stream 则是在多个线程上同时执行。</p><p>创建并行Stream的俩种方式：</p><ul><li><p>调用串行 Stream 的 parallel() 方法，可以将其转换并行 Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>);<br>Stream&lt;String&gt; parallelStream = stream.parallel();<br></code></pre></td></tr></table></figure><br/></li><li><p>调用集合对象的 parallelStream 方法，之后获取并行 Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Collections.addAll(list,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;briup&quot;</span>);<br>Stream&lt;String&gt; parallelStream = list.parallelStream();<br></code></pre></td></tr></table></figure><br/></li></ul><p>例：排序并统计200万个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">2000000</span>;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(max);<br>      <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; max; i++) &#123;<br>          UUID uuid = UUID.randomUUID();<br>          list.add(uuid.toString());<br>        &#125;<br>      <br>        <span class="hljs-comment">//注意，前面生成字符串和存放到List中，也需要一些时间</span><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>      <br>        <span class="hljs-comment">//串行stream</span><br>        <span class="hljs-keyword">long</span> count = list.stream().sorted().count();<br>      <br>        <span class="hljs-comment">//并行stream</span><br>        <span class="hljs-comment">// long count = list.parallelStream().sorted().count();</span><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> time = end - start;<br>        System.out.println(<span class="hljs-string">&quot;排序并统计200万个字符串，耗时&quot;</span>+time+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看出，在数据量较大的特定场景下，并行Stream比串行Stream的效率要高一些。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/06/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/3.%20%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <url>/2021/07/06/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/3.%20%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>我们用 Lambda 表达式来实现匿名方法。但有些情况下，我们用 Lambda 表达式仅仅是调用一些已经存在的方法，除了调用动作外，没有其他任何多余的动作。在这种情况下，我们倾向于通过方法名来调用它，而 Lambda 表达式可以帮助我们实现这一要求，它使得 Lambda 在调用那些已经拥有方法名的方法的代码更简洁、更容易理解。方法引用可以理解为 Lambda 表达式的另外一种表现形式。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//使用Lambda表达式，直接表示一个函数</span><br>      <span class="hljs-comment">//这个函数就作为run方法的具体实现</span><br>      Action a1 = ()-&gt; System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>      <br>      <span class="hljs-comment">//使用Lambda表达式，引用一个已经存在的方法，作为当前要表示的一个函数</span><br>      <span class="hljs-comment">//这个被引用的方法，需要和Action接口中的抽象方法run保持一致：参数列表、返回类型</span><br>      <span class="hljs-comment">//这个方法就作为run方法的具体实现</span><br>      Action a2 = Student::sayHello;<br>      a1.run();<span class="hljs-comment">//输出hello</span><br>      a2.run();<span class="hljs-comment">//输出hello</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，以上代码中的 a1 和 a2 要表示的俩个函数，其实是一样的，它们的参数列表、函数主体、 返回类型都是一样的，只不过 a1 表示的函数自己直接写出来的，a2 表示的函数是引用提前写好的。</p><p>对应一个函数来说，我们不关心它的名字是什么，它在什么地方定义的，我们只关心函数的三要素：参数列表、函数主体、返回类型，只要能写出这个函数或者引用到这个函数，就可以直接拿来使用。</p><br/><h2 id="2-静态方法引用"><a href="#2-静态方法引用" class="headerlink" title="2. 静态方法引用"></a>2. 静态方法引用</h2><p>当静态方法的参数列表和返回值类型和接口中需要实现的方法一致时，就可以引用该静态方法作为接口中的方法的实现。</p><p>使用 Lambda 表达式可以引用类中的静态方式，语法要求为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法</span><br>类名::静态方法名<br><br><span class="hljs-comment">// 对应的 lambda 表达式。</span><br>(args) -&gt; 类名.staticMethod(args)<br></code></pre></td></tr></table></figure><br/><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//只要函数的参数列表是 String 类型，函数的返回值是 int 类型，就可以作为 Action 接口的具体实现。</span><br>    Action a1 = str -&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//使用 类名::静态方法名 的形式来引用当前类中的 len 方法</span><br>    Action a2 = Test::len;<br>    System.out.println(a1.run(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">//输出1</span><br>    System.out.println(a2.run(<span class="hljs-string">&quot;hello&quot;</span>)); <span class="hljs-comment">//输出5</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">len</span><span class="hljs-params">(String str)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> str.length();<br>  &#125;<br>  <br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="3-实例方法引用"><a href="#3-实例方法引用" class="headerlink" title="3. 实例方法引用"></a>3. 实例方法引用</h2><p>若 Lambda 参数列表中的第一个参数是实例方法的参数调用者，而第二个参数是实例方法的参数时，可以使用对象方法引用。</p><p>使用 Lambda 表达式可以引用类中的非静态方式，语法要求为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法</span><br>类名::非静态方法名<br>  <br><span class="hljs-comment">// 对应的 Lambda 表达式</span><br>(inst,args) -&gt; 类名.instMethod(args)<br></code></pre></td></tr></table></figure><br/><p>例1：run 方法只有一个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a1 = str -&gt; <span class="hljs-number">1</span>;<br>    Action a2 = String::hashCode;<br>    Action a3 = String::length;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>例2：run 方法有两个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a1 = (str,i) -&gt; <span class="hljs-number">1</span>;<br>    Action a2 = String::indexOf;<br>    Action a3 = String::lastIndexOf;<br>    System.out.println(a2.run(<span class="hljs-string">&quot;abc-abc&quot;</span>,<span class="hljs-string">&#x27;a&#x27;</span>));<span class="hljs-comment">//输出 0</span><br>    System.out.println(a3.run(<span class="hljs-string">&quot;abc-abc&quot;</span>,<span class="hljs-string">&#x27;a&#x27;</span>));<span class="hljs-comment">//输出 4</span><br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String str,<span class="hljs-keyword">int</span> i)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>例3：run 方法有三个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a1 = (str,i,j) -&gt; <span class="hljs-number">1</span>;<br>    Action a2 = String::indexOf;<br>    Action a3 = String::lastIndexOf;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(String str,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>例4：run 方法有四个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a = MyHandler::test;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(MyHandler handler, <span class="hljs-keyword">int</span> i, String str, List&lt;Integer&gt; list)</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, String str, List&lt;Integer&gt; list)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="4-通过对象引用方法"><a href="#4-通过对象引用方法" class="headerlink" title="4. 通过对象引用方法"></a>4. 通过对象引用方法</h2><p>上面的例子，都是使用类名来引用方法，也可以使用对象来引用它的非静态方式，语法要求为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法</span><br>对象::非静态方法<br>  <br><span class="hljs-comment">// 对应的 Lambda 表达式</span><br>(args) -&gt; inst.instMethod(args)<br></code></pre></td></tr></table></figure><br/><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    MyHandler handler = <span class="hljs-keyword">new</span> MyHandler();<br>    Action a1 = str -&gt; str;<br>    <span class="hljs-comment">//这里表示，使用 handler 对象的 test 方法，来对 Action 接口进行实现</span><br>    <span class="hljs-comment">//因为 test 方法的参数列表和返回类型，恰好是和run方法的参数列表和返回类型保持一致</span><br>    Action a2 = handler::test;;<br>    System.out.println(a2.run(<span class="hljs-string">&quot;tom&quot;</span>)); <span class="hljs-comment">//输出：hello! tom</span><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function">String <span class="hljs-title">run</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandler</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello! &quot;</span>+name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="5-构造方法引用"><a href="#5-构造方法引用" class="headerlink" title="5. 构造方法引用"></a>5. 构造方法引用</h2><p>使用Lambda表达式可以引用类中的构造函数，语法要求为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法</span><br>类名::<span class="hljs-keyword">new</span><br>  <br><span class="hljs-comment">// 对应的 Lambda 表达式</span><br>(args) -&gt; <span class="hljs-keyword">new</span> 类名(args)<br></code></pre></td></tr></table></figure><br/><h3 id="5-1-引用无参构造方法"><a href="#5-1-引用无参构造方法" class="headerlink" title="5.1 引用无参构造方法"></a>5.1 引用无参构造方法</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a1 = ()-&gt;<span class="hljs-keyword">new</span> Student();<br>    <span class="hljs-comment">//这里表示，使用Student类的无参构造函数，来对Action接口进行实现</span><br>    <span class="hljs-comment">//因为Student类的无参构造函数，恰好是和run方法的参数列表和返回类型保持一致</span><br>    Action a2 = Student::<span class="hljs-keyword">new</span>;<br>    System.out.println(a2.run());<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function">Student <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123; <br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="5-2-引用有参构造方法"><a href="#5-2-引用有参构造方法" class="headerlink" title="5.2 引用有参构造方法"></a>5.2 引用有参构造方法</h3><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Action a1 = ()-&gt;<span class="hljs-keyword">new</span> Student();<br>      <span class="hljs-comment">//这里表示，使用Student类的无参构造函数，来对Action接口进行实现</span><br>      <span class="hljs-comment">//因为Student类的无参构造函数，恰好是和run方法的参数列表和返回类型保持一致</span><br>      Action a2 = Student::<span class="hljs-keyword">new</span>;<br>      System.out.println(a2.run());<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function">Student <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="5-3-数组构造"><a href="#5-3-数组构造" class="headerlink" title="5.3 数组构造"></a>5.3 数组构造</h3><p>使用Lambda表达式可以引用数组类型的构造函数，语法要求为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数组类型::<span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure><br/><p>例如：根据给定的长度，创建任意类型的数组对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a1 = len -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>    <span class="hljs-comment">//这里表示，使用int数组的构造函数，来对Action接口进行实现</span><br>    <span class="hljs-comment">//因为int数组的构造函数，恰好是和run方法的参数列表和返回类型保持一致</span><br>    Action a2 = <span class="hljs-keyword">int</span>[]::<span class="hljs-keyword">new</span>;<br>    System.out.println(a2.run(<span class="hljs-number">5</span>));<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-keyword">int</span>[] run(<span class="hljs-keyword">int</span> len);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/04/CoreJava/2.%20%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <url>/2021/07/04/CoreJava/2.%20%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>Java 语言是一个面向对象的语言，但是 Java 中的基本数据类型却是不面向对象的。这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类。</p><table><thead><tr><th align="center">基本类型</th><th align="center">大小</th><th align="center">包装器类型</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">/</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">16bit</td><td align="center">Character</td></tr><tr><td align="center">byte</td><td align="center">8bit</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">16bit</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">32bit</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">64bit</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">32bit</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">64bit</td><td align="center">Double</td></tr><tr><td align="center">void</td><td align="center">/</td><td align="center">Void</td></tr></tbody></table><br/><p>Java中的包装器类有两个主要的目的：</p><ol><li>提供一种机制，将基本值“包装”到对象中，从而使基本值能够包含在为对象而保留的操作中，比如添加到 Collections 中，或者从带对象返回值的方法中返回。注意，java5 增加了自动装箱和拆箱，程序员过去需手工执行的许多包装操作，现在可以由 java 自动处理了。</li><li>为基本值提供分类功能。这些功能大多数于各种转换有关：在基本值和 String 对象间相互转换，在基本值和 String 对象之间按不同基数转换，如二进制、八进制和十六进制。</li></ol><br/><h2 id="2-包装类共同的方法"><a href="#2-包装类共同的方法" class="headerlink" title="2. 包装类共同的方法"></a>2. 包装类共同的方法</h2><ul><li>带有基本值参数并创建包装类对象的构造函数。如利用 Integer 包装类创建对象：<code>Integer obj=new Integer(145);</code></li><li>带有字符串参数并创建包装类对象的构造函数.如：<code>new Integer(“-45.36”);</code></li><li>可生成对象基本值的<code>typeValue</code>方法，如：<code>obj.intValue();</code></li><li>将字符串转换为基本值的<code>parseType</code>方法，如：<code>Integer.parseInt(args[0]);</code></li><li>生成哈稀表代码的<code>hashCode</code>方法，如：<code>obj.hasCode();</code></li><li>对同一个类的两个对象进行比较的<code>equals()</code>方法，如：<code>obj1.eauqls(obj2);</code></li><li>生成字符串表示法的<code>toString()</code>方法，如：<code>obj.toString().</code></li></ul><br/><h2 id="3-装箱与拆箱"><a href="#3-装箱与拆箱" class="headerlink" title="3. 装箱与拆箱"></a>3. 装箱与拆箱</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>Java 5 之后提供了自动装箱的特性。</p><ul><li>装箱就是自动将基本数据类型转换为包装器类型。</li><li>拆箱就是自动将包装器类型转换为基本数据类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">10</span>; <span class="hljs-comment">//装箱</span><br><span class="hljs-keyword">int</span> index = i;  <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></table></figure><br/><h3 id="3-2-实现机制"><a href="#3-2-实现机制" class="headerlink" title="3.2 实现机制"></a>3.2 实现机制</h3><p>以下代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">10</span>; <span class="hljs-comment">//装箱</span><br><span class="hljs-keyword">int</span> index = i;  <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></table></figure><p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是 Integer 的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是 Integer的<code>intValue</code>方法。</p><p>装箱过程是通过调用包装器的 valueOf 方法实现的，而拆箱过程是通过调用包装器的 xxxValue 方法实现的。</p><br/><h2 id="4-创建包装类对象的两种方法"><a href="#4-创建包装类对象的两种方法" class="headerlink" title="4. 创建包装类对象的两种方法"></a>4. 创建包装类对象的两种方法</h2><p>创建包装类有两种方法：直接赋值和使用 new 关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">10</span>;<br>Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><br/><p>两种方式的主要区别：</p><ul><li>第一种方式不会触发自动装箱的过程；而第二种方式会触发；</li><li>在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</li></ul><br/><h2 id="5-包装类值的比较"><a href="#5-包装类值的比较" class="headerlink" title="5. 包装类值的比较"></a>5. 包装类值的比较</h2><h3 id="5-1-和-equals-方法"><a href="#5-1-和-equals-方法" class="headerlink" title="5.1 == 和 equals 方法"></a>5.1 == 和 equals 方法</h3><table><thead><tr><th align="center">基本类型</th><th align="center">==</th><th align="center">equals</th></tr></thead><tbody><tr><td align="center">字符串变量</td><td align="center">对象在内存中的首地址</td><td align="center">字符串内容</td></tr><tr><td align="center">基本类型</td><td align="center">值</td><td align="center">不可用</td></tr><tr><td align="center">包装类</td><td align="center">地址</td><td align="center">内容</td></tr></tbody></table><br/><h3 id="5-2-Integer"><a href="#5-2-Integer" class="headerlink" title="5.2 Integer"></a>5.2 Integer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i1 = <span class="hljs-number">100</span>;<br>Integer i2 = <span class="hljs-number">100</span>;<br>Integer i3 = <span class="hljs-number">200</span>;<br>Integer i4 = <span class="hljs-number">200</span>;<br><br>System.out.println(i1==i2);  <span class="hljs-comment">//true</span><br>System.out.println(i3==i4);  <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>输出结果表明 i1 和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对象。</p><br/><p>查看 Integer 的 <code>valueOf</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(i &gt;= -<span class="hljs-number">128</span> &amp;&amp; i &lt;= IntegerCache.high)<br>      <span class="hljs-keyword">return</span> IntegerCache.cache[i + <span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，在通过 <code>valueOf</code> 方法创建 Integer 对象的时候，如果数值在 [-128,127] 之间，便返回指向 <code>IntegerCache.cache</code> 中已经存在的对象的引用；否则创建一个新的 Integer 对象。</p><p>Integer、Short、Byte、Character、Long 这几个类的 <code>valueOf</code> 方法的实现是类似的。</p><br/><h3 id="5-3-Double"><a href="#5-3-Double" class="headerlink" title="5.3 Double"></a>5.3 Double</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Double i1 = <span class="hljs-number">100.0</span>;<br>Double i2 = <span class="hljs-number">100.0</span>;<br>Double i3 = <span class="hljs-number">200.0</span>;<br>Double i4 = <span class="hljs-number">200.0</span>;<br><br>System.out.println(i1==i2);  <span class="hljs-comment">//false</span><br>System.out.println(i3==i4);  <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><br/><p>查看 Double 的 <code>valueOf</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Double <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">double</span> d)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Double(d);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每次装箱都会创建一个新的 Double 对象。</p><p>Double、Float 的 <code>valueOf</code> 方法的实现是类似的。</p><p>为什么 Double 类的 <code>valueOf</code> 方法会采用与 Integer 类的 <code>valueOf</code> 方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><br/><h3 id="5-4-Boolean"><a href="#5-4-Boolean" class="headerlink" title="5.4 Boolean"></a>5.4 Boolean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Boolean i1 = <span class="hljs-keyword">false</span>;<br>Boolean i2 = <span class="hljs-keyword">false</span>;<br>Boolean i3 = <span class="hljs-keyword">true</span>;<br>Boolean i4 = <span class="hljs-keyword">true</span>;<br><br>System.out.println(i1==i2);  <span class="hljs-comment">//true</span><br>System.out.println(i3==i4);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><br/><p>查看 Boolean 的 <code>valueOf</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (b ? TRUE : FALSE);<br>&#125;<br><br><span class="hljs-comment">// TRUE</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean TRUE = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-keyword">true</span>);<br><br><span class="hljs-comment">// FALSE</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Boolean FALSE = <span class="hljs-keyword">new</span> Boolean(<span class="hljs-keyword">false</span>);<br><br><span class="hljs-comment">// 构造器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Boolean</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> value)</span> </span>&#123;<br>   <span class="hljs-keyword">this</span>.value = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Boolean 的 <code>valueOf</code>方法返回的其实是一个常量。</p><br/><h3 id="5-5-含有表达式的比较"><a href="#5-5-含有表达式的比较" class="headerlink" title="5. 5 含有表达式的比较"></a>5. 5 含有表达式的比较</h3><p>当 “==” 运算符的两个操作数都是包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals 方法比较的是数值且不会进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer a = <span class="hljs-number">1</span>;<br>Integer b = <span class="hljs-number">2</span>;<br>Integer c = <span class="hljs-number">3</span>;<br>Integer d = <span class="hljs-number">3</span>;<br>Integer e = <span class="hljs-number">321</span>;<br>Integer f = <span class="hljs-number">321</span>;<br>Long g = <span class="hljs-number">3L</span>;<br>Long h = <span class="hljs-number">2L</span>;<br><br>System.out.println(c==d); <span class="hljs-comment">//true</span><br>System.out.println(e==f);  <span class="hljs-comment">//false</span><br>System.out.println(c==(a+b)); <span class="hljs-comment">//true</span><br>System.out.println(c.equals(a+b));  <span class="hljs-comment">//true</span><br>System.out.println(g==(a+b));  <span class="hljs-comment">//true</span><br>System.out.println(g.equals(a+b));  <span class="hljs-comment">//false</span><br>System.out.println(g.equals(a+h));  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><br/><h2 id="6-练习"><a href="#6-练习" class="headerlink" title="6. 练习"></a>6. 练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">97</span>); <br>Integer i2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">97</span>); <br><br><span class="hljs-comment">//比较引用地址</span><br>System.out.println(i1 == i2); <span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//比较值</span><br>System.out.println(i1.equals(i2)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i3 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">148</span>);<br>Integer i4 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">148</span>);<br><br><span class="hljs-comment">//比较引用地址</span><br>System.out.println(i3 == i4); <span class="hljs-comment">//false</span><br><br><span class="hljs-comment">//比较值</span><br>System.out.println(i3.equals(i4)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i5 = <span class="hljs-number">97</span>;<br>Integer i6 = <span class="hljs-number">97</span>;<br><br><span class="hljs-comment">//-128-127缓存了地址</span><br>System.out.println(i5 == i6); <span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//重写了方法</span><br>System.out.println(i5.equals(i6)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i7 = <span class="hljs-number">148</span>;<br>Integer i8 = <span class="hljs-number">148</span>;<br><span class="hljs-comment">//没缓存</span><br>System.out.println(i7 == i8); <span class="hljs-comment">//false</span><br>System.out.println(i7.equals(i8)); <span class="hljs-comment">//true</span><br><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">148</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">97</span>;<br>Integer c = <span class="hljs-number">97</span>;<br><span class="hljs-comment">//一个Integer 与 int比较，先将Integer转换成int类型，再做值比较，所以返回的是true。</span><br>System.out.println(i7==a); <span class="hljs-comment">//true</span><br>System.out.println(b==c); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/04/CoreJava/1.%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/07/04/CoreJava/1.%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-java-中的类型"><a href="#1-java-中的类型" class="headerlink" title="1. java 中的类型"></a>1. java 中的类型</h2><p>Java 是一种静态编程语言，所有变量和表达式是在编译时就确定的。同时，Java 又是一种强类型语言，所有的变量和表达式都有具体的类型，并且每种类型是严格定义的。</p><p>类型限制了变量可以拥有什么样的值，表达式最终会产生什么样的值，可以进行哪些操作。在Java中共有 8 中基本类型数据，同时每种基本类型又有对应的包装类。</p><br/><h2 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2. 基本类型"></a>2. 基本类型</h2><p>Java 共有 8 种基本数据类型。</p><ul><li>基本类型变量存储在堆栈中。</li><li>每种基本类型的所占的存储空间的大小的确定的。</li><li>基本类型具有的包装器类，使得可以在堆中创建一非基本类对象，用来标识对应的基本类型。</li></ul><table><thead><tr><th>基本类型</th><th>大小</th><th>最小值</th><th>最大值</th><th>包装器类型</th><th>默认值</th></tr></thead><tbody><tr><td>boolean</td><td>———</td><td>——</td><td>——</td><td>Boolean</td><td>false</td></tr><tr><td>char</td><td>16 bit</td><td>Unicode 0</td><td>Unicode 2^16-1</td><td>Character</td><td>null</td></tr><tr><td>byte</td><td>8 bit</td><td>-2^7</td><td>2^7-1</td><td>Byte</td><td>(byte)0</td></tr><tr><td>short</td><td>16 bit</td><td>-2^15</td><td>2^15-1</td><td>Short</td><td>(short)0</td></tr><tr><td>int</td><td>32 bit</td><td>-2^31</td><td>2^31-1</td><td>Integer</td><td>0</td></tr><tr><td>long</td><td>64bit</td><td>-2^63</td><td>2^63-1</td><td>Long</td><td>0L</td></tr><tr><td>float</td><td>32 bit</td><td>IEEE 754</td><td>IEEE 754</td><td>Float</td><td>0.0f</td></tr><tr><td>double</td><td>64 bit</td><td>IEEE 754</td><td>IEEE 754</td><td>Double</td><td>0.0d</td></tr></tbody></table><br/><h2 id="3-基本类型运算"><a href="#3-基本类型运算" class="headerlink" title="3. 基本类型运算"></a>3. 基本类型运算</h2><h3 id="3-1-逻辑运算"><a href="#3-1-逻辑运算" class="headerlink" title="3.1 逻辑运算"></a>3.1 逻辑运算</h3><p>boolean 类型的数据可以进行逻辑运算。</p><br/><h3 id="3-2-数值运算"><a href="#3-2-数值运算" class="headerlink" title="3.2 数值运算"></a>3.2 数值运算</h3><p>数值运算涉及到运算后的结果的类型问题，稍微比较复杂一点。一般来说，运算最终结果的类型与表达式中的最大（占用空间最大）的类型。</p><p><code>byte &lt;（short=char）&lt; int &lt; long &lt; float &lt; double</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> l = <span class="hljs-number">1</span> + <span class="hljs-number">2L</span>; <span class="hljs-comment">// 与1L的类型一致</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> + <span class="hljs-number">2L</span>; <span class="hljs-comment">// 编译不通过</span><br><span class="hljs-keyword">float</span> f = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1.2f</span>; <span class="hljs-comment">// 与1.2f的类型一致</span><br><span class="hljs-keyword">double</span> d = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1.2</span>; <span class="hljs-comment">// 与1.2的类型一致</span><br></code></pre></td></tr></table></figure><br/><p>如果两种相同的类型的数据进行运算，按理来说，运算结果应该还是那个类型。但事实上，byte、char、short 等类型不满足这个结论的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 编译不通过，编辑器报：Type mismatch: cannot convert from int to byte 。</span><br><span class="hljs-keyword">byte</span> s1 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">byte</span> s2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">byte</span> s = s1 + s2;<br><br><span class="hljs-comment">// 编译不通过，编辑器报：Type mismatch: cannot convert from int to char 。</span><br><span class="hljs-keyword">char</span> s1 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">char</span> s2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">char</span> s = s1 + s2;<br><br><span class="hljs-comment">// 编译不通过，编辑器报：Type mismatch: cannot convert from int to short 。</span><br><span class="hljs-keyword">short</span> s1 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">short</span> s2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">short</span> s = s1 + s2;<br></code></pre></td></tr></table></figure><br/><p>从字面上来看，1+1=2 绝对没有超过这个类型的范围。下面的例子都可以编译通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">byte</span> s1 = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">char</span> s2 = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">short</span> s3 = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这是因为 Java 中的数值运算最低要求是 int 类型，如果参与运算的变量类型都没有超过 int 类型，则它们都会被自动升级为 int 类型再进行运算，所以它们运算后的结果类型也是 int 类型。这种方式所得到结果是否超过了对应类型所表示的范围只能在运行时才能确定，在编译时是无法知晓的。而编译器会直接将 byte s1 = 1 + 1 编译成 byte s1 = 2，这个表达式在编译器就可以确定是合法表达式，故可以通过编译。</p><br/><h2 id="4-基本类型转换"><a href="#4-基本类型转换" class="headerlink" title="4. 基本类型转换"></a>4. 基本类型转换</h2><p>Java 中除了 boolean 类型之外，其他 7 中类型相互之间可以进行转换。转换分为自动转换和强制转换。对于自动转换（隐式），无需任何操作，而强制类型转换需要显式转换，，即使用转换操作符（type）。</p><p>类型转换的总则是：小可直接转大、大转小会失去精度。这句话的意思是较小的类型直接转换成较大的类型，没有任何影响；而较大的类型也可以转换为较小的类型，但是会失去精度。他们之间的转换都不会抛出任何运行时异常。小转大是 Java 帮我们自动进行转换的，与正常的赋值操作完全一样；大转小需要进行强制转换操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自动转换</span><br><span class="hljs-keyword">long</span> l = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">float</span> = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 强制转换</span><br><span class="hljs-keyword">int</span> a = (<span class="hljs-keyword">int</span>) <span class="hljs-number">1.0</span>;<br><span class="hljs-keyword">char</span> c = (<span class="hljs-keyword">char</span>) a;<br></code></pre></td></tr></table></figure><p>大转小是一个很不安全的动作，可能导致莫名其妙的错误。譬如在下面的代码中，111111111111L 强转成 int 类型后，其值（-1285418553）与转换前的值相差巨大。这是由于在进行强制转换时，在二进制层面上直接截断，导致结果“面目全非”。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/01/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/2.%20Lambda/"/>
    <url>/2021/07/01/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/2.%20Lambda/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>Lambda 表达式是 JDK1.8 新增的一种语法，以确保在 java 代码中可以支持函数式编程，让代码的表示含义更简单。</p><br/><h3 id="1-2-行为参数化"><a href="#1-2-行为参数化" class="headerlink" title="1.2. 行为参数化"></a>1.2. 行为参数化</h3><p>行为参数化，就是可以帮助你处理频繁变更的需求的一种软件开发模式。</p><p>行为参数化，旨在抽象出具有某种功能的代码（它的输入参数和返回值是固定的），以某种方式将此代码传入到其他的方法中，以辅助它们的操作。</p><br/><h4 id="1-2-1-实例"><a href="#1-2-1-实例" class="headerlink" title="1.2.1 实例"></a>1.2.1 实例</h4><p>应对不断变化的需求的一个例子——选苹果。<br>苹果的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;<br>    <span class="hljs-keyword">private</span> String color;<br>    <span class="hljs-comment">// constructor, setter, getter</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><p>需求一：挑选出集合中的青苹果或者红苹果。</p><p>我们可以非常容易的想到下面的方法，在挑选的方法参数列表中加上 color 条件。遍历集合，如果当前苹果的颜色跟指定颜色相等，则加入到表示结果的集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Apple&gt; <span class="hljs-title">filterApplesByColor</span><span class="hljs-params">(List&lt;Apple&gt; inventory, String color)</span></span>&#123;<br>    List&lt;Apple&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Apple apple : inventory)&#123;<br>        <span class="hljs-keyword">if</span> (color.equals(apple.getColor()))<br>            result.add(apple);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>需求二：挑选出集合中重量大于200的苹果。</p><p>和需求一的解决方案类似，在挑选的方法参数列表中加上 weight 参数。遍历集合，如果当前苹果的重量大于 weight，则加入到表示结果的集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Apple&gt; <span class="hljs-title">filterApplesByWeight</span><span class="hljs-params">(List&lt;Apple&gt; inventory, <span class="hljs-keyword">int</span> weight)</span></span>&#123;<br>    List&lt;Apple&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Apple apple : inventory)&#123;<br>        <span class="hljs-keyword">if</span> (apple.getWeight() &gt; weight)<br>            result.add(apple);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><br/>……需求N：挑选重量在100~200之间的红色苹果。<br/><p>此时，如果按照上面的方法，需要不断地实现挑选苹果的方法。怎么简化开发呢？其实，上面的方法各不相同，但是他们有一个共同点，就是选择苹果时，需要一个标准，满足这个标准则挑选出来，否则，跳过。很明显，这个标准可以定义为只有两种返回值的布尔类型的方法。如果能够定义这样的标准，并把它们传递给挑选方法，我们通过一个挑选方法就可以挑选满足各种条件的苹果。那么，怎么实现这个想法呢？</p><p>答案是，通过对象传递方法。</p><br/><h4 id="1-2-2-解决"><a href="#1-2-2-解决" class="headerlink" title="1.2.2 解决"></a>1.2.2 解决</h4><p>先定义一个接口，这个接口只有一个抽象方法，传递给它一个苹果，它返回boolean类型的结果。<br>当前不需要关心这个抽象方法的方法体的具体判断内容是什么。首要任务是，能把这个方法传递给挑选苹果的方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplePredicate</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/>此时，我们在挑选苹果的方法中调用这个挑选条件。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Apple&gt; <span class="hljs-title">filterApplesByPredicate</span><span class="hljs-params">(List&lt;Apple&gt; inventory, ApplePredicate predicate)</span></span>&#123;<br>    List&lt;Apple&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Apple apple : inventory)&#123;<br>        <span class="hljs-keyword">if</span> (predicate.test(apple))<br>            result.add(apple);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>以后，我们再挑选苹果，只需要把实现 ApplePredicate 接口，覆写 predicate.test(apple) 方法，把实现类的实例传递给挑选苹果的方法就可以选择满足条件的苹果，我们不需要多次写挑选苹果的代码。</p><p>比如，我们要挑选出青苹果，首先实现覆写test方法，然后将接口的实例传递给挑选苹果的方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleColorPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;green&quot;</span>.equals(apple.getColor());<br>    &#125;<br>&#125;<br>List&lt;Apple&gt; result = filterApplesByPredicate(appleList, <span class="hljs-keyword">new</span> AppleColorPredicate());<br></code></pre></td></tr></table></figure><br/><p>同样，我们以可以选择重量在160一下的苹果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleWeightPredicate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplePredicate</span></span>&#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> apple.getWeight() &lt; <span class="hljs-number">160</span>;<br>     &#125;<br> &#125;<br>List&lt;Apple&gt; result = filterApplesByPredicate(appleList, <span class="hljs-keyword">new</span> AppleWeightPredicate());<br></code></pre></td></tr></table></figure><br/><p>至此，我们以可以不用重复编写挑选苹果的方法，只需要覆写挑选条件方法即可，这比行为参数化之间简化了代码量。但是，这也有一个很大的弊端，随着挑选条件的变化，我们需要不停地创建新的实现了指定接口的类。</p><p>一个好主意是，使用匿名类。比如，挑选出重量小于200的绿苹果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterApplesByAnonymousPredicate</span><span class="hljs-params">()</span></span>&#123;<br>    List&lt;Apple&gt; result = filterApplesByPredicate(appleList, <span class="hljs-keyword">new</span> ApplePredicate()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(Apple apple)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;green&quot;</span>.equals(apple.getColor()) &amp;&amp; apple.getWeight() &lt; <span class="hljs-number">200</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>上述代码中，使用了匿名内部类的方式，虽然简化了之前的代码，但是每次调用还是编写了很多相同代码。</p><p>其实我们真正的关心的只有三点： 方法的参数列表，方法中的核心操作代码和方法的返回类型。 也就是：传入指定参数，通过核心计算，给出最后结果。</p><br/><h3 id="1-3-函数式编程"><a href="#1-3-函数式编程" class="headerlink" title="1.3 函数式编程"></a>1.3 函数式编程</h3><p>函数式编程是面向数学的抽象，将计算过程描述为一种表达式求值。简单说，函数式程序就是一个表达式。 </p><p>严格意义上的表达式，就是由数据和操作符按照一定的规则，组合在一起形成的序列，并且所有的表达式都是有返回结果的，这是这里所说的表达式和代码语句的最大的区别。</p><br/><h2 id="2-Lambda-表达式"><a href="#2-Lambda-表达式" class="headerlink" title="2. Lambda 表达式"></a>2. Lambda 表达式</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>Lambda 表达式，可以用来表示一个函数，它只关注函数的参数列表，函数主体、返回类型，并且可以将此函数作为一个参数，进行传递。但在 java中，Lambda 表达式还有另一个存在的意义，那就是作为一个接口的实现类对象。</p><p>例 2-1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a = (str) -&gt; str.length();<br>    System.out.println(a.test(<span class="hljs-string">&quot;hello&quot;</span>));<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(String str)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，Lambda 表达式虽然可以通过（参数列表，函数主体、返回类型）三部分来表示一个具体的函数操作，但是它必须是依托于一个接口才行，所以 Lambda 表达式就是对接口中抽象方法的实现。</p><br/><h3 id="2-2-使用场合"><a href="#2-2-使用场合" class="headerlink" title="2.2 使用场合"></a>2.2 使用场合</h3><p>虽然 Lambda 表达式在 java 中的实际意义是对一个接口的实现，但并不是任何接口都可以使用 Lambda 表达式来进行实现。 </p><p>原因很简单，一个 Lambda 表达式只是描述了一个函数的参数列表、函数主体、返回类型，那么它顶多是对接口中的一个抽象方法的实现。如果接口中有多个抽象方法，这时候一个 Lambda 表达式是无法表示为这个接口的实现。 </p><p>因此，接口中有且只有一个抽象方法的时候（函数式接口），才可以使用Lambda表达式来对其进行实现。‘</p><br/><h3 id="2-3-语法规则"><a href="#2-3-语法规则" class="headerlink" title="2.3 语法规则"></a>2.3 语法规则</h3><p>Lambda表达式的格式为： () -&gt; {}</p><ul><li>() 表示参数列表。</li><li> -&gt; 后面跟的是函数主体。 </li><li>{} 函数主体，表达式的返回值，由这个函数主体中代码来决定。</li></ul><br/><p>函数式接口中，抽象方法常见的有以下几种情况：</p><ol><li><p>函数式接口中，抽象方法无参，无返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Action action1 = () -&gt; &#123;&#125;;<br><br>      <span class="hljs-comment">//函数主体中，如果只有一句代码，那么可以省去大括号</span><br>      Action action2 = () -&gt; System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>      <span class="hljs-comment">//函数主体中，如果有多句代码，那么大括号必须要写</span><br>      Action action3= () -&gt; &#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>        System.out.println(a+b);<br>      &#125;;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数式接口中，抽象方法有参，无返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Action action = (<span class="hljs-keyword">int</span> a) -&gt; &#123;&#125;;<br>        <span class="hljs-comment">//只有一个参数时，可以不加小括号</span><br>        <span class="hljs-comment">//并且参数的类型，JVM运行时会做自动推断的，即使不写，它也知道是int</span><br>        Action action1 = a -&gt; &#123;&#125;;<br>        Action action2 = a -&gt; System.out.println(a);<br>        Action action3 = a -&gt; a++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数式接口中，抽象方法无参，有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//如果就一句代码，大括号可以去掉，return关键字也会省去</span><br>      Action action1 = () -&gt; <span class="hljs-number">1</span>;<br><br>      Action action2 = () -&gt; &#123;<br>        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(Math.random()*num);<br>      &#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>函数式接口中，抽象方法有参，有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Action action1 = (a,b) -&gt; a + b;<br>        Action action2 = (a,b) -&gt; &#123;<br>          <span class="hljs-keyword">int</span> num = a+b;<br>          <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(Math.random()*num);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>Lambda 表达式中的参数列表，里面的参数可以不写类型，因为 JVM 在运行时会自动推断， 当然，如果直接手动写上去，也完全没有问题。</p><br/><h2 id="3-类型推断"><a href="#3-类型推断" class="headerlink" title="3. 类型推断"></a>3. 类型推断</h2><p>使用 Lambda 表达式，相当于给函数式接口生成一个实例，但是 Lambda 表达式本身，并不包含这个接口的任何信息。</p><p>Lambda 表达式中没有接口的任何信息，JVM 还能将其和接口匹配的上，那是因为：</p><ul><li>我们在使用 Lambda 表达式的时候，JVM 是会通过上下文自动推断它所属接口类型的。</li><li>接口中只有一个抽象方法，自然也能匹配成功该表达式所对应实现的抽象方法。</li><li>类似的，JVM还能自动推断出Lambda表达式中参数的类型</li></ul><br/><h2 id="4-重载解析"><a href="#4-重载解析" class="headerlink" title="4. 重载解析"></a>4. 重载解析</h2><p>如果类中的方法进行了重载，那么在使用Lambda表达式的时候，很可能给它的类型推断带来问题。</p><p>例 4-1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//编译报错，因为俩个方法都符合</span><br>      test(<span class="hljs-number">1</span>,num -&gt; num&gt;<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,Predicate&lt;Integer&gt; p)</span></span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,Function&lt;Integer,Boolean&gt; f)</span></span>&#123;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这时候编译报错，因为表达式 num -&gt; num&gt;0 对于俩个方法都符合 既符合 Predicate 的实现，也符合 Function 的实现。</p><br/><p>可以使用类型转换，来解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//编译通过，用强转的方式指定了表达式的对应的接口类</span><br>      test(<span class="hljs-number">1</span>,(Predicate&lt;Integer&gt;)(num-&gt;num&gt;<span class="hljs-number">0</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,Predicate&lt;Integer&gt; p)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,Function&lt;Integer,Boolean&gt; f)</span></span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h2 id="5-局部变量"><a href="#5-局部变量" class="headerlink" title="5. 局部变量"></a>5. 局部变量</h2><p>如果在 Lambda 表达式中，使用了局部变量，那么这个局部变量就一定要使用 final 修饰符进行修饰， 这方面的语法要求，和之前学习的匿名内部类保持一致。</p><p>例 5-1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    Runnable run = ()-&gt;&#123;<br>      <span class="hljs-comment">//这里访问局部变量a之后，a就自动变成了final修饰的常量（JDK1.8）</span><br>      <span class="hljs-comment">//也可以手动给局部变量a加上final修饰符</span><br>      <span class="hljs-comment">//变量a的值将不可被再次赋值，变为了常量</span><br>      System.out.println(a);<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，JDK1.8中，被匿名内部类、局部内部类、Lambda 表示访问的局部变量，会默认加上 final 修饰符。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/01/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/1.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/07/01/JDK%201.8%20%E6%96%B0%E7%89%B9%E6%80%A7/1.%20%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-接口方法"><a href="#1-接口方法" class="headerlink" title="1. 接口方法"></a>1. 接口方法</h2><p>JDK1.8之前，接口中的方法都必须是抽象方法。实现接口的类，必须实现接口中定义的每一个抽象方法。</p><p>如果在程序设计过程中，设计了一个接口，其中包含两个方法，这个接口被多次实现并引用。 后续升级过程中，发现需要在接口中新增 2-3 个方法的定义，会出现什么情况？</p><p>为了解决这个问题，JDK1.8 中引入了一种新的机制：接口可以支持在声明方法的同时，提供实现。 主要通过两种方式可以完成这种操作：默认方法和静态方法。</p><p>在接口中，以上俩种方法都可以有具体实现。因此，实现接口的类，可以继承这些方法并直接使用，就不再需要强制在实现类中的去实现（重写）接口中的方法了。这种机制可以使我们更平滑地进行接口的优化和演进。</p><br/><h3 id="1-1-默认方法"><a href="#1-1-默认方法" class="headerlink" title="1.1 默认方法"></a>1.1 默认方法</h3><h4 id="1-1-1-定义默认方法"><a href="#1-1-1-定义默认方法" class="headerlink" title="1.1.1 定义默认方法"></a>1.1.1 定义默认方法</h4><p>JDK1.8中，接口里面可以定义默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceName</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">default</span> returnType <span class="hljs-title">methodName</span><span class="hljs-params">(arg-list)</span></span>&#123;<span class="hljs-comment">//...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FirstInterface</span></span>&#123;<br>  <span class="hljs-comment">//传统定义,抽象方法，没有方法体。</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//默认方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;接口中的默认方法&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FirstInterface</span></span>&#123;<br>  <span class="hljs-comment">//所有实现类必须实现接口中未实现的方法。</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是FirstInterface中的抽象方法，所有实现类必须实现！&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultMethodTest</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    FirstClass fc = <span class="hljs-keyword">new</span> FirstClass();<br>    fc.test();<br>    fc.before();<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h4 id="1-1-2-默认方法的优点"><a href="#1-1-2-默认方法的优点" class="headerlink" title="1.1.2 默认方法的优点"></a>1.1.2 默认方法的优点</h4><p>默认方法存在的两大优势：</p><ul><li>可以让接口更优雅的升级，减少使用人员操作的负担。不必随着接口方法增加，从而修改实现代码，因为默认方法在子类中可以不用实现。</li><li>可以让实现类中省略很多不必要方法的空实现。</li></ul><br/><h4 id="1-1-3-默认方法冲突"><a href="#1-1-3-默认方法冲突" class="headerlink" title="1.1.3 默认方法冲突"></a>1.1.3 默认方法冲突</h4><p>例 1-1：一个类 C 实现两个接口A、B，其中接口 B 继承接口 A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Default Method test in A&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;default method test in B&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    C c = <span class="hljs-keyword">new</span> C();<br>    c.test();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-keyword">default</span> method test in B<br></code></pre></td></tr></table></figure><br/><p>例 1-2 ：一个类 C 实现两个接口A、B，但是A和B之间没有子父接口关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Default Method test in A&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;default method test in B&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//如下代码编译会报错。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class C implements A,B&#123;</span><br><span class="hljs-comment">  public static void main(String[] args)&#123;</span><br><span class="hljs-comment">    C c = new C();</span><br><span class="hljs-comment">    c.test();</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//如果 C 需要同时实现 A 和 B 接口，那么必须显示覆盖。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//如果在C中需要显示访问A/B的默认方法，可以使用接口名.super.方法名();</span><br>    A.<span class="hljs-keyword">super</span>.test();<br>    B.<span class="hljs-keyword">super</span>.test();<br>    <span class="hljs-comment">//或者自己编写test方法的实现</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>例 1-3 ：：一个类C，继承父类A，实现接口B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Default Method test in A&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;default method test in B&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    C c = <span class="hljs-keyword">new</span> C();<br>    c.test();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：default method test in A</span><br></code></pre></td></tr></table></figure><br/><p>方法调用的判断规则： </p><ol><li>类中声明的方法优先级最高。 类或父类中声明的方法要高于任何默认方法的优先级。</li><li>如果无法依据第一条进行判断，那么子接口的优先级更高。</li><li>最后，如果还是无法判断，那么继承了多个接口的类，必须通过实现（重写）方法来确定方法的调用。</li></ol><br/><h3 id="1-2-静态方法"><a href="#1-2-静态方法" class="headerlink" title="1.2 静态方法"></a>1.2 静态方法</h3><h4 id="1-2-1-定义静态方法"><a href="#1-2-1-定义静态方法" class="headerlink" title="1.2.1 定义静态方法"></a>1.2.1 定义静态方法</h4><p>JDK1.8中，接口里面可以定义静态方法。和类中定义的静态方法类似，接口中的静态方法可以直接通过 <code>接口名.静态方法名</code> 的形式进行访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceName</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">static</span> returnType <span class="hljs-title">methodName</span><span class="hljs-params">(arg-list)</span></span>&#123;<br>    <span class="hljs-comment">//代码实现</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>例 1-4：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StaticMethod</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是StaticMethod接口中的静态方法！&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StaticMethod</span></span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    <span class="hljs-comment">//运行成功</span><br>    StaticMethod.test();<br>    <span class="hljs-comment">//编译报错：</span><br>    <span class="hljs-comment">//Static method may be invoked on containing interface class only</span><br>    <span class="hljs-comment">//A.test();</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中的静态方法，只能使用当前接口的名字来调用。</p><BR/><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><p>有且只有一个抽象方法的接口，就是函数式接口。该接口中，也允许有其他的默认方法和静态方法。</p><p>例 2-1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是函数式接口。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action1</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//这是函数式接口。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action2</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是默认实现&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><p>例 2-2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是函数式接口。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Calculate</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//这不是函数式接口，因为接口 SubCalculate 中有俩个抽象方法，自己一个，继承一个。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SubCalculate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Calculate</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span> b)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//这不是函数式接口，因为接口 Noting 中没有任何抽象方法。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Noting</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><br/><p>JDK1.8中，针对函数式接口，新增了一个注解 <code>@FunctionalInterface </code>，用来检查被标注的接口是否是一个函数式接口。如果不是，那么编译器会报错。 但是，该注解不是必须要用的，它只是会让编辑器帮我们检查一下而已，以免出现接口中抽象方法的个数不是 1 的情况。</p><br/><h2 id="3-常用的函数式接口"><a href="#3-常用的函数式接口" class="headerlink" title="3. 常用的函数式接口"></a>3. 常用的函数式接口</h2><p>JDK1.8 中已经定了一些会常用到的函数式接口，这些函数式接口都定义在 <code>java.lang.function</code> 包中。例如 <code>Predicate</code> 、 <code>Consumer </code>、 <code>Function</code> 、 <code>Supplier</code> 、 <code>UnaryOperator</code> 和 <code>BinaryOperator</code> 等。如果需要，也可以自己定义类似的函数式接口，并不是必须要使用这些定义好的接口。</p><br/><h3 id="3-1-Predicate"><a href="#3-1-Predicate" class="headerlink" title="3.1 Predicate"></a>3.1 Predicate</h3><h4 id="3-1-1-抽象方法"><a href="#3-1-1-抽象方法" class="headerlink" title="3.1.1 抽象方法"></a>3.1.1 抽象方法</h4><p><code>java.util.function.Predicate</code> 接口定义了一个名叫 test 的抽象方法，它接受泛型 T 对象， 并返回一个 boolean 类型的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure><br/><p>例 3-1：定义一个方法，用来过滤数组中所有符合要求的数据，选出大于50的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      Integer[] arr = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">43</span>,<span class="hljs-number">123</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6</span>,<span class="hljs-number">56</span>,<span class="hljs-number">7</span>&#125;;<br>      arr = t.filter(arr,e-&gt;e&gt;<span class="hljs-number">50</span>);<br>      System.out.println(Arrays.toString(arr));<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> Integer[] filter(Integer[] arr, Predicate&lt;Integer&gt; p)&#123;<br>      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <br>      <span class="hljs-keyword">for</span>(Integer i: arr)&#123;<br>        <span class="hljs-comment">//判断当前数据是否符合要求</span><br>        <span class="hljs-keyword">if</span>(p.test(i))&#123;<br>          list.add(i);<br>        &#125;<br>      &#125;<br>    <br>      <span class="hljs-comment">//把集合转为Integer类型数组</span><br>      <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> Integer[list.size()]);<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>[<span class="hljs-number">123</span>, <span class="hljs-number">56</span>]<br></code></pre></td></tr></table></figure><br/><h4 id="3-1-2-默认方法"><a href="#3-1-2-默认方法" class="headerlink" title="3.1.2 默认方法"></a>3.1.2 默认方法</h4><p>Predicate 接口中，还定义了 3 个默认方法。</p><p>在使用该接口来做判断的时候，经常需要几个条件同时成立，或者其中一个条件成立，或者求反。 在这种情况下，除了可以在代码中选择使用 &amp;&amp;，||，！之外，也可以分别使用这三个方法来代替。</p><br/><p><code>and()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>    Objects.requireNonNull(other);<br>    <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>例 3-2：选出数组中大于 10 且小于 50 的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      Integer[] arr = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">43</span>,<span class="hljs-number">123</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6</span>,<span class="hljs-number">56</span>,<span class="hljs-number">7</span>&#125;;<br>    <br>      <span class="hljs-comment">//条件1，数据大于10。</span><br>      Predicate&lt;Integer&gt; p1 = e -&gt; e&gt;<span class="hljs-number">10</span>;<br>    <br>      <span class="hljs-comment">//条件2，数据小于50。</span><br>      Predicate&lt;Integer&gt; p2 = e -&gt; e&lt;<span class="hljs-number">50</span>;<br>    <br>      <span class="hljs-comment">//两个条件同时成立。</span><br>      Predicate&lt;Integer&gt; p = p1.and(p2);<br>    <br>    <span class="hljs-comment">//filter 方法和 例 3-1 中的一样。</span><br>      arr = t.filter(arr,p);<br>      System.out.println(Arrays.toString(arr));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p><code>or()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; other)</span> </span>&#123;<br>    Objects.requireNonNull(other);<br>    <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>例 3-3：选出数组中小于 10 和大于 50 的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      Integer[] arr = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">43</span>,<span class="hljs-number">123</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6</span>,<span class="hljs-number">56</span>,<span class="hljs-number">7</span>&#125;;<br>    <br>      <span class="hljs-comment">//条件1，数据小于10</span><br>      Predicate&lt;Integer&gt; p1 = e -&gt; e&lt;<span class="hljs-number">10</span>;<br>    <br>      <span class="hljs-comment">//条件2，数据大于50</span><br>      Predicate&lt;Integer&gt; p2 = e -&gt; e&gt;<span class="hljs-number">50</span>;<br>    <br>      <span class="hljs-comment">//两个条件成立一个即可</span><br>      Predicate&lt;Integer&gt; p = p1.or(p2);<br>    <br>    <span class="hljs-comment">//filter 方法和 例 3-1 中的一样。</span><br>      arr = t.filter(arr,p);<br>      System.out.println(Arrays.toString(arr));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p><code>negate()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title">negate</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (t) -&gt; !test(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>例 3-4：选出数组中小于等于 10 的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      Integer[] arr = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">43</span>,<span class="hljs-number">123</span>,<span class="hljs-number">34</span>,<span class="hljs-number">6</span>,<span class="hljs-number">56</span>,<span class="hljs-number">7</span>&#125;;<br>    <br>      <span class="hljs-comment">//条件1，数据大于10</span><br>      Predicate&lt;Integer&gt; p1 = e -&gt; e&gt;<span class="hljs-number">10</span>;<br>    <br>      <span class="hljs-comment">//获取条件1相反的数据</span><br>      Predicate&lt;Integer&gt; p = p1.negate();<br>    <br>    <span class="hljs-comment">//filter 方法和 例 3-1 中的一样。</span><br>      arr = t.filter(arr,p);<br>      System.out.println(Arrays.toString(arr));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="3-1-3-静态方法"><a href="#3-1-3-静态方法" class="headerlink" title="3.1.3 静态方法"></a>3.1.3 静态方法</h4><p>Predicate 接口中，还定义了 2 个静态方法。</p><br/><p><code>isEqual()</code> 方法：判断两个参数是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">isEqual</span><span class="hljs-params">(Object targetRef)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">null</span> == targetRef)<br>      ? Objects::isNull<br>      : object -&gt; targetRef.equals(object);<br>&#125;<br></code></pre></td></tr></table></figure><br/><p><code>not()</code>方法：等同于 <code>negate</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Predicate&lt;T&gt; <span class="hljs-title">not</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; target)</span> </span>&#123;<br>    Objects.requireNonNull(target);<br>    <span class="hljs-keyword">return</span> (Predicate&lt;T&gt;)target.negate();<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="3-2-Consumer"><a href="#3-2-Consumer" class="headerlink" title="3.2 Consumer"></a>3.2 Consumer</h3><h4 id="3-2-1-抽象方法"><a href="#3-2-1-抽象方法" class="headerlink" title="3.2.1 抽象方法"></a>3.2.1 抽象方法</h4><p><code>java.util.function.Consumer</code> 接口定义了一个名叫 accept 的抽象方法，它接受泛型 T 对象，没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure><p>例 3-5 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Consumer&lt;String&gt; name = s -&gt; System.out.println(<span class="hljs-string">&quot;名字是&quot;</span> + s);<br>        name.accept(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为：</span><br>名字是 tom<br></code></pre></td></tr></table></figure><br/><h4 id="3-2-2-默认方法"><a href="#3-2-2-默认方法" class="headerlink" title="3.2.2 默认方法"></a>3.2.2 默认方法</h4><p>Consumer 接口中就只有一个默认方法。</p><p><code>andThen()</code>方法：有两个 Consumer 对象 c1 和 c2 。<code>c1.andThen(c2)</code>表示把 c1 调用 accept 方法返回的结果作为 c2 中 accept 方法的参数。</p><p>例 3-6：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AcceptTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>       <span class="hljs-comment">// 使用 andThen 方法合并。</span><br>        Consumer&lt;String&gt; name = s -&gt; System.out.println(<span class="hljs-string">&quot;名字是&quot;</span> + s);<br>        Consumer&lt;String&gt; age = s -&gt; System.out.println(<span class="hljs-string">&quot;年龄是20&quot;</span>);<br>        Consumer&lt;String&gt; stringConsumer = name.andThen(age);<br>        stringConsumer.accept(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>      <span class="hljs-comment">// 不使用 andThen 方法。</span><br>        Consumer&lt;String&gt; print = s -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;名字是&quot;</span>+s);<br>            System.out.println(<span class="hljs-string">&quot;年龄是20&quot;</span>);<br>        &#125;;<br>        print.accept(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 两段代码的结果一样。</span><br>名字是tom<br>年龄是<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><br/><h3 id="3-3-Function"><a href="#3-3-Function" class="headerlink" title="3.3 Function"></a>3.3 Function</h3><h4 id="3-3-1-抽象方法"><a href="#3-3-1-抽象方法" class="headerlink" title="3.3.1 抽象方法"></a>3.3.1 抽象方法</h4><p><code>java.util.function.Function</code> 接口定义了一个名叫 apply 的抽象方法，它接受泛型 T 对象，返回任意类型的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure><p>例 3-7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;a-b-c-d-e-f&quot;</span>;<br>        Function&lt;String, String[]&gt; f1 = s -&gt; s.split(<span class="hljs-string">&quot;-&quot;</span>);<br>        System.out.println(Arrays.toString(f1.apply(str)));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为：</span><br>[a, b, c, d, e, f]<br></code></pre></td></tr></table></figure><br/><h4 id="3-3-2-默认方法"><a href="#3-3-2-默认方法" class="headerlink" title="3.3.2 默认方法"></a>3.3.2 默认方法</h4><p><code>compose()</code>方法：有两个 Function 对象 f1 和 f2 。<code>f1.compose(f2)</code>表示把 f2 调用 apply 方法的结果作为 f1 中 apply 方法的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;V, R&gt; <span class="hljs-title">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;<br>    Objects.requireNonNull(before);<br>    <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>&#125;<br></code></pre></td></tr></table></figure><p>例 3-8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;a-b-c-d-e-f&quot;</span>;<br>        Function&lt;String, String[]&gt; f1 = s -&gt; s.split(<span class="hljs-string">&quot;-&quot;</span>);<br><br>        Function&lt;String, String&gt; f2 = s -&gt; &#123;<br>            s = <span class="hljs-string">&quot;h-i-j-k-l-m-n&quot;</span>;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;;<br>        Function&lt;String, String[]&gt; compose = f1.compose(f2);<br>        System.out.println(Arrays.toString(compose.apply(str)));<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为：</span><br>[h, i, j, k, l, m, n]<br></code></pre></td></tr></table></figure><br/><p><code>andThen()</code>方法：有两个 Function 对象 f1 和 f2 。<code>f1.andThen(f2)</code>表示把 f1 调用 apply 方法的结果作为 f2 中 apply 方法的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> &lt;V&gt; <span class="hljs-function">Function&lt;T, V&gt; <span class="hljs-title">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;<br>    Objects.requireNonNull(after);<br>    <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>&#125;<br></code></pre></td></tr></table></figure><p>例 3-9：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplyTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;a-b-c-d-e-f&quot;</span>;<br>        Function&lt;String, String[]&gt; f1 = s -&gt; s.split(<span class="hljs-string">&quot;-&quot;</span>);<br>        Function&lt;String[], List&lt;String&gt;&gt; f2 = Arrays::asList;<br>        Function&lt;String, List&lt;String&gt;&gt; stringListFunction = f1.andThen(f2);<br>        System.out.println(stringListFunction.apply(str));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为：</span><br>[a, b, c, d, e, f]<br></code></pre></td></tr></table></figure><br/><h4 id="3-3-3-静态方法"><a href="#3-3-3-静态方法" class="headerlink" title="3.3.3 静态方法"></a>3.3.3 静态方法</h4><p>只有一个静态方法。</p><p><code>identity()</code>方法：返回输入的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Function&lt;T, T&gt; <span class="hljs-title">identity</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> t -&gt; t;<br>&#125;<br></code></pre></td></tr></table></figure><p>例 3-10：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Function&lt;String,String&gt; f = Function.identity();<br>        <span class="hljs-comment">//传入hello，返回hello</span><br>        String result = f.apply(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(result);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为：</span><br>hello<br></code></pre></td></tr></table></figure><br/><h3 id="3-4-Supplier"><a href="#3-4-Supplier" class="headerlink" title="3.4  Supplier"></a>3.4  Supplier</h3><h4 id="3-4-1-抽象方法"><a href="#3-4-1-抽象方法" class="headerlink" title="3.4.1 抽象方法"></a>3.4.1 抽象方法</h4><p><code>java.util.function.Supplier</code> 接口定义了一个名叫 get 的抽象方法，它不接受参数，返回任意类型的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>例 3-11：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//生成1-100直接的随机的奇数</span><br>    Supplier&lt;Integer&gt; supplier = ()-&gt;&#123;<br>      <span class="hljs-keyword">int</span> num ;<br>      <span class="hljs-keyword">do</span> &#123;<br>        num = (<span class="hljs-keyword">int</span>) (Math.random()*<span class="hljs-number">100</span>+<span class="hljs-number">1</span>);<br>      &#125;<span class="hljs-keyword">while</span> ( (num &amp; <span class="hljs-number">1</span>)==<span class="hljs-number">0</span> );<br>      <span class="hljs-keyword">return</span> num;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      System.out.println(supplier.get());<br>    &#125;<br>    <br>  &#125;<br>&#125;<br><span class="hljs-comment">//结果w：</span><br><span class="hljs-number">79</span><br><span class="hljs-number">51</span><br><span class="hljs-number">69</span><br><span class="hljs-number">63</span><br><span class="hljs-number">31</span><br><span class="hljs-number">89</span><br><span class="hljs-number">81</span><br><span class="hljs-number">17</span><br><span class="hljs-number">97</span><br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><br/><h3 id="3-5-基本类型的函数式接口"><a href="#3-5-基本类型的函数式接口" class="headerlink" title="3.5 基本类型的函数式接口"></a>3.5 基本类型的函数式接口</h3><p>Predicate 、 Consumer ， Function ， Supplier 这些接口都是带泛型的接口。泛型的类型只能是引用类型，那么如果需要操作基本类型的数据，这时候就会做自动装箱和拆箱。 而大量的装箱和拆箱是比较消耗性能的，所以JDK1.8中，还专门定义了一些针对基本类型的函数式接。</p><p>默认情况下，这些专门对基本类型数据进行操作的函数式接口，它们的名字都有一定的规律前缀。比如： DoublePredicate 、 IntConsumer 、 LongBinaryOperator 、 IntFunction 等。 其中 Function 接口还有针对输出参数类型的变种: ToIntFunction 、 IntToDoubleFunction 等</p><p><img src="C:\Users\MaxSeal\AppData\Roaming\Typora\typora-user-images\image-20210705171456134.png" alt="image-20210705171456134"></p><br/><h2 id="4-Collection-和-Map-的增强"><a href="#4-Collection-和-Map-的增强" class="headerlink" title="4. Collection 和 Map 的增强"></a>4. Collection 和 Map 的增强</h2><ul><li>给 Collection 接口增加了默认方法： removeIf 方法；</li><li>给 Iterable 接口增加了 forEach 默认方法；</li><li>给 Map 接口增加了默认方法： computeIfAbsent 默认方法;</li></ul><h3 id="4-1-removeIf-方法"><a href="#4-1-removeIf-方法" class="headerlink" title="4.1 removeIf 方法"></a>4.1 removeIf 方法</h3><p> removeIf 方法使用了 Predicate 作为自己的参数，来移除符合条件的数据。源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> E&gt; filter)</span> </span>&#123;<br>      Objects.requireNonNull(filter);<br>      <span class="hljs-keyword">boolean</span> removed = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();<br>      <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>          each.remove();<br>          removed = <span class="hljs-keyword">true</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> removed;<br>&#125;<br></code></pre></td></tr></table></figure><p>例 4-1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>        col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        col.add(<span class="hljs-string">&quot;world&quot;</span>);<br>        col.removeIf((str)-&gt;str.contains(<span class="hljs-string">&quot;o&quot;</span>));<br>        System.out.println(col);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>[abc]<br></code></pre></td></tr></table></figure><br/><h3 id="4-2-forEach-方法"><a href="#4-2-forEach-方法" class="headerlink" title="4.2 forEach 方法"></a>4.2 forEach 方法</h3><p> forEach 方法使用了 Consumer 作为自己的参数，来遍历集合。源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; action)</span> </span>&#123;<br>    Objects.requireNonNull(action);<br>    <span class="hljs-keyword">for</span> (T t : <span class="hljs-keyword">this</span>) &#123;<br>      action.accept(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例 4-2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      Collection&lt;String&gt; col = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>      col.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>      col.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>      col.add(<span class="hljs-string">&quot;world&quot;</span>);<br>      <span class="hljs-comment">//去掉中间变量，直接把Lambda表达式当前参数传入到forEach方法中</span><br>      col.forEach((t)-&gt;System.out.println(t));<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>abc<br>hello<br>world<br></code></pre></td></tr></table></figure><BR/><h3 id="4-3-computeIfAbsent-方法"><a href="#4-3-computeIfAbsent-方法" class="headerlink" title="4.3  computeIfAbsent 方法"></a>4.3  computeIfAbsent 方法</h3><p> computeIfAbsent 方法用来在指定 key 不存在时，计算一个 value 值和指定 key 匹配，并将该 key=value  写入map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> V <span class="hljs-title">computeIfAbsent</span><span class="hljs-params">(K key, Function&lt;? <span class="hljs-keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;<br>    Objects.requireNonNull(mappingFunction);<br>    V v;<br>    <span class="hljs-keyword">if</span> ((v = get(key)) == <span class="hljs-keyword">null</span>) &#123;<br>      V newValue;<br>      <span class="hljs-keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="hljs-keyword">null</span>) &#123;<br>        put(key, newValue);<br>        <span class="hljs-keyword">return</span> newValue;<br>      &#125;<br>    &#125;<br>  <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>例 4-3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;mary&quot;</span>);<br>    Function&lt;String,String&gt; f = key-&gt;<span class="hljs-string">&quot;default&quot;</span>;<br>    <br>    <span class="hljs-comment">//如果key为3的时候，对应的值不存在</span><br>    <span class="hljs-comment">//那么使用f函数计算出一个value，并当前这个key-value存入到map集合中</span><br>    map.computeIfAbsent(<span class="hljs-string">&quot;3&quot;</span>,f);<br>    <br>    <span class="hljs-comment">//也可以去掉中间变量f，直接将Lambda表达式传入</span><br>    <span class="hljs-comment">//map.computeIfAbsent(&quot;3&quot;,key-&gt;&quot;default&quot;);</span><br>    map.forEach((k,v)-&gt; System.out.println(k+<span class="hljs-string">&quot;-&quot;</span>+v));<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-number">1</span>-tom<br><span class="hljs-number">2</span>-mary<br><span class="hljs-number">3</span>-<span class="hljs-keyword">default</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程（二）网络编程</title>
    <link href="/2021/06/30/CoreJava/32.%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/06/30/CoreJava/32.%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>TCP 和 UDP 网络编程。</p><h2 id="1-TCP-网络编程"><a href="#1-TCP-网络编程" class="headerlink" title="1. TCP 网络编程"></a>1. TCP 网络编程</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p>在 TCP 通信协议下，能实现两台计算机之间的数据交互，并且它们要严格区分客户端（Client）与服务端 （Server）。</p><br/><p>客户端和服务端通信的步骤：</p><ul><li>服务端先进行启动，并占用一个指定的端口号，等待客户端的连接。</li><li>客户端主动发起服务端的连接，在连接成功之后，就可以进行数据发送了。</li></ul><p>在整个过程中，服务端不能主动连接客户端，必须由客户端先行发起连接才行。</p><br/><p>在 java 中，对于这样基于 TCP 协议下连接通信的客户端和服务端，分别进行了抽象：</p><ul><li><code>java.net.Socket</code> 类表示客户端。</li><li><code>java.net.ServerSocket</code> 类表示服务端。</li></ul><p>使用 Socket 和 ServerSocket 进行的编程，也称为套接字编程。</p><br/><h3 id="1-2-Socket-类"><a href="#1-2-Socket-类" class="headerlink" title="1.2 Socket 类"></a>1.2 Socket 类</h3><h3 id="1-3-ServerSocket-类"><a href="#1-3-ServerSocket-类" class="headerlink" title="1.3 ServerSocket 类"></a>1.3 ServerSocket 类</h3><h3 id="1-4-使用"><a href="#1-4-使用" class="headerlink" title="1.4 使用"></a>1.4 使用</h3>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程（一）基本概念</title>
    <link href="/2021/06/30/CoreJava/31.%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/06/30/CoreJava/31.%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>一些计算机网络的基础知识。</p><h2 id="1-软件结构"><a href="#1-软件结构" class="headerlink" title="1. 软件结构"></a>1. 软件结构</h2><p>常见的软件结构有 C/S 和 B/S：</p><ul><li>Client / Server：表示客户端 / 服务器的软件结构。例如 QQ、微信、网盘客户端等，只要是需要我们下载安装，并且和服务器通信的这一类软件，都属于 C/S 的软件结构。</li><li>Browser / Server：表示浏览器 / 服务器的软件结构。例如淘宝网、京东商城等，只要是需要使用浏览器，并且和服务器通信的这一类软件，都属于 B/S 的软件结构。</li></ul><br/><p>C/S 和 B/S 的优缺点：</p><ul><li>C/S 在图形的表现能力上以及运行的速度上强于 B/S。</li><li>C/S 需要运行专门的客户端，并且它不能跨平台。</li><li>B/S 不需要专门的客户端，只要系统中安装了浏览器即可访问，方便用户的使用。</li><li>B/S 是基于网页语言的、与操作系统无关，所以跨平台也是它的优势。</li><li>随着网页技术以及浏览器的进步，B/S 在表现能力上的处理以及运行的速度上会越来越快，所以现在越来越多的 C/S 结构的软件，也推出了对应 B/S 的版本。</li></ul><p><strong>无论是 C/S 结构的软件，还是 B/S 结构的软件，都离不开网络的支持。</strong> </p><br/><h2 id="2-通信协议"><a href="#2-通信协议" class="headerlink" title="2. 通信协议"></a>2. 通信协议</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>通信协议是指双方实体完成通信或服务所必须遵循的规则和约定。通过通信信道和设备互连起来的多个不同地理位置的数据通信系统，要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。</p><p>通信协议，对俩台计算机之间所传输数据的传输格式、传输步骤等做了统一规定要求，通信双方必须同时遵守才能完成数据交换。</p><br/><h3 id="2-2-TCP-IP-协议栈"><a href="#2-2-TCP-IP-协议栈" class="headerlink" title="2.2 TCP / IP 协议栈"></a>2.2 TCP / IP 协议栈</h3><p>传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)：</p><ul><li>它是一系列网络协议的总和，是构成网络通信的核心骨架。</li><li>它是互联网中最基本、使用最广泛的协议。</li><li>它定义了计算机如何连入因特网，以及数据如何在计算机之间进行传输。</li></ul><br/><h3 id="2-3-TCP-IP-协议栈-4-层结构"><a href="#2-3-TCP-IP-协议栈-4-层结构" class="headerlink" title="2.3 TCP / IP  协议栈 4 层结构"></a>2.3 TCP / IP  协议栈 4 层结构</h3><p>TCP/IP 协议栈采用 4 层结构，分别是应用层、传输层、网络层、链路层，并且在每一层的内部，都包含了一系列用于处理数据通信的协议，分别负责不同的通信功能。</p><ul><li>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。 </li><li>网络层：网络层是整个 TCP/IP 协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。 </li><li>传输层：主要使网络程序进行通信，在进行网络通信时，可以采用 TCP 协议，也可以采用UDP协议。 </li><li>应用层：主要负责应用程序的协议，例如 HTTP 协议、FTP 协议等。</li></ul><br/><p>当通过 http 发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包 装并携带对应的首部，最终在链路层生成以太网数据包，以太网数据包通过物理介质传输给对方主机。 对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。如图：</p><img src="C:\Users\MaxSeal\AppData\Roaming\Typora\typora-user-images\image-20210630095732027.png" alt="image-20210630095732027" style="zoom: 50%;" /><br/><h2 id="3-TCP-和-UDP"><a href="#3-TCP-和-UDP" class="headerlink" title="3. TCP 和 UDP"></a>3. TCP 和 UDP</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h3><p>虽然完整的通信过程比较复杂，但是JavaAPI中把这些通信实现的细节进行了封装，使得我们可以直接使 用相应的类和接口，来进行网络程序开发，而不用考虑通信的细节。</p><br/><p>java.net 包中对常见的俩种通信协议进行了封装和支持：UDP 和 TCP。</p><p>UDP 用户数据报协议(User Datagram Protocol) :</p><ul><li>UDP 是无连接通信协议，在数据传输时，数据的发送端和接收端不建立连接，也不能保证对方能接收成功。 例如，当一台计算机向另外一台计算机发送数据时（UDP），发送端不会确认接收端是否存在，就 会直接发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</li><li>由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 但是在传输重要数据时，不建议使用 UDP 协议，因为它不能保证数据传输的完整性。</li></ul><br/><p>TCP 传输控制协议 (Transmission Control Protocol) ：</p><ul><li>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立连接，然后再传输数 据，它提供了两台计算机之间可靠的、无差错的数据传输。 </li><li>在TCP连接中，将计算机明确划分为客户端与服务器端，并且由客户端向服务端发出连接请求，每次连接的创建都需要经过 “三次握手” 的过程。</li></ul><br/><h3 id="3-2-TCP-三次握手"><a href="#3-2-TCP-三次握手" class="headerlink" title="3.2 TCP 三次握手"></a>3.2 TCP 三次握手</h3><p>TCP的三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p><ul><li>第一次握手：客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手：服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手：客户端再次向服务器端发送确认信息，确认连接。</li></ul><p>完成上述的三次握手后，客户端和服务器端的连接就已经建立了，在这个安全的、可靠的连接基础之上，就可以开始进行数据传输了。</p><h2 id="4-IP-和端口号"><a href="#4-IP-和端口号" class="headerlink" title="4. IP 和端口号"></a>4. IP 和端口号</h2><p>在网络中，通过IP可以找到对应的主机设备，而通过端口号，可以找到这个主机中正在运行的一个应用程序。</p><h3 id="4-1-IP"><a href="#4-1-IP" class="headerlink" title="4.1 IP"></a>4.1 IP</h3><p>IP地址：即互联网协议地址（Internet Protocol Address）。IP地址用来给一个网络中的计算机设备做唯一的编号。</p><h3 id="4-2-端口号"><a href="#4-2-端口号" class="headerlink" title="4.2 端口号"></a>4.2 端口号</h3><p>端口号：网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，每个需要网络通信的进程（应用程序），都会占用系统的一个端口号。</p><p>端口号的取值范围是 0 ~ 65535。其中 0 ~ 1023 之间的端口号用于系统内部的使用，我们自己普通的应用程序要使用1024以上的端口号即可，同时也要避免和一些知名应用程序默认的端口冲突。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO 流（五）其他流</title>
    <link href="/2021/06/30/CoreJava/30.%20IO%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%B6%E4%BB%96%E6%B5%81/"/>
    <url>/2021/06/30/CoreJava/30.%20IO%E6%B5%81%EF%BC%88%E4%BA%94%EF%BC%89%E5%85%B6%E4%BB%96%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>一些其他常用的流。</p><h2 id="1-数据流"><a href="#1-数据流" class="headerlink" title="1. 数据流"></a>1. 数据流</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>字节流操作数据的时候，以字节为单位，一个个的进行读写，很多时候这样并不方便。 我们希望读出来的若干个字节，自动转换为指定类型的数据，例如 int、float、char 等。 类似的，我们也希望每次能直接把一个数据，自动转成字节再写出去。 例如，把一个long类型数据，写入到一个字节数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// long 是 64 位，8个字节，在内存中表示为</span><br><span class="hljs-comment">// 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</span><br><span class="hljs-comment">// 写入字节数组后，具体的值应该如下：</span><br><span class="hljs-keyword">byte</span>[] arr = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br></code></pre></td></tr></table></figure><br/><h3 id="1-2-DataOutputStream"><a href="#1-2-DataOutputStream" class="headerlink" title="1.2 DataOutputStream"></a>1.2 DataOutputStream</h3><p><code>java.io.DataOutputStream</code> 可以将指定类型的数据转换为字节，并写出去，其代码结构大致为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataOutputStream</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span> writeBuffer[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">8</span>];<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataOutputStream</span><span class="hljs-params">(OutputStream out)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(out);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBoolean</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> v)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeShort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeChar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeLong</span><span class="hljs-params">(<span class="hljs-keyword">long</span> v)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    writeBuffer[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">byte</span>)(v &gt;&gt;&gt; <span class="hljs-number">56</span>);<br>    writeBuffer[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">byte</span>)(v &gt;&gt;&gt; <span class="hljs-number">48</span>);<br>    writeBuffer[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>)(v &gt;&gt;&gt; <span class="hljs-number">40</span>);<br>    writeBuffer[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">byte</span>)(v &gt;&gt;&gt; <span class="hljs-number">32</span>);<br>    writeBuffer[<span class="hljs-number">4</span>] = (<span class="hljs-keyword">byte</span>)(v &gt;&gt;&gt; <span class="hljs-number">24</span>);<br>    writeBuffer[<span class="hljs-number">5</span>] = (<span class="hljs-keyword">byte</span>)(v &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    writeBuffer[<span class="hljs-number">6</span>] = (<span class="hljs-keyword">byte</span>)(v &gt;&gt;&gt; <span class="hljs-number">8</span>);<br>    writeBuffer[<span class="hljs-number">7</span>] = (<span class="hljs-keyword">byte</span>)(v &gt;&gt;&gt; <span class="hljs-number">0</span>);<br>    out.write(writeBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeFloat</span><span class="hljs-params">(<span class="hljs-keyword">float</span> v)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeDouble</span><span class="hljs-params">(<span class="hljs-keyword">double</span> v)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeUTF</span><span class="hljs-params">(String str)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DataOutputStream 必须要 “包裹” 一个字节流，增强这个字节流的功能，一次可以写出去一个 具体类型的数据。</p><p>通过 writeLong 方法可以看出，内部是通过移位操作，拿到每一个字节的值，放到数组中，再 写出去。</p><br/><p>例：将1000L写入到一个字节数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//1.声明流</span><br>    DataOutputStream out = <span class="hljs-keyword">null</span><br>      ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//2.创建流</span><br>      byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>      <span class="hljs-comment">//“包裹”字节数组输出流，增强它的功能，可以一次写到数组中一个指定类型的数据</span><br>      out = <span class="hljs-keyword">new</span> DataOutputStream(byteArrayOutputStream);<br>      <span class="hljs-comment">//3.使用流</span><br>      out.writeLong(<span class="hljs-number">1000L</span>);<br>      out.flush();<br>      <span class="hljs-comment">//将写入的数据转为字节数组并返回</span><br>      <span class="hljs-keyword">byte</span>[] toByteArray = byteArrayOutputStream.toByteArray();<br>      System.out.println(Arrays.toString(toByteArray));<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//4.关闭流</span><br>      <span class="hljs-keyword">if</span>(byteArrayOutputStream!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          byteArrayOutputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(out!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          out.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">24</span>]<br></code></pre></td></tr></table></figure><br/><h3 id="1-3-DataOutputStream"><a href="#1-3-DataOutputStream" class="headerlink" title="1.3 DataOutputStream"></a>1.3 DataOutputStream</h3><p>与 DataOutputStream 功能类似，DataInputStream 可以将读取到的字节自动转化为指定类型的数据，但一般都需要和 DataOutputStream 配合使用。 </p><p>DataOutputStream 负责把指定类型的数据，转化为字节并写出去。 DataInputStream 负责把读取到的若干个字节，转化为指定类型的数据。</p><p>例：先使用 DataOutputStream 将数据写入到文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//1.声明流</span><br>  DataOutputStream out = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//2.创建流</span><br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/a.txt&quot;</span>);<br>    <span class="hljs-comment">//“包裹”文件字节输出流，增强数据写出功能</span><br>    out = <span class="hljs-keyword">new</span> DataOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(file));<br>    <span class="hljs-comment">//3.使用流</span><br>    out.writeLong(<span class="hljs-number">1000L</span>);<br>    out.writeInt(<span class="hljs-number">5</span>);<br>    out.writeDouble(<span class="hljs-number">10.5D</span>);<br>    out.writeChar(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    out.writeUTF(<span class="hljs-string">&quot;hello，中国&quot;</span>);<br>    out.flush();<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>  &#125;<span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//4.关闭流</span><br>    <span class="hljs-keyword">if</span>(out!=<span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        out.close();<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>例：再使用 DataInputStream 将数据从文件中读出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//1.声明流</span><br>  DataInputStream in = <span class="hljs-keyword">null</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//2.创建流</span><br>      File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/a.txt&quot;</span>);<br>      <span class="hljs-comment">//“包裹”文件字节输入流，增强读取数据功能</span><br>      in = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));<br>      <span class="hljs-comment">//3.使用流</span><br>      <span class="hljs-comment">//注意，数据读出来的顺序要，和之前写进去的顺序一致</span><br>      System.out.println(in.readLong());<br>      System.out.println(in.readInt());<br>      System.out.println(in.readDouble());<br>      System.out.println(in.readChar());<br>      System.out.println(in.readUTF());<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//4.关闭流</span><br>      <span class="hljs-keyword">if</span>(in!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>数据读出来的顺序要，和之前写进去的顺序一致。</p><br/><h2 id="2-缓冲流"><a href="#2-缓冲流" class="headerlink" title="2. 缓冲流"></a>2. 缓冲流</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>缓冲流可以在创建流对象时，设置一个默认大小的缓冲区数组，通过缓冲区进行读写，减少系统磁盘 的IO次数，从而提高读写的效率。</p><br/><h3 id="2-2-字节缓冲流"><a href="#2-2-字节缓冲流" class="headerlink" title="2.2 字节缓冲流"></a>2.2 字节缓冲流</h3><h4 id="2-2-1-BufferedInputStream"><a href="#2-2-1-BufferedInputStream" class="headerlink" title="2.2.1 BufferedInputStream"></a>2.2.1 BufferedInputStream</h4><p><code>java.io.BufferedInputStream</code> 负责给字节输入流提供缓冲功能。</p><p>BufferedInputStream 的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 BufferedInputStream 对象，缓冲区的大小默认为 8192</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(in, DEFAULT_BUFFER_SIZE);<br>&#125;<br><br><br><span class="hljs-comment">// 创建 BufferedInputStream 对象，并指定缓冲区的大小</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>  <span class="hljs-keyword">super</span>(in);<br>  <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>  &#125;<br>  buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[size];<br>&#125;<br></code></pre></td></tr></table></figure><p>字节缓冲流的构造器，要求一定要传入一个字节流对象，然后缓冲流就可以对这个字节流的功能进行增强，提供缓冲数据的功能，从而提高读写的效率。</p><br/><h4 id="2-2-2-BufferedOutputStream"><a href="#2-2-2-BufferedOutputStream" class="headerlink" title="2.2.2 BufferedOutputStream"></a>2.2.2 BufferedOutputStream</h4><p><code>java.io.BufferedOutputStream</code> 负责给字节输出流提供缓冲功能。</p><p>BufferedOutputStream 的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 BufferedOutputStream 对象，缓冲区的大小默认为 8192</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedOutputStream</span><span class="hljs-params">(OutputStream out)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(out, <span class="hljs-number">8192</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建 BufferedOutputStream 对象，并指定缓冲区的大小</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedOutputStream</span><span class="hljs-params">(OutputStream out, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>  <span class="hljs-keyword">super</span>(out);<br>  <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>  &#125;<br>  buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[size];<br>&#125;<br></code></pre></td></tr></table></figure><p>字节缓冲流的构造器，要求一定要传入一个字节流对象，然后缓冲流就可以对这个字节流的功能进行增强，提供缓冲数据的功能，从而提高读写的效率。</p><br/><h4 id="2-2-3-使用"><a href="#2-2-3-使用" class="headerlink" title="2.2.3 使用"></a>2.2.3 使用</h4><p>例：使用缓冲流来增强文件字节流的功能，提高读写效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>   <span class="hljs-comment">//1.声明流</span><br>    InputStream in = <span class="hljs-keyword">null</span>;<br>    OutputStream out = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//2.创建流</span><br>      File file1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/背影.txt&quot;</span>);<br>      File file2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/背影copy.txt&quot;</span>);<br><br>      <span class="hljs-comment">//使用缓冲流增强文件字节流的功能，提供读写效率</span><br>      <span class="hljs-comment">//使用缓存流“包裹”其他的字节流即可</span><br>      in = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(file1));<br>      out = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(file2));<br>      <span class="hljs-comment">//3.使用流</span><br>      <span class="hljs-keyword">int</span> data = -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>      <span class="hljs-keyword">while</span>((data=in.read())!=-<span class="hljs-number">1</span>)&#123;<br>        out.write(data);<br>      &#125;<br>      out.flush();<br>      <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>      System.out.println(<span class="hljs-string">&quot;使用缓冲流完成读写操作的时间为：&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//4.关闭流</span><br>      <span class="hljs-keyword">if</span>(in!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(out!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          out.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：每次运行结果稍有差异</span><br>使用字符流完成读写操作的时间为：<span class="hljs-number">30</span>毫秒<br></code></pre></td></tr></table></figure><br/><h3 id="2-3-字符缓冲流"><a href="#2-3-字符缓冲流" class="headerlink" title="2.3 字符缓冲流"></a>2.3 字符缓冲流</h3><h4 id="2-3-1-BufferedReader"><a href="#2-3-1-BufferedReader" class="headerlink" title="2.3.1 BufferedReader"></a>2.3.1 BufferedReader</h4><p><code>java.io.BufferedReader</code> 负责给字符输入流提供缓冲功能。</p><p>BufferedReader 的构造器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reader</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> cb[];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> defaultCharBufferSize = <span class="hljs-number">8192</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedReader</span><span class="hljs-params">(Reader in, <span class="hljs-keyword">int</span> sz)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(in);<br>    <span class="hljs-keyword">if</span> (sz &lt;= <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>    <span class="hljs-keyword">this</span>.in = in;<br>    cb = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[sz];<br>    nextChar = nChars = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedReader</span><span class="hljs-params">(Reader in)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(in, defaultCharBufferSize);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符缓冲流的构造器，要求一定要传入一个字符流对象，然后缓冲流就可以对这个字符 流的功能进行增强，提供缓冲数据的功能，从而提高读写的效率。</p><br/><p>常用方法： <code>public String readLine() </code> 一次读一行。</p><ul><li>如果下一行是空行， readLine 方法返回空字符串，也就是 String line = “” </li><li>如果没有下一行数据了， readLine 方法返回 null</li></ul><h4 id="2-3-2-BufferedWtiter"><a href="#2-3-2-BufferedWtiter" class="headerlink" title="2.3.2 BufferedWtiter"></a>2.3.2 BufferedWtiter</h4><p><code>java.io.BufferedWriter</code> ，负责给字符输出流提供缓冲功能。</p><p>BufferedWriter 构造器代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedWriter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writer</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> cb[];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> defaultCharBufferSize = <span class="hljs-number">8192</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedWriter</span><span class="hljs-params">(Writer out)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(out, defaultCharBufferSize);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedWriter</span><span class="hljs-params">(Writer out, <span class="hljs-keyword">int</span> sz)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(out);<br>    <span class="hljs-keyword">if</span> (sz &lt;= <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Buffer size &lt;= 0&quot;</span>);<br>    <span class="hljs-keyword">this</span>.out = out;<br>    cb = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[sz];<br>    nChars = sz;<br>    nextChar = <span class="hljs-number">0</span>;<br>    lineSeparator = java.security.AccessController.doPrivileged(<br>      <span class="hljs-keyword">new</span> sun.security.action.GetPropertyAction(<span class="hljs-string">&quot;line.separator&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符缓冲流的构造器，要求一定要传入一个字符流对象，然后缓冲流就可以对这个字符 流的功能进行增强，提供缓冲数据的功能，从而提高读写的效率。</p><h3 id="2-4-使用"><a href="#2-4-使用" class="headerlink" title="2.4 使用"></a>2.4 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//1.声明流</span><br>    Reader in = <span class="hljs-keyword">null</span>;<br>    Writer out = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//2.创建流</span><br>      File file1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/背影.txt&quot;</span>);<br>      File file2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/背影copy.txt&quot;</span>);<br>      <span class="hljs-comment">// in = new FileReader(file1);</span><br>      <span class="hljs-comment">// out = new FileWriter(file2);</span><br>      <span class="hljs-comment">//使用缓冲流增强文件字符流的功能，提高读写效率</span><br>      in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(file1));<br>      out = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(file2));<br>      <span class="hljs-comment">//3.使用流</span><br>      <span class="hljs-keyword">int</span> data = -<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>      <span class="hljs-keyword">while</span>((data=in.read())!=-<span class="hljs-number">1</span>)&#123;<br>        out.write(data);<br>      &#125;<br>      out.flush();<br>      <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>      System.out.println(<span class="hljs-string">&quot;使用字符流完成读写操作的时间为：&quot;</span>+(end-start)+<span class="hljs-string">&quot;毫秒&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//4.关闭流</span><br>      <span class="hljs-keyword">if</span>(in!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(out!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          out.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h2 id="3-转换流"><a href="#3-转换流" class="headerlink" title="3. 转换流"></a>3. 转换流</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>转换流，可以在把一个字节流转换为字符的同时，并指定转换的字符编码。</p><br/><h3 id="3-2-OutputStreamWriter"><a href="#3-2-OutputStreamWriter" class="headerlink" title="3.2  OutputStreamWriter"></a>3.2  OutputStreamWriter</h3><p><code>java.io.OutputStreamWriter</code> 可以将字节输出流转换为字符输出流，并指定编码。</p><p>OutputStreamWriter 本身就是一个字符输出流，它继承了 Writer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OutputStreamWriter</span><span class="hljs-params">(OutputStream in)</span> </span>&#123;<br><span class="hljs-comment">//使用默认编码转换</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OutputStreamWriter</span><span class="hljs-params">(OutputStream in, String charsetName)</span></span>&#123;<br><span class="hljs-comment">//使用指定编码转换</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//1.声明流</span><br>  PrintWriter out = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-comment">//转换流，同时也是一个字符流</span><br>  OutputStreamWriter outputStreamWriter = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//2.创建流</span><br>    <span class="hljs-comment">//创建文件对象</span><br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/a.txt&quot;</span>);<br>    <span class="hljs-comment">//将字节流转换为字符流</span><br>    outputStreamWriter = <span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(file),<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    <span class="hljs-comment">//“包裹”转换流，增强这个字符流的功能，可以一次写出一行字符串，并自动换行</span><br>    <span class="hljs-comment">//注意，转换流同时也是一个字符流</span><br>    out = <span class="hljs-keyword">new</span> PrintWriter(outputStreamWriter);<br>    <span class="hljs-comment">//3.使用流</span><br>    out.println(<span class="hljs-string">&quot;你好，程序员&quot;</span>);<br>    out.flush();<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>  &#125;<span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//4.关闭流</span><br>    <span class="hljs-keyword">if</span>(outputStreamWriter!=<span class="hljs-keyword">null</span>)&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        outputStreamWriter.close();<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(out!=<span class="hljs-keyword">null</span>) &#123;<br>      out.close();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><br/><h3 id="3-3-InputStreamReader"><a href="#3-3-InputStreamReader" class="headerlink" title="3.3 InputStreamReader"></a>3.3 InputStreamReader</h3><p><code>java.io.InputStreamReader</code> 可以将字节输入流转换为字符输入流，并指定编码。</p><p> InputStreamReader 本身就是一个字符输出流，它继承了 Reader。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputStreamReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Reader</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputStreamReader</span><span class="hljs-params">(InputStream in)</span> </span>&#123;<br>    <span class="hljs-comment">//使用默认编码转换</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputStreamReader</span><span class="hljs-params">(InputStream in, String charsetName)</span></span>&#123;<br>    <span class="hljs-comment">//使用指定编码转换</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//1.声明流</span><br>  BufferedReader in = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-comment">//转换流，同时也是一个字符流</span><br>  InputStreamReader inputStreamReader = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//2.创建流</span><br>    <span class="hljs-comment">//创建文件对象</span><br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/a.txt&quot;</span>);<br>    <span class="hljs-comment">//将字节流转换为字符流</span><br>    inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(file),<span class="hljs-string">&quot;UTF8&quot;</span>);<br>    <span class="hljs-comment">//“包裹”转换流，增强这个字符流的功能，可以一次读出一行字符串数据</span><br>    <span class="hljs-comment">//注意，转换流同时也是一个字符流</span><br>    in = <span class="hljs-keyword">new</span> BufferedReader(inputStreamReader);<br>    <span class="hljs-comment">//3.使用流</span><br>    String line = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span>((line=in.readLine())!=<span class="hljs-keyword">null</span>)&#123;<br>      System.out.println(line);<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>  &#125;<span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//4.关闭流</span><br>    <span class="hljs-keyword">if</span>(inputStreamReader!=<span class="hljs-keyword">null</span>)&#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        inputStreamReader.close();<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(in!=<span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        in.close();<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="4-对象流"><a href="#4-对象流" class="headerlink" title="4.  对象流"></a>4.  对象流</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>Java 提供了一种对象序列化的机制，可以将对象和字节序列之间进行转换： </p><ul><li>序列化：程序中，可以用一个字节序列来表示一个对象，该字节序列包含了对象的类型、对象中的数据等。 如果这个字节序列写出到文件中，就相当于在文件中持久保存了这个对象的信息。</li><li>反序列化：相反的过程，从文件中将这个字节序列读取回来，在内存中重新生成这个对象，对象的类型、对象中的数据等，都和之前的那个对象保持一致。（注意，这时候的对象和之前的对象，内存地址可能是不同的）</li></ul><br/><h3 id="4-2-Serializable"><a href="#4-2-Serializable" class="headerlink" title="4.2 Serializable"></a>4.2 Serializable</h3><p>在 java 中，并非所有对象都可以进行序列化和反序列化，而是只有实现了 Serializable 接口的对象才可以进行。</p><p>Serializable 接口中没有抽象方法，这只是一个 “标识” 接口，实现它的的对象才可以进行序列化和反序列化操作。</p><br/><h3 id="4-3-ObjectOutputStream"><a href="#4-3-ObjectOutputStream" class="headerlink" title="4.3 ObjectOutputStream"></a>4.3 ObjectOutputStream</h3><p><code>java.io.ObjectOutputStream</code> 将 Java 对象转换为字节序列，并输出到内存、文件、网络等地方 注意，具体输出到什么地方，要看 ObjectOutputStream “包裹”的是哪一个节点流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectOutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OutputStream</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObjectOutputStream</span><span class="hljs-params">(OutputStream out)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>  <span class="hljs-comment">//序列化方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//1.声明流</span><br>  ObjectOutputStream out = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//2.创建流</span><br>    <span class="hljs-comment">//创建文件对象</span><br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/a.txt&quot;</span>);<br>    <span class="hljs-comment">//&quot;包裹&quot;一个文件字节输出流</span><br>    out = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(file));<br>    <span class="hljs-comment">//3.使用流</span><br>    Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//序列化：对象-&gt;字节</span><br>    out.writeObject(stu);<br>    out.flush();<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>  &#125;<span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//4.关闭流</span><br>    <span class="hljs-keyword">if</span>(out!=<span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        out.close();<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-4-ObjectInputStream"><a href="#4-4-ObjectInputStream" class="headerlink" title="4.4 ObjectInputStream"></a>4.4 ObjectInputStream</h3><p><code>java.io.ObjectInputStream</code>从某一个地方读取出对象的字节序列，并生成对应的对象。 注意，具体是从输什么地方读取字节，要看 ObjectInputStream “包裹”的是哪一个节点流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectInputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStream</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ObjectInputStream</span><span class="hljs-params">(InputStream in)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//..</span><br>  &#125;<br>  <span class="hljs-comment">//反序列化方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">readObject</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> IOException, ClassNotFoundException</span>&#123;<br>    <span class="hljs-comment">//</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//1.声明流</span><br>  ObjectInputStream in = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//2.创建流</span><br>    <span class="hljs-comment">//创建文件对象</span><br>    File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;src/main/java/com/briup/demo/a.txt&quot;</span>);<br>    <span class="hljs-comment">//&quot;包裹&quot;一个文件字节输出流</span><br>    in = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(file));<br>    <span class="hljs-comment">//3.使用流</span><br>    Object obj = in.readObject();<br>    <span class="hljs-comment">//反序列化：字节-&gt;对象</span><br>    System.out.println(obj);<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>  &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>    e.printStackTrace();<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">//4.关闭流</span><br>    <span class="hljs-keyword">if</span>(in!=<span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        in.close();<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-5-transient"><a href="#4-5-transient" class="headerlink" title="4.5 transient"></a>4.5 transient</h3><p>java中的关键字 transient ，可以修饰类中的属性，它是让对象在进行序列化的时候，忽略掉指定的属性。</p><p>常用在一些敏感属性的修饰，例如对象中的password属性，我们并不想将这个敏感属性的值进行序列化 保存，那么就可以使用 transient 来对他进行修饰。</p><p>transient 的单词含义就是短暂的、转瞬即逝。</p><br/><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> age;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时候，再进行序列化操作，对象中的 age 属性的值将会被忽略掉。</p><br/><h3 id="4-6-序列化版本号"><a href="#4-6-序列化版本号" class="headerlink" title="4.6 序列化版本号"></a>4.6 序列化版本号</h3><p>Serializable 接口给需要序列化的类，提供了一个序列版本号：serialVersionUID。该版本号的目的，是用于验证序列化的对象和对应类是否版本匹配。</p><p>默认情况下，每次修改代码编译生成的新的 class 文件中，都会根据当前类的信息计算出一个序列 化版本号，之前序列化的字节中的保存的是之前老的版本号，和现在这个新的不一致，然后就报错了。</p><p>如果我们手动指定这个版本号之后，那么这个类的序列化版本号就固定下来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>  <span class="hljs-comment">//属性的名字、类型、修饰符是固定的，值可以随意给一个</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>  String name;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="5-随机访问流"><a href="#5-随机访问流" class="headerlink" title="5. 随机访问流"></a>5. 随机访问流</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p><code>java.io.RandomAccessFile</code> 是JavaAPI中提供的对文件进行随机访问的流。</p><p>之前使用的每一个流，那么是读数据的，要么是写数据的，而这个随机访问流，它的对象即可用作文件内容的读，又可以用作文件内容的写，同时它还可以任意定位到文件的某一个文件进行读或者写操作。 </p><p>创建该类的对象时，需要指定要操作的文件和操作的模式：</p><ul><li>“r” 模式，以只读方式来打开指定文件夹。如果试图对该RandomAccessFile执行写入方法，都将抛出 IOException异常。 </li><li>“rw” 模式，以读写方式打开指定文件。如果该文件尚不存在，则试图创建该文件。</li><li> “rws” 模式，以读写方式打开指定文件。相对于”rw” 模式，还要求对文件内容或元数据的每个更新 都同步写入到底层设备。</li><li> “rwd” 默认，以读写方式打开指定文件。相对于”rw” 模式，还要求对文件内容每个更新都同步写入 到底层设备。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO 流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO 流（四）文件</title>
    <link href="/2021/06/30/CoreJava/29.%20IO%E6%B5%81%EF%BC%88%E5%9B%9B%EF%BC%89%E6%96%87%E4%BB%B6/"/>
    <url>/2021/06/30/CoreJava/29.%20IO%E6%B5%81%EF%BC%88%E5%9B%9B%EF%BC%89%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>File 类和常见的读写文件的方式。</p><span id="more"></span><h2 id="1-File-类"><a href="#1-File-类" class="headerlink" title="1. File 类"></a>1. File 类</h2><p><code>java.io.File </code>类，是 java 中对文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h3 id="1-1-构造器"><a href="#1-1-构造器" class="headerlink" title="1.1 构造器"></a>1.1 构造器</h3><p>File 既可以表示一个文件，也可以表示一个目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过指定文件路径，创建File对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">File</span><span class="hljs-params">(String pathname)</span></span>&#123;...&#125;<br><br><span class="hljs-comment">//通过父路径名和子路径名，创建File对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">File</span><span class="hljs-params">(String parent, String child)</span></span>&#123;...&#125;<br><br><span class="hljs-comment">//通过父路径名和子路径名，创建File对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">File</span><span class="hljs-params">(File parent, String child)</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure><br/><p>例 1：通过指定文件路径，创建 File 对象。</p><p>Windows 系统中的路径分隔符，使用 / 或者 \ 都可以，但是 \ 需要转义一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String pathname1 = <span class="hljs-string">&quot;D:\\Users\\test.txt&quot;</span>;<br>String pathname2 = <span class="hljs-string">&quot;D:/sers/test.txt&quot;</span>;<br>File file = <span class="hljs-keyword">new</span> File(pathname1);<br></code></pre></td></tr></table></figure><br/><p>例 2：通过父路径名和子路径名，创建 File 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String parent = <span class="hljs-string">&quot;D:/Users&quot;</span>;<br>String child = <span class="hljs-string">&quot;test.txt&quot;</span>;<br>File file = <span class="hljs-keyword">new</span> File(parent,child);<br></code></pre></td></tr></table></figure><br/><p>例 3：通过父路径名和子路径名，创建File对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String parentPath = <span class="hljs-string">&quot;D:/briup&quot;</span>;<br>File parent = <span class="hljs-keyword">new</span> File(parentPath); <span class="hljs-comment">//parent 表示一个目录。</span><br><br>String child = <span class="hljs-string">&quot;Hello.java&quot;</span>;<br>File file = <span class="hljs-keyword">new</span> File(parent,child);<br></code></pre></td></tr></table></figure><br/><h3 id="1-2-常用方法"><a href="#1-2-常用方法" class="headerlink" title="1.2 常用方法"></a>1.2 常用方法</h3><p>获取：</p><p><code>public String getName()</code>：获取文件或目录的名称。</p><p><code>public String getParent()</code>：获取父目录的名称。如果没有就返回 <code>null</code>。</p><p><code>public File getParentFile()</code>：获取父目录。如果没有就返回 <code>null</code>。</p><p><code>public String getPath()</code>：获取创建 File 对象时传入的路径参数（有可能是相对路径）。</p><p><code>public String getAbsolutePath()</code>：获取 File 对象的绝对路径。</p><p><code>public long length()</code>：获取文件的长度。</p><p><code>public String[] list() </code>：返回目录中所有的子文件或子目录，返回值是 String 类型数组。</p><p><code>public String[] list(FilenameFilter filter)</code>：返回目录中所有满足过滤条件的子文件或子目录，返回值是 String 类型数组。</p><p><code>public File[] listFiles() </code>：返回目录中所有的子文件或子目录，返回值是 File 类型数组。</p><p><code>public File[] listFiles(FileFilter filter)</code>：返回目录中所有满足过滤条件的子文件或子目录，返回值是 File 类型数组。</p><br/><p>判断：</p><p><code>public boolean exists()</code>：判断此文件或目录是否真的存在。</p><p><code>public boolean isDirectory() </code>：判断 File 对象表示的是否是一个目录。</p><p><code>public boolean isFile()</code>：判断 File 对象表示的是否是一个文件。</p><p><code>public boolean isAbsolute()</code>：判断创建 File 对象时传入的路径参数是否为绝对路径。</p><p><code>public boolean canRead()</code>：判断是否可读。</p><p><code>public boolean canWrite()</code>：判断是否可写。</p><br/><p>文件操作：</p><p><code>public boolean createNewFile() </code>：创建一个文新文件 </p><p><code>public boolean delete()</code> ：删除文件或目录 </p><p><code>public boolean mkdir() </code>：创建一个目录 </p><p><code>public boolean mkdirs() </code>：创建多级目录</p><p><code>public boolean renameTo(File dest)</code>：重命名。</p><br/><h2 id="2-字节流读写文件"><a href="#2-字节流读写文件" class="headerlink" title="2. 字节流读写文件"></a>2. 字节流读写文件</h2><p>使用字节流，可以从文件中读取数据，以及向文件中写数据。 </p><ul><li><code>java.io.FileInputStream</code> 负责从文件中读取数据。</li><li><code>java.io.FileOutputStream</code> 负责把数据写入到文件中。</li></ul><br/><h3 id="2-1-FileInputStream"><a href="#2-1-FileInputStream" class="headerlink" title="2.1 FileInputStream"></a>2.1 FileInputStream</h3><h4 id="2-1-1-构造器"><a href="#2-1-1-构造器" class="headerlink" title="2.1.1 构造器"></a>2.1.1 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过指定的字符串参数来创建File类对象，而后再与File对象所代表的实际路径建立链接创建FileInputStream 流对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileInputStream</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//通过打开与File类对象代表的实际文件的链接来创建FileInputStream流对象。若File类对象的所代表的文件不存在;不是文件是目录;或者其他原因不能打开的话，则会抛出FileNotFoundException。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileInputStream</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//使用的fdObj文件描述符来作为参数，文件描述符是指与计算机系统中的文件的连接，前面两个方法的源码中最后都是利用文件描述符来建立连接的。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileInputStream</span><span class="hljs-params">(FileDescriptor fdObj)</span> </span>&#123;<br>   <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-2-常用方法"><a href="#2-1-2-常用方法" class="headerlink" title="2.1.2 常用方法"></a>2.1.2 常用方法</h4><p><code>public int read()</code>：从文件中读取一个字节的数据。</p><p><code>public int read(byte b[])</code>：从文件中读取数据并存入 b[ ]。返回实际读取的字节数。</p><p><code>public int read(byte b[], int off, int len)</code>：从文件中读取数据并存入 b[ ] 的指定部分。</p><br/><h3 id="2-2-FileOutputStream"><a href="#2-2-FileOutputStream" class="headerlink" title="2.2 FileOutputStream"></a>2.2 FileOutputStream</h3><h4 id="2-2-1-构造器"><a href="#2-2-1-构造器" class="headerlink" title="2.2.1 构造器"></a>2.2.1 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过指定的字符串参数来创建 File 类对象，而后再与 File 对象所代表的实际路径建立链接创建 FileOutputStream 流对象。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileOutputStream</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//通过指定的字符串参数来创建 File 类对象，而后再与 File 对象所代表的实际路径建立链接创建 FileOutputStream 流对象。append 为 true 表示从文件尾开始写入。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileOutputStream</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> append)</span></span><br><span class="hljs-function">  <span class="hljs-comment">//...</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//通过打开与File类对象代表的实际文件的链接来创建 FileOutputStream 流对象。若 File 类对象的所代表的文件不存在;不是文件是目录;或者其他原因不能打开的话，则会抛出FileNotFoundException。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileOutputStream</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-comment">//同上</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileOutputStream</span><span class="hljs-params">(File file, <span class="hljs-keyword">boolean</span> append)</span> <span class="hljs-keyword">throws</span> FileNotFoundException</span><br><span class="hljs-function"> <span class="hljs-comment">//...</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileOutputStream</span><span class="hljs-params">(FileDescriptor fdObj)</span> </span>&#123;<br> <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="2-2-2-常用方法"><a href="#2-2-2-常用方法" class="headerlink" title="2.2.2 常用方法"></a>2.2.2 常用方法</h4><p><code>public void write(int b)</code>：将一个字节写入文件。</p><p><code>public void write(byte b[])</code>：将字节数组 b[ ] 写入文件。</p><p><code>public void write(byte b[], int off, int len)</code>：将字节数组 b[ ] 的指定部分写入文件。</p><br/><h2 id="3-字符流读写文件"><a href="#3-字符流读写文件" class="headerlink" title="3. 字符流读写文件"></a>3. 字符流读写文件</h2>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO 流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO 流（三）字符流</title>
    <link href="/2021/06/30/CoreJava/28.%20IO%E6%B5%81%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
    <url>/2021/06/30/CoreJava/28.%20IO%E6%B5%81%EF%BC%88%E4%B8%89%EF%BC%89%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>常见的字符流及其用法。</p><span id="more"></span><h2 id="1-字符流"><a href="#1-字符流" class="headerlink" title="1. 字符流"></a>1. 字符流</h2><p>JavaAPI 中提供了字符流，可以用字符的形式，读写数据，专门用于处理文本数据。</p><h3 id="1-1-Reader"><a href="#1-1-Reader" class="headerlink" title="1.1 Reader"></a>1.1 Reader</h3><p><code>java.io.Reader</code> 是所有字符输入流的抽象父类型。</p><p>其中的 3 个 核心 read 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//每次读取一个字符，返回这个字符的编码值。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">char</span> cb[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (read(cb, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) == -<span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> cb[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">//每次读取多个字符，并存放到指定字符数组中，返回值是本次读取到的字符个数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> cbuf[])</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-keyword">return</span> read(cbuf, <span class="hljs-number">0</span>, cbuf.length);<br>&#125;<br><br><span class="hljs-comment">//每次读取多个字符，并存放到指定字符数组中，返回值是本次读取到的字符个数</span><br><span class="hljs-comment">//同时可以指定从数组的什么位置开始存放，以及在数组中最多存放多个字符</span><br><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> cbuf[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br></code></pre></td></tr></table></figure><h3 id="1-2-Writer"><a href="#1-2-Writer" class="headerlink" title="1.2 Writer"></a>1.2 Writer</h3><p><code>java.io.Writer</code> 是所有字符输出流的抽象父类型。</p><p>其中的 3 个 核心 write 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写出去一个字符，注意字符可以使用int值来表示</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">if</span> (writeBuffer == <span class="hljs-keyword">null</span>)&#123;<br>      writeBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[WRITE_BUFFER_SIZE];<br>    &#125;<br>    writeBuffer[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">char</span>) c;<br>    write(writeBuffer, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//写出去数组中的多个字符</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> cbuf[])</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  write(cbuf, <span class="hljs-number">0</span>, cbuf.length);<br>&#125;<br><br><br><span class="hljs-comment">//写出去数组中的多个字符</span><br><span class="hljs-comment">//可以指定从数组的什么位置开始写，以及多少个字符</span><br><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> cbuf[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br><br><span class="hljs-comment">//写出去一个字符串</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String str)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  write(str, <span class="hljs-number">0</span>, str.length());<br>&#125;<br><br><br><span class="hljs-comment">//写出去一个字符串</span><br><span class="hljs-comment">//可以指定从字符串的什么位置开始写，以及多少个字符</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">char</span> cbuf[];<br>    <span class="hljs-keyword">if</span> (len &lt;= WRITE_BUFFER_SIZE) &#123;<br>      <span class="hljs-keyword">if</span> (writeBuffer == <span class="hljs-keyword">null</span>) &#123;<br>        writeBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[WRITE_BUFFER_SIZE];<br>      &#125;<br>      cbuf = writeBuffer;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];<br>    &#125;<br>    str.getChars(off, (off + len), cbuf, <span class="hljs-number">0</span>);<br>    write(cbuf, <span class="hljs-number">0</span>, len);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，所以的方法都是调用抽象方法 <code>write(char cbuf[], int off, int len)</code> 来实现的。</p><h2 id="2-字符数组"><a href="#2-字符数组" class="headerlink" title="2. 字符数组"></a>2. 字符数组</h2><h3 id="2-1-CharArrayReader"><a href="#2-1-CharArrayReader" class="headerlink" title="2.1 CharArrayReader"></a>2.1 CharArrayReader</h3><h4 id="2-1-1-属性"><a href="#2-1-1-属性" class="headerlink" title="2.1.1 属性"></a>2.1.1 属性</h4><p>在 CharArrayReader 类中有 4 个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">char</span> buf[];<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> pos;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> mark = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> count;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>buf[]</code></td><td>由流的创建者提供的字节数组。</td></tr><tr><td><code>pos</code></td><td>要从输入流缓冲区读取的下一个字符的索引。</td></tr><tr><td><code>markedPos</code></td><td>流中当前标记的位置。</td></tr><tr><td><code>count</code></td><td>缓冲区末尾的索引。</td></tr></tbody></table><br/><h4 id="2-1-2-构造器"><a href="#2-1-2-构造器" class="headerlink" title="2.1.2 构造器"></a>2.1.2 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从指定的字符数组创建一个 CharArrayReader。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CharArrayReader</span><span class="hljs-params">(<span class="hljs-keyword">char</span> buf[])</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.buf = buf;<br>    <span class="hljs-keyword">this</span>.pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>.count = buf.length;<br>&#125;<br><br><span class="hljs-comment">//从指定的字符数组创建一个 CharArrayReader。</span><br><span class="hljs-comment">//从 offset 处开始读取 buf[] 数组。可读取的 char 值总数为 length 与 buf.length-offset 之间的较小值。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CharArrayReader</span><span class="hljs-params">(<span class="hljs-keyword">char</span> buf[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span>) || (offset &gt; buf.length) || (length &lt; <span class="hljs-number">0</span>) ||<br>        ((offset + length) &lt; <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    &#125;<br>    <span class="hljs-keyword">this</span>.buf = buf;<br>    <span class="hljs-keyword">this</span>.pos = offset;<br>    <span class="hljs-keyword">this</span>.count = Math.min(offset + length, buf.length);<br>    <span class="hljs-keyword">this</span>.markedPos = offset;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="2-1-3-常用方法"><a href="#2-1-3-常用方法" class="headerlink" title="2.1.3 常用方法"></a>2.1.3 常用方法</h4><p><code>public int read()</code>：读入单个字符。如果到达流的末尾则返回 -1，否则返回字符对应的整数值。</p><p><code>public int read(char b[], int off, int len)</code>：将流中的字符数据读入到 b[ ] 数组的一部分。如果到达流的末尾则返回 -1，否则返回实际读入的字符数量。</p><p><code>public long skip(long n)</code>：跳过字符。 返回实际跳过的字符数。 如果n为负，则此方法不执行任何操作并返回0 。</p><p><code>public void mark(int readAheadLimit)</code>：标记流中的当前位置。 对 reset() 的后续调用会将流重新定位到这一点。</p><p><code>public void reset()</code>：将流重置为最近的标记，如果从未标记过，则重置为开头。</p><p><code>public void close()</code>：关闭流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">char</span>[] chars = <span class="hljs-string">&quot;helloWorld&quot;</span>.toCharArray();<br>    <span class="hljs-keyword">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">int</span> data = -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 创建输入流。</span><br>    CharArrayReader reader = <span class="hljs-keyword">new</span> CharArrayReader(chars);<br><br>    <span class="hljs-comment">// 将输入流里的数据读入到 buffer 数组，并将其打印。</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-keyword">int</span> read = reader.read(buffer, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>      System.out.println(Arrays.toString(buffer));<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>      e.printStackTrace();<br>    &#125;<br>  <span class="hljs-comment">// 执行完上述代码已经到达输入流的末尾。</span><br><br>    <span class="hljs-comment">// 将输入流里的数据一个一个地读入到控制台。</span><br>    <span class="hljs-keyword">try</span>&#123;<br>      reader.reset();  <span class="hljs-comment">//重新回到缓冲数组的开头。</span><br>      <span class="hljs-keyword">long</span> skip = reader.skip(<span class="hljs-number">5</span>); <span class="hljs-comment">//跳过前5个字符。</span><br>      System.out.println(<span class="hljs-string">&quot;跳过了&quot;</span> + skip + <span class="hljs-string">&quot;个字符&quot;</span>);<br>      <span class="hljs-keyword">while</span> ((data = reader.read()) != -<span class="hljs-number">1</span>)&#123;<br>        System.out.print((<span class="hljs-keyword">char</span>)data);<br>      &#125;<br><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>      e.printStackTrace();<br>    &#125;<br>    reader.close();<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-2-CharArrayWriter"><a href="#2-2-CharArrayWriter" class="headerlink" title="2.2 CharArrayWriter"></a>2.2 CharArrayWriter</h3><h4 id="2-2-1-属性"><a href="#2-2-1-属性" class="headerlink" title="2.2.1 属性"></a>2.2.1 属性</h4><p>CharArrayWriter 中只有 2 个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">char</span> buf[];<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> count;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code> buf[]</code></td><td>存储数据的缓冲区。</td></tr><tr><td><code>count</code></td><td>缓冲区中的有效字节数。</td></tr></tbody></table><br/><h4 id="2-2-2-构造器"><a href="#2-2-2-构造器" class="headerlink" title="2.2.2 构造器"></a>2.2.2 构造器</h4><p>CharArrayWriter 中只有 2 个构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 CharArrayWriter，不指定缓冲区数组的大小（默认为32）。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CharArrayWriter</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(<span class="hljs-number">32</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建 CharArrayWriter，指定缓冲区数组的大小。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CharArrayWriter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialSize)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialSize &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Negative initial size: &quot;</span> + initialSize);<br>    &#125;<br>    buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[initialSize];<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="2-2-3-常用方法"><a href="#2-2-3-常用方法" class="headerlink" title="2.2.3 常用方法"></a>2.2.3 常用方法</h4><p><code>public void write(int c)</code>：将一个字符写入缓冲区。</p><p><code>public void write(char c[])</code>：将数组 c[ ] 写入缓冲区。</p><p><code>public void write(char c[], int off, int len)</code>：将数组 c[ ] 的一部分写入缓冲区。</p><p><code>public void write(String str)</code>：将字符串 str 写入缓冲区</p><p><code>public void write(String str, int off, int len)</code>：将字符串 str 的一部分写入缓冲区。</p><p><code>public char[] toCharArray() </code>：将缓冲区的数据复制到一个 char 类型的数组并返回。</p><p><code>public String toString()</code>：将缓冲区的数据转换为字符串并返回。</p><p><code>public void flush()</code>：</p><p><code>public void close()</code>：关闭流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>[] chars = <span class="hljs-string">&quot;helloWorld&quot;</span>.toCharArray();<br>    String str = <span class="hljs-string">&quot;helloJava&quot;</span>;<br><br>    <span class="hljs-comment">//创建输出流</span><br>    CharArrayWriter writer = <span class="hljs-keyword">new</span> CharArrayWriter();<br><br>    <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-comment">//将 chars 数组内的数据写入输出流</span><br>      writer.write(chars);<br>      System.out.println(Arrays.toString(writer.toCharArray()));<br>      System.out.println(writer.toString());<br><br>      <span class="hljs-comment">//将字符串 str 写入输出流</span><br>      writer.write(str);<br>      System.out.println(Arrays.toString(writer.toCharArray()));<br>      System.out.println(writer.toString());<br><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>      e.printStackTrace();<br>    &#125;<br>    writer.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-管道"><a href="#3-管道" class="headerlink" title="3. 管道"></a>3. 管道</h2><p>使用字符流，可以从管道中读取数据，以及向管道中写数据。</p><ul><li><code>java.io.PipedReader </code>负责从管道中读取数据。</li><li><code>java.io.PipedWriter</code> 负责将数据写入到管道中。</li></ul><p>一般可以在一个线程中，使用管道输出流，将数据写入到管道中，在另一个线程中，读取管道中的数据。</p><br/><h3 id="3-1-PipedReader"><a href="#3-1-PipedReader" class="headerlink" title="3.1 PipedReader"></a>3.1 PipedReader</h3><h4 id="3-1-1-构造器"><a href="#3-1-1-构造器" class="headerlink" title="3.1.1 构造器"></a>3.1.1 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个未连接的 PipedReader，默认管道缓冲区大小为 1024。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedReader</span><span class="hljs-params">()</span> </span>&#123;<br>    initPipe(DEFAULT_PIPE_SIZE);<br>&#125;<br><br><span class="hljs-comment">// 创建一个未连接的 PipedReader，并指定管道缓冲区大小。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedReader</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipeSize)</span> </span>&#123;<br>    initPipe(pipeSize);<br>&#125;<br><br><span class="hljs-comment">// 创建一个与 PipedWriter 连接的 PipedReader。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedReader</span><span class="hljs-params">(PipedWriter src)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-keyword">this</span>(src, DEFAULT_PIPE_SIZE);<br>&#125;<br><br><span class="hljs-comment">//创建一个与 PipedWriter 连接的 PipedReader，同时指定管道缓冲区大小。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedReader</span><span class="hljs-params">(PipedWriter src, <span class="hljs-keyword">int</span> pipeSize)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    initPipe(pipeSize);<br>    connect(src);<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="3-1-2-常用方法"><a href="#3-1-2-常用方法" class="headerlink" title="3.1.2 常用方法"></a>3.1.2 常用方法</h4><p><code>public void connect(PipedWriter src)</code>：连接一个 PipedWriter 对象。</p><p><code>public synchronized int read()</code>：从管道缓冲区中读取一个字符，并返回这个字符的整数值。 如果由达到流的末尾，则返回 -1 。 此方法会阻塞，直到输入数据可用、检测到流结束或抛出异常为止。</p><p><code>public synchronized int read(char cbuf[], int off, int len)</code>：将管道缓冲区里的数据读入到cbuf[ ] 的指定部分，并返回实际读入字符的个数。如果由达到流的末尾，则返回 -1 。此方法会阻塞，直到至少有一个输入字符可用。</p><p><code>public void close()</code>：关闭流。</p><br/><h3 id="3-2-PipedWriter"><a href="#3-2-PipedWriter" class="headerlink" title="3.2 PipedWriter"></a>3.2 PipedWriter</h3><h4 id="3-2-1-构造器"><a href="#3-2-1-构造器" class="headerlink" title="3.2.1 构造器"></a>3.2.1 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个与 PipedReader 连接的 PipedWriter。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedWriter</span><span class="hljs-params">(PipedReader snk)</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  connect(snk);<br>&#125;<br><br><span class="hljs-comment">//创建一个未连接的 PipedWriter。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedWriter</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="3-2-2-常用方法"><a href="#3-2-2-常用方法" class="headerlink" title="3.2.2 常用方法"></a>3.2.2 常用方法</h4><p><code>public synchronized void connect(PipedReader snk)</code>：连接一个 PipedReader 对象。</p><p><code>public void write(int c)</code>：将指定字符 c 写入到与之连接的 PipedReader 对象的管道缓冲区中。如果线程正在从连接的管道输入流中读取数据字符，但该线程不再处于活动状态，则会抛出IOException 。</p><p><code>public void write(char cbuf[], int off, int len)</code>：将字符数组 cbuf[ ] 的指定部分写入到与之连接的 PipedReader 对象的管道缓冲区中。如果线程正在从连接的管道输入流中读取数据字符，但该线程不再处于活动状态，则会抛出 IOException 。</p><p><code>public synchronized void flush()</code>：刷新此输出流并强制写出任何缓冲的输出字符。</p><p><code>public void close()</code>：关闭流。</p><br/><h3 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3 使用"></a>3.3 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pipe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>       <span class="hljs-keyword">try</span> &#123;<br>           PipedReader reader = <span class="hljs-keyword">new</span> PipedReader();<br>           PipedWriter writer = <span class="hljs-keyword">new</span> PipedWriter(reader);<br><br>           WriteThread t1 = <span class="hljs-keyword">new</span> WriteThread(writer,<span class="hljs-string">&quot;T1&quot;</span>);<br>           ReadThread t2 = <span class="hljs-keyword">new</span> ReadThread(reader,<span class="hljs-string">&quot;T2&quot;</span>);<br><br>            t1.start();<br>            t1.join();<br>            t2.start();<br><br>       &#125;<span class="hljs-keyword">catch</span> (IOException | InterruptedException e)&#123;<br>           e.printStackTrace();<br>       &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">public</span> PipedWriter writer;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WriteThread</span><span class="hljs-params">(PipedWriter writer, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.writer = writer;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        setName(name);<br>        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-string">&quot;helloWorld&quot;</span>.toCharArray();<br>        <span class="hljs-keyword">try</span>&#123;<br>            writer.write(chars);<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                writer.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-keyword">public</span> PipedReader reader;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadThread</span><span class="hljs-params">(PipedReader reader, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.reader = reader;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        setName(name);<br>        <span class="hljs-keyword">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">12</span>];<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">int</span> read = reader.read(chars);<br>            System.out.println(<span class="hljs-string">&quot;一共读入了&quot;</span> + read +<span class="hljs-string">&quot;个字符到数组&quot;</span>);<br>            System.out.println(Arrays.toString(chars));<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                reader.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>PipedWriter 和 PipedReader 未进行连接都不能正常使用。</li><li>先使用 PipedWriter 的 write 方法写入数据，才能使用 PipedReader 的 read 方法读数据。</li><li> PipedWriter 类内有一个私有属性 PipedReader sink。 当 PipedWriter  对象与 PipedReader 对象连接时，会将 PipedReader 对象的引用赋值给 sink。</li><li>PipedWriter 的 write 方法实际上是调用了与之连接的 PipedReader 对象的 receive 方法，将 write 方法写入的数据储存在该 PipedReader 对象的管道缓冲区中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO 流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO 流（二）字节流</title>
    <link href="/2021/06/29/CoreJava/27.%20IO%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E8%8A%82%E6%B5%81/"/>
    <url>/2021/06/29/CoreJava/27.%20IO%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>常见的字节流及其用法。</p><span id="more"></span><h2 id="1-字节流"><a href="#1-字节流" class="headerlink" title="1. 字节流"></a>1. 字节流</h2><p>计算机中一切数据（文本、图片、视频等）都是以二进制的形式存储的，最终都是一个一个的字节。所以使用流，进行传输数据的时候，也是一个一个的字节进行的。</p><br/><h3 id="1-1-InputStream"><a href="#1-1-InputStream" class="headerlink" title="1.1 InputStream"></a>1.1 InputStream</h3><p><code>java.io.InputStream</code> 是所有字节输入流的抽象父类型。</p><p>InputStream 类其中的 3 个核心 read 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从输入流中读取下一个字节的数据。 </span><br><span class="hljs-comment"> * 值字节以 0 到 255 范围内的int形式返回。 如果由于已到达流末尾而没有可用字节，则返回值-1。 </span><br><span class="hljs-comment"> * 此方法会阻塞，直到输入数据可用、检测到流的结尾或抛出异常。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从输入流中读取一定数量的字节并将它们存储到缓冲区数组 b，返回读入缓冲区的总字节数。</span><br><span class="hljs-comment"> * 如果 b 的长度为零，则不读取字节并返回 0。否则，将尝试读取至少一个字节。 </span><br><span class="hljs-comment"> * 如果由于流位于文件末尾而没有可用字节，则返回值-1。否则，至少读取一个字节并将其存储到 b。</span><br><span class="hljs-comment"> * 读取的第一个字节存储到元素 b[0]，下一个存储到 b[1]，依此类推。 读取的字节数最多等于 b 的长度。</span><br><span class="hljs-comment"> * 此方法会阻塞，直到输入数据可用、检测到文件结尾或抛出异常。</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 参数：b – 读取数据的缓冲区。</span><br><span class="hljs-comment">返回：读入缓冲区的总字节数，如果由于已到达流末尾而没有更多数据，则为-1 。</span><br><span class="hljs-comment">抛出：IOException – 如果由于文件末尾以外的任何原因无法读取第一个字节，如果输入流已关闭，或者如果发生其他一些 I/O 错误。</span><br><span class="hljs-comment">      NullPointerException – 如果 b 为 null。 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 此方法的默认实现会阻塞，直到读取了请求的输入数据量len 、检测到文件结尾或抛出异常。 鼓励子类提供此方法的更有效实现。 </span><br><span class="hljs-comment"> * 从输入流中读取最多 len 个字节的数据到一个字节数组中。尝试读取多达 len 个字节，但可能会读取较小的数字。实际读取的字节数作为整数返回。</span><br><span class="hljs-comment"> * 如果 len 为零，则不读取字节并返回0。否则，将尝试读取至少一个字节。 </span><br><span class="hljs-comment"> * 如果由于流位于文件末尾而没有可用字节，则返回值-1。否则，至少读取一个字节并将其存储到 b。</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * 在每种情况下，元素 b[0] 到 b[off] 和元素 b[off+len] 到 b[b.length-1] 不受影响。</span><br><span class="hljs-comment"> * 读取的第一个字节存储到元素 b[off] ，下一个存储到 b[off+1] ，依此类推。 读取的字节数最多等于 len。 令 k 为实际读取的字节数：这些字节将存储在元素 b[off] 到 b[off+ k -1]，而元素 b[off+ k ] 到 b[off+len-1] 不受影响。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * InputStream 类的 read(b, off, len) 方法只是重复调用 read() 方法。 </span><br><span class="hljs-comment"> * 如果第一次这样的调用导致 IOException ，则该异常将从对 read(b, off, len) 方法的调用返回。</span><br><span class="hljs-comment"> * 如果对 read() 任何后续调用导致 IOException ，则会捕获该异常并将其视为文件结尾；到该点读取的字节存储到 b 并返回发生异常之前读取的字节数。 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">   参数：</span><br><span class="hljs-comment">      b – 读取数据的缓冲区。</span><br><span class="hljs-comment">      off – 数组b中写入数据的起始偏移量。</span><br><span class="hljs-comment">      len – 要读取的最大字节数。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">返回：读入缓冲区的总字节数，如果由于已到达流末尾而没有更多数据，则为-1 。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   抛出：</span><br><span class="hljs-comment">      IOException – 如果由于文件结尾以外的任何原因无法读取第一个字节，或者如果输入流已关闭，或者如果发生其他一些 I/O 错误。</span><br><span class="hljs-comment">      NullPointerException – 如果 b 为 null。 </span><br><span class="hljs-comment">      IndexOutOfBoundsException – 如果 off 为负， len 为负，或者 len 大于 b.length - off。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  Objects.checkFromIndexSize(off, len, b.length);<br>  <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">int</span> c = read();<br>  <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>  b[off] = (<span class="hljs-keyword">byte</span>)c;<br><br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (; i &lt; len ; i++) &#123;<br>      c = read();<br>      <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      b[off + i] = (<span class="hljs-keyword">byte</span>)c;<br>    &#125;<br>  &#125; <span class="hljs-keyword">catch</span> (IOException ee) &#123;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-OutputStream"><a href="#1-2-OutputStream" class="headerlink" title="1.2 OutputStream"></a>1.2 OutputStream</h3><p><code>java.io.OutputStream</code> 是所有字节输出流的抽象父类型。</p><p>OutputStream 类其中的 3 个核心 read 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将指定的字节写入此输出流。write的一般约定是将一个字节写入输出流。要写入的字节是参数 b 低八位，b 的 24 个高位被忽略。</span><br><span class="hljs-comment"> * OutputStream 子类必须为此方法提供实现。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  参数：b – byte </span><br><span class="hljs-comment">  抛出：IOException – 如果发生 I/O 错误。 特别是，如果输出流已关闭，则可能会抛出 IOException。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将指定字节数组中的 b.length 个字节写入此输出流。 </span><br><span class="hljs-comment"> * write(b)的一般约定是它应该与调用write(b, 0, b.length)具有完全相同的效果。</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 参数：b —— 数据。</span><br><span class="hljs-comment"> 抛出：IOException – 如果发生 I/O 错误。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  write(b, <span class="hljs-number">0</span>, b.length);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将指定字节数组中的 len 个字节从偏移量 off 开始写入此输出流。 </span><br><span class="hljs-comment"> * write(b, off, len) 的一般约定是将数组 b 中的一些字节按顺序写入输出流</span><br><span class="hljs-comment"> * 元素 b[off] 是写入的第一个字节， b[off+len-1] 是此操作写入的最后一个字节。</span><br><span class="hljs-comment"> * 如果 b 为null ，则抛出 NullPointerException 。</span><br><span class="hljs-comment"> * 如果 off 为负，或 len 为负，或 off+len 大于数组 b 的长度，则抛出 IndexOutOfBoundsException。</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">  参数：</span><br><span class="hljs-comment">      b——数据。</span><br><span class="hljs-comment">      off – 数据中的起始偏移量。</span><br><span class="hljs-comment">      len – 要写入的字节数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">  抛出：</span><br><span class="hljs-comment">  IOException – 如果发生 I/O 错误。 特别是，如果输出流关闭，则会抛出IOException 。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  Objects.checkFromIndexSize(off, len, b.length);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i++) &#123;<br>    write(b[off + i]);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><p>一般情况，使用字节流来操作数据的时候，往往是使用一对一。一个字节输入流，负责读取数据；一 个字节输出流，负责将数据写出去，而这些流都将是 InputStream 和 OutputStream 的子类型。</p><br/><p>在代码中，使用流操作数据的的基本步骤是： 1. 声明流  2. 创建流  3. 使用流  4. 关闭流。</p><br/><h2 id="2-控制台"><a href="#2-控制台" class="headerlink" title="2. 控制台"></a>2. 控制台</h2><p>使用字节流，从控制台读取数据，以及向控制台中写数据。</p><p>在 <code>java.lang.System</code> 中定义了两个常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//The &quot;standard&quot; input stream.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> InputStream in = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">//The &quot;standard&quot; output stream.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> PrintStream out = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><br/><p>PrintStream 里的 write 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> buf[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> buf[])</span> </span>&#123;<br>   <span class="hljs-comment">//...</span><br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String s)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//1.声明流</span><br>    InputStream in = <span class="hljs-keyword">null</span>;<br>    OutputStream out = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-comment">//2.创建流，这里使用System中已经创建好的流对象</span><br>    in = System.in;<br>    out = System.out;<br>    <br>    <span class="hljs-comment">//3.使用流</span><br>    <span class="hljs-keyword">int</span> data = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      data = in.read();<br>      out.write(data);<br>      out.flush();<span class="hljs-comment">//刷新缓冲区，强制所有数据写出去</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      <br>      <span class="hljs-comment">//4.关闭流</span><br>      <span class="hljs-keyword">if</span>(in!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      <br>      <span class="hljs-keyword">if</span>(out!=<span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          out.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      <br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><br/><p>例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//1.声明流</span><br>    InputStream in = <span class="hljs-keyword">null</span>;<br>    OutputStream out = <span class="hljs-keyword">null</span>;<br>    <br>    <span class="hljs-comment">//2.创建流，这里使用System中已经创建好的流对象</span><br>    in = System.in;<br>    out = System.out;<br>    <br>    <span class="hljs-comment">//3.使用流</span><br>    <span class="hljs-keyword">int</span> len = -<span class="hljs-number">1</span>; <span class="hljs-comment">//本次读取到的字节个数</span><br>    <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>]; <span class="hljs-comment">//读取的字节都存到这个数组中，最多一次存1024个字节</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      len = in.read(buf);<br>      out.write(buf,<span class="hljs-number">0</span>,len);<span class="hljs-comment">//本次读了多几个字节，那么就写出几个字节</span><br>      out.flush();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>      <br>      <span class="hljs-comment">//4.关闭流</span><br>      <span class="hljs-keyword">if</span>(in != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      <br>      <span class="hljs-keyword">if</span>(out != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          out.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个子类中重写的 read 方法，会让线程阻塞，等待用户在控制台中的输入。用户输入并按下回车，程序中的 read 方法就从阻塞状态恢复过来，从而读取到用户输入的内容。</p><br/><h2 id="3-字节数组"><a href="#3-字节数组" class="headerlink" title="3. 字节数组"></a>3. 字节数组</h2><h3 id="3-1-ByteArrayInputStream"><a href="#3-1-ByteArrayInputStream" class="headerlink" title="3.1 ByteArrayInputStream"></a>3.1 ByteArrayInputStream</h3><h4 id="3-1-1-属性"><a href="#3-1-1-属性" class="headerlink" title="3.1.1 属性"></a>3.1.1 属性</h4><p>在 ByteArrayInputStream 类中有 4 个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">byte</span> buf[];<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> pos;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> mark = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> count;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>buf[]</code></td><td>由流的创建者提供的字节数组。元素 buf[0] 到buf [count-1] 是唯一可以从流中读取的字节；元素 buf[pos] 是要读取的下一个字节。</td></tr><tr><td><code>pos</code></td><td>要从输入流缓冲区读取的下一个字符的索引。 <strong>此值应始终为非负且不大于 count 的值。</strong> 要从输入流缓冲区读取的下一个字节将是 buf[pos] 。</td></tr><tr><td><code>mark</code></td><td>流中当前标记的位置。 ByteArrayInputStream 对象在构造时默认标记在位置零。<br/>它们可以通过 mark() 方法在缓冲区内的另一个位置进行 mark() 。 当前缓冲区位置由 reset() 方法设置到这一点。<br/>如果未设置标记，则标记的值是传递给构造函数的偏移量。（如果未提供偏移量，则为 0）</td></tr><tr><td><code>count</code></td><td>比输入流缓冲区中最后一个有效字符大一的索引。 <strong>此值应始终为非负且不大于 buf 的长度</strong>。 它比 buf 中可以从输入流缓冲区读取的最后一个字节的位置大一个。</td></tr></tbody></table><h4 id="3-1-2-构造器"><a href="#3-1-2-构造器" class="headerlink" title="3.1.2 构造器"></a>3.1.2 构造器</h4><p>在 ByteArrayInputStream 类中有 2 个构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个 ByteArrayInputStream 以buf作为其缓冲区数组。不复制缓冲区数组。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ByteArrayInputStream</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> buf[])</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.buf = buf;<br>    <span class="hljs-keyword">this</span>.pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">this</span>.count = buf.length;<br>&#125;<br><br><span class="hljs-comment">// 创建使用buf作为其缓冲区数组的 ByteArrayInputStream。</span><br><span class="hljs-comment">// pos 的初始值是 offset，count 的初始值是 offset+length 和 buf.length 中更小的一个。</span><br><span class="hljs-comment">// 不复制缓冲区数组。 缓冲区的标记设置为指定的偏移量。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ByteArrayInputStream</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> buf[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.buf = buf;<br>    <span class="hljs-keyword">this</span>.pos = offset;<br>    <span class="hljs-keyword">this</span>.count = Math.min(offset + length, buf.length);<br>    <span class="hljs-keyword">this</span>.mark = offset;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-3-常用方法"><a href="#3-1-3-常用方法" class="headerlink" title="3.1.3 常用方法"></a>3.1.3 常用方法</h4><p>**<code>int read()</code>**：从此输入流中读取下一个数据字节。 </p><ul><li>值字节以 0 到 255 范围内的 int 形式返回。 </li><li>如果由于已到达流末尾而没有可用字节，则返回值 -1 。</li><li><strong>这种read方法不能阻塞。</strong></li></ul><br/><p>**<code>int read(byte b[], int off, int len)</code>**：从此输入流中将最多 len 个字节的数据读入字节数组。 </p><ul><li>如果 pos 等于 count ，则返回 -1 以指示文件结束。 </li><li>读取的字节数 k 等于 len 和 count-pos 的较小者。 如果 k 为正数，则字节 buf[pos] 到 buf[pos+k-1] 以 <code>System.arraycopy</code> 执行的方式复制到 b[off] 到 b[off+k-1] 中。 将值 k 添加到 pos 并返回 k 。</li><li><strong>这种 read 方法不能阻塞。</strong></li></ul><br/><p>**<code>long skip(long n) </code>**：从这个输入流跳过 n 个字节的输入。返回实际跳过的字节数。</p><ul><li>如果到达输入流的末尾，可能会跳过更少的字节。 </li><li>要跳过的<strong>实际字节数 k 等于 n 和 count-pos 的较小者</strong>。 将值 k 添加到 pos 并返回 k 。</li></ul><br/><p>**<code>int available()</code>**：返回可以从此输入流读取（或跳过）的剩余字节数。</p><ul><li>返回的值是 count - pos ，它是要从输入缓冲区读取的剩余字节数。</li><li>可以在不阻塞的情况下从此输入流读取（或跳过）的剩余字节数。</li></ul><br/><h3 id="3-2-ByteArrayOutputStream"><a href="#3-2-ByteArrayOutputStream" class="headerlink" title="3.2 ByteArrayOutputStream"></a>3.2 ByteArrayOutputStream</h3><h4 id="3-2-1-属性"><a href="#3-2-1-属性" class="headerlink" title="3.2.1 属性"></a>3.2.1 属性</h4><p>ByteArrayOutputStream 中只有 2 个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">byte</span> buf[];<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> count;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code> buf[]</code></td><td>存储数据的缓冲区。</td></tr><tr><td><code>count</code></td><td>缓冲区中的有效字节数。</td></tr></tbody></table><br/><h4 id="3-2-2-构造器"><a href="#3-2-2-构造器" class="headerlink" title="3.2.2 构造器"></a>3.2.2 构造器</h4><p>在 ByteArrayOutputStream 类中有 2 个构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个 ByteArrayOutputStream。 缓冲区容量最初为 32 字节，但其大小在必要时会增加。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ByteArrayOutputStream</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(<span class="hljs-number">32</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建一个 ByteArrayOutputStream，具有指定大小的缓冲区容量（以字节为单位）。</span><br><span class="hljs-comment">// 最大容量为 MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ByteArrayOutputStream</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Negative initial size: &quot;</span>+ size);<br>  &#125;<br>  buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[size];<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-2-3-常用方法"><a href="#3-2-3-常用方法" class="headerlink" title="3.2.3 常用方法"></a>3.2.3 常用方法</h4><p>**<code>void write(int b)</code>**：将指定的字节写入此 ByteArrayOutputStream 。</p><p>**<code>void write(byte b[], int off, int len) </code>**：将指定字节数组中的 len 个字节从偏移量 off 开始写入此 ByteArrayOutputStream。</p><p>**<code>int size()</code>**：返回缓冲区的当前大小，即属性 count 的值。</p><p>**<code>void reset()</code>**：将此 ByteArrayOutputStream 的 count 字段重置为零，以便丢弃输出流中当前累积的所有输出。 输出流可以再次使用，重用已经分配的缓冲区空间。</p><p>**<code>void writeTo(OutputStream out)</code>**：将此 ByteArrayOutputStream 的完整内容写入指定的输出流参数，就像使用 out.write(buf, 0, count)调用输出流的 write 方法一样。</p><p>**<code>byte[] toByteArray()</code>**：创建一个新分配的字节数组。 它的大小是此输出流的当前大小，并且缓冲区的有效内容已复制到其中。</p><p>**<code>String toString()</code>**：使用平台的默认字符集将缓冲区的内容转换为字符串解码字节。 新String的长度是字符集的函数，因此可能不等于缓冲区的大小。</p><br/><h3 id="3-3-使用"><a href="#3-3-使用" class="headerlink" title="3.3 使用"></a>3.3 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>  <span class="hljs-comment">// 创建输入流</span><br>  <span class="hljs-keyword">byte</span>[] testArray =<span class="hljs-string">&quot;helloWorld&quot;</span>.getBytes();<br>  ByteArrayInputStream input = <span class="hljs-keyword">new</span> ByteArrayInputStream(testArray);<br><br>  <span class="hljs-comment">// 创建缓冲数组</span><br>  <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">16</span>];<br><br>  <span class="hljs-comment">// 将输入流中的数据读入到缓冲数组中</span><br>  <span class="hljs-keyword">int</span> read = input.read(buffer, <span class="hljs-number">0</span>, testArray.length);<br><br>  <span class="hljs-comment">// 查看是否读入</span><br>  System.out.println(Arrays.toString(buffer));<br><br>  <span class="hljs-comment">// 创建输出流</span><br>  ByteArrayOutputStream output = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br><br>  <span class="hljs-comment">// 将 buffer 数组中的内容写入输出流</span><br>  output.write(buffer, <span class="hljs-number">0</span> , buffer.length);<br><br>  <span class="hljs-comment">// 打印输出流里的内容，查看是否写入成功</span><br>  System.out.println(output.toString()); <span class="hljs-comment">//方式1:使用 toString 将对应的字节码转为字符</span><br>  <span class="hljs-keyword">byte</span>[] bytes = output.toByteArray();   <span class="hljs-comment">//方式2:使用 toByteArray 将输入流里的内容转为一个 byte 数组</span><br>  System.out.println(Arrays.toString(bytes));<br><br>  input.close();<br>  output.close();<br><br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h2><p>使用字节流，可以从管道中读取数据，以及向管道中写数据。 </p><ul><li><code>java.io.PipedInputStream</code> 负责从管道中读取数据。</li><li><code>java.io.PipedOutputStream</code> 负责将数据写入到管道中。</li></ul><p>一般可以在一个线程中，使用管道输出流，将数据写入到管道中，在另一个线程中，读取管道中的数据。</p><br/><h3 id="4-1-PipedInputStream"><a href="#4-1-PipedInputStream" class="headerlink" title="4.1 PipedInputStream"></a>4.1 PipedInputStream</h3><h4 id="4-1-1-构造器"><a href="#4-1-1-构造器" class="headerlink" title="4.1.1 构造器"></a>4.1.1 构造器</h4><p>PipedInputStream 有 4 个构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个未连接的 PipedInputStream。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedInputStream</span><span class="hljs-params">()</span> </span>&#123;<br>  initPipe(DEFAULT_PIPE_SIZE);<br>&#125;<br><br><span class="hljs-comment">// 创建一个未连接的PipedInputStream，并指定管道缓冲区的大小。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedInputStream</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pipeSize)</span> </span>&#123;<br>  initPipe(pipeSize);<br>&#125;<br><br><span class="hljs-comment">//创建一个与 PipedOutputStream 连接的 PipedInputStream。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedInputStream</span><span class="hljs-params">(PipedOutputStream src)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  <span class="hljs-keyword">this</span>(src, DEFAULT_PIPE_SIZE);<br>&#125;<br><br><span class="hljs-comment">// 创建一个与 PipedOutputStream 连接的 PipedInputStream，并指定管道缓冲区的大小。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedInputStream</span><span class="hljs-params">(PipedOutputStream src, <span class="hljs-keyword">int</span> pipeSize)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    initPipe(pipeSize);<br>    connect(src);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-常用方法"><a href="#4-1-2-常用方法" class="headerlink" title="4.1.2 常用方法"></a>4.1.2 常用方法</h4><p><code>connect(PipedOutputStream src)</code>：连接一个 PipedOutputStream 对象。</p><p><code>int read()</code>：从管道缓冲区中读取一个字节，并把这个值字节以 0 到 255 范围内的 in t形式返回。 此方法会阻塞，直到输入数据可用、检测到流结束或抛出异常为止。</p><p><code>int read(byte b[], int off, int len)</code>：将管道缓冲区里的数据读入到 b[ ] 的指定部分，并返回实际读入字节的个数。如果由达到流的末尾，则返回 -1 。此方法会阻塞，直到至少有一个输入字符可用。</p><p><code>int available()</code>：返回可以在不阻塞的情况下从此输入流读取的字节数。</p><p><code>public void close()</code>：关闭流。</p><br/><h3 id="4-2-PipedOutputStream"><a href="#4-2-PipedOutputStream" class="headerlink" title="4.2 PipedOutputStream"></a>4.2 PipedOutputStream</h3><h4 id="4-2-1-构造器"><a href="#4-2-1-构造器" class="headerlink" title="4.2.1 构造器"></a>4.2.1 构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个与 PipedInputStream 连接的 PipedOutputStream。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedOutputStream</span><span class="hljs-params">(PipedInputStream snk)</span>  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>  connect(snk);<br>&#125;<br><br><span class="hljs-comment">//创建一个未连接的 PipedOutputStream。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PipedOutputStream</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="4-2-2-常用方法"><a href="#4-2-2-常用方法" class="headerlink" title="4.2.2 常用方法"></a>4.2.2 常用方法</h4><p><code>write(int b)</code>：将指定的byte写入管道输出流。</p><p><code>oid write(byte b[], int off, int len) </code>：将指定字节数组中的len个字节从偏移量off开始写入此管道输出流。 此方法阻塞，直到所有字节都写入输出流。</p><p><code>void flush()</code>：刷新此输出流并强制写出任何缓冲的输出字节。 </p><br/><h3 id="4-3-使用"><a href="#4-3-使用" class="headerlink" title="4.3 使用"></a>4.3 使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pipe</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        PipedInputStream input = <span class="hljs-keyword">new</span> PipedInputStream();<br>        PipedOutputStream output = <span class="hljs-keyword">new</span> PipedOutputStream(input);<br><br><br>        WriteThread t1 = <span class="hljs-keyword">new</span> WriteThread(output);<br>        ReadThread t2 = <span class="hljs-keyword">new</span> ReadThread(input);<br><br>        t1.start();<br>        t2.start();<br>        t1.join();<br>        t2.join();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    PipedOutputStream output;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WriteThread</span><span class="hljs-params">(PipedOutputStream output)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.output = output;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-string">&quot;helloWorld&quot;</span>.getBytes();<br>        <span class="hljs-keyword">try</span> &#123;<br>            output.write(bytes, <span class="hljs-number">0</span>, bytes.length);<br>            output.flush();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (output != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    output.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    PipedInputStream input;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadThread</span><span class="hljs-params">(PipedInputStream input)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.input = input;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">16</span>];<br>        <span class="hljs-keyword">int</span> data = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> ((data = input.read()) != -<span class="hljs-number">1</span>)&#123;<br>                System.out.write(data);<br>                System.out.flush();<br>            &#125;<br>            System.out.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    input.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO 流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO 流（一）流的基本概念</title>
    <link href="/2021/06/28/CoreJava/26.%20IO%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/06/28/CoreJava/26.%20IO%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>流的基本概念和分类。</p><span id="more"></span><h2 id="1-流的概念"><a href="#1-流的概念" class="headerlink" title="1. 流的概念"></a>1. 流的概念</h2><p>在计算机中，流是个抽象的概念，是<strong>对输入输出设备的抽象</strong>。在 Java 程序中，对于数据的输入/输 出操作，都是以 “流” 的方式进行。</p><br/><p><strong>流具有方向性，可以分为输入和输出。</strong>数据以二进制的形式在程序与设备之间流动传输，就像水在管道里流动一样，所以就把这种数据传输的方式称之为输入流、输出流。这里描述的设备，可以是文件、网络、内存等。</p><br/><h2 id="2-流的分类"><a href="#2-流的分类" class="headerlink" title="2. 流的分类"></a>2. 流的分类</h2><p>Java 中的 IO 流可以根据很多不同的角度进行划分，最常见的是以数据的流向和数据的类型来划分。</p><br/><p>根据数据的流向分为：输入流和输出流。</p><ul><li>输入流 ：把数据从其他设备上读取到程序中的流。</li><li>输出流 ：把数据从程序中写出到其他设备上的流。</li></ul><br/><p>根据数据的类型分为：字节流和字符流 </p><ul><li>字节流 ：以字节为单位（byte），读写数据的流。</li><li>字符流 ：以字符为单位（char），读写数据的流。</li></ul><br/><h2 id="3-流的结构"><a href="#3-流的结构" class="headerlink" title="3. 流的结构"></a>3. 流的结构</h2><p>在 Java 中，和 IO 流相关的类，主要是在 <code>java.io</code> 包下的定义的。</p><p>几乎所有的流，都是派生自四个抽象的父类型： </p><ul><li>InputStream：代表字节输入流类型。</li><li>OutputStream：代表字节输出流类型。</li><li>Reader：代表字符输入流类型。 </li><li>Writer：代表字符输出流类型。</li></ul><p><img src="D:\Users\MaxSeal\Desktop\杰普实训\corejava\笔记\图片\IO流.png"></p><br/><h2 id="4-流的特点"><a href="#4-流的特点" class="headerlink" title="4. 流的特点"></a>4. 流的特点</h2><p>一般情况下，一个流会具备最起码的三个特点： </p><ul><li>方向：输入还是输出。</li><li>读写的类型：字节还是字符。 </li><li>流的目的地： 如果是输入流，就表示这个流从什么地方读数据。如果是输出流，就表示这个流把数据写到什么地方。</li></ul><br/><p>例如：InputStream 是所有字节输入流的抽象父类型。那么它的子类型一定是以字节的方式，从某个地方把数据读取到程序中。只是不同的子类型，它们的目的地不一样，并且一般可以通过子类型的名字看出它的的目的地是哪里。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO 流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程（四）线程的同步和通信</title>
    <link href="/2021/06/24/CoreJava/25.%20%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2021/06/24/CoreJava/25.%20%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>java 中的线程安全和 synchronized 的使用</p><span id="more"></span><h2 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h2><p>JVM 内存中的堆区，是一个共享的区域，是所有线程都可以访问的内存空间。</p><p>JVM 内存中的栈区，是线程的私有空间，每个线程都有自己的栈区，别的线程无法访问到自己栈区的数据。</p><br/><p>如果两个线程 t1 和 t2，同时也访问堆区中的 MyDate 对象中的 num 属性值，结果可能和预期的不一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    MyData myData = <span class="hljs-keyword">new</span> MyData();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-comment">//先给num赋值</span><br>          myData.num = i;<br>          <span class="hljs-comment">//然后再输出num的值</span><br>          System.out.println(name + <span class="hljs-string">&quot;: &quot;</span> + myData.num);<br>        &#125;<br>      &#125;<br>    &#125;;<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;<br>          <span class="hljs-comment">//给num赋值</span><br>          myData.num = i;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    t1.start();<br>    t2.start();<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span></span>&#123;<br>  <span class="hljs-keyword">int</span> num;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>t1: <span class="hljs-number">0</span><br>t1: <span class="hljs-number">11706</span><br>t1: <span class="hljs-number">13766</span><br>t1: <span class="hljs-number">15459</span><br>t1: <span class="hljs-number">17710</span><br>t1: <span class="hljs-number">19304</span><br>t1: <span class="hljs-number">6</span><br>t1: <span class="hljs-number">7</span><br>t1: <span class="hljs-number">8</span><br>t1: <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><br/><p>此时的内存图为：</p><p><img src="C:\Users\MaxSeal\AppData\Roaming\Typora\typora-user-images\image-20210624112522407.png" alt="image-20210624112522407"></p><p>t1 和 t2 并发访问的时候，争夺 CPU 的时间片，运行完时间片，退出后再次争夺下一个时间片，也就是说 t1 和 t2 都是 “断断续续” 的运行的。</p><p>在这期间，可能 t1 线程有一次拿到时间片运行的时候，给 num 赋值为1，然后时间片用完退出 了。结果下次 t2 线程拿到了时间片，又将 num 的值赋成了11750，然后 t1 线程又拿到了时间片，本来预期的是输出1，但是结果却是输出了 11750。</p><p>核心的原因是，t1 线程操作一下变量 num，然后时间片用完退出去，t2 先过来又操作了变量 num， 等t1线程再过来的时候，这值已经被 t2 线程给 “偷偷” 修改了，那么就出现了和预期不符的情况。</p><br/><p>如果有多个线程，它们在一段时间内，并发访问堆区中的同一个变量，并且有写入的操作，那么最终可能会出数据的结果和预期不符的情况，这种情况就是线程安全问题。 </p><p>我们经常会进行这样的描述：这段代码是线程安全的，那段代码是非线程安全的。 其实就是在说，这段代码在多线程并发访问的环境中，是否会出现上述情况，也就是结果和预期不符的情况。</p><br/><h2 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2. 线程同步"></a>2. 线程同步</h2><p>Java 中提供了线程同步的机制，即给需要同步的代码进行 synchronized 关键字加锁，来解决上述的线程安全问题。</p><h3 id="2-1-synchronized-修饰代码块"><a href="#2-1-synchronized-修饰代码块" class="headerlink" title="2.1 synchronized 修饰代码块"></a>2.1 synchronized 修饰代码块</h3><p>synchronized 修饰代码块的使用格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (锁对象)&#123;<br>    <span class="hljs-comment">//操作共享变量的代码，这些代码需要线程同步，否则会有线程安全问题</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><p>修改上个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    MyData myData = <span class="hljs-keyword">new</span> MyData();<br>    <br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">synchronized</span> (myData)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            myData.num = i;<br>            System.out.println(name + <span class="hljs-string">&quot;: &quot;</span> + myData.num);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (myData)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">20000</span>; i++) &#123;<br>            myData.num = i;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <br>    t1.start();<br>    t2.start();<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span></span>&#123;<br>  <span class="hljs-keyword">int</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在运行这个程序，每次输出的结果都是和预期的一样：t1 线程每次输出的值都是 0~9。</p><br/><p>对应这样加锁的代码，如果两个线程进行并发访问的话： </p><ul><li>假设线程 t1 是第一个这段代码的线程，那么它会率先拿到这把锁，其实就是在这个锁对象中写入自己线程的信息，相当于告诉其他线程，这把锁现在是我的，你们都不能使用。</li><li>这时候 t1 线程拿着锁，就可以进入到加锁的代码块中，去执行代码，执行很短的一个时间片，然后退出，但是锁并不释放，也就意味着，即使下次是 t2 线程抢到 CPU 的使用权，它也无法运行代码， 因为 t2 没有拿到锁。 </li><li>就这样，t1 线程开心的拿着锁，抢到 CPU 的执行权，抢到了就去执行，抢不到也不用担心，因为没有其他线程可以 “偷偷” 的执行这段代码，因为其他线程拿不到锁。 </li><li>而对于 t2 线程来说，即使有一次抢到了 CPU 执行权，来到了代码面前，要执行的时候才发现，锁被  t1 线程拿走了，自己无法进入代码块中执行，这时候 t2 线程就会从运行状态进入阻塞状态，直到 t1 运行完，把锁释放了，t2 线程才会恢复到 RUNNABLE 状态，抢到 CPU 执行权，再拿到锁，然后进入代码块中执行。</li></ul><br/><h3 id="2-2-synchronized-修饰方法"><a href="#2-2-synchronized-修饰方法" class="headerlink" title="2.2  synchronized 修饰方法"></a>2.2  synchronized 修饰方法</h3><p>synchronized 关键字修饰非静态方法，默认使用 this 当做锁对象，并且不能自己另外指定。synchronized 关键字修饰静态方法，默认使用 当前类的 Class对象 当做锁对象，并且不能自己另外指定。</p><p>这俩中情况的同步效果是一样的，只是锁对象不同而已。</p><br/><p>例：对 MyDate 类中的 add 方法添加 synchronized。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyData</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">20</span>];<br>  <br>  <span class="hljs-comment">//当前数据可以存放的位置,也表示当前存放的元素个数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> current;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    String name = Thread.currentThread().getName();<br>    arr[current] = num;<br>    System.out.println(name+<span class="hljs-string">&quot;线程本次写入的值为&quot;</span>+num+<span class="hljs-string">&quot;，写入后值为&quot;</span>+arr[current]);<br>    current++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码表示，拿到锁对象 this 的线程，才可以进入到 add 方法中执行代码。代码执行完，会释放 锁。这时锁变的可用了，所有需要这把锁的线程都恢复到 RUNABLE 状态（它们之前在锁阻塞状态）。这些线程一起重新争夺 CPU 执行权，谁先拿到 CPU 执行权，就会先过去拿到锁，进入代码去执行。</p><p>线程同步的效果的关键点在于，让 t1 和 t2 两线程去争夺同一把锁对象。</p><br/><h2 id="3-线程通信"><a href="#3-线程通信" class="headerlink" title="3. 线程通信"></a>3. 线程通信</h2><h3 id="3-1-synchronized-的缺点"><a href="#3-1-synchronized-的缺点" class="headerlink" title="3.1 synchronized 的缺点"></a>3.1 synchronized 的缺点</h3><p>synchronized 关键字，虽然可以达到线程同步的效果，但是太 “霸道” 了。只要一个线程拿到了锁对象，那么这个线程无论是在运行状态，还是时间片用完，回到就绪状态，还是 sleep 休眠，这个线程都是死死的拿着这个锁对象不释放。只有这个线程把线程同步的代码执行完，才会释放锁对象让别的线程使用。</p><p>那么有没有一个方法，可以让拿到的锁的线程，即使代码没执行完，也可以把锁立即给释放了呢？ 有的，这个就是 wait 方法。</p><br/><h3 id="3-2-wait-方法和-notify-方法"><a href="#3-2-wait-方法和-notify-方法" class="headerlink" title="3.2 wait  方法和 notify 方法"></a>3.2 wait  方法和 notify 方法</h3><p>Object类中有三个方法： wait()、notify()、notifyAll()</p><p>当一个对象，在线程同步的代码中，充当锁对象的时候，在 synchronized 同步的代码块中，就可以调用这个锁对象的这三个方法了。</p><ul><li>任何对象中都一定有这三个方法。</li><li>只有对象作为锁对象的时候，才可以调用。 </li><li>只有在同步的代码块中，才可以调用。</li><li>其他情况下，调用一个对象的这三个方法，都会报错。</li></ul><br/><p>例：t1 和 t2 俩个线程，争夺同一把锁对象 obj。程序的运行结果是：要么 t1 先拿到锁输出 0 ~ 9，然后 t2 再拿到锁输出10 ~ 19，要么就是 t2 先拿到锁输入10 ~ 19，然后 t1 再拿到锁输出 0 ~ 9。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;线程: i = &quot;</span>+i);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>; j &lt; <span class="hljs-number">20</span>; j++) &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;线程: j = &quot;</span>+j);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    t1.start();<br>    t2.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>现在，我们希望的是 t1 线程中 i=5 的时候，先释放锁，让 t2 拿到锁去运行。在 t2 线程中，当 j=15的时候，释放锁，让 t1 拿到锁去运行。在 run 方法中加入 wait() 的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br>    <br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;线程: i = &quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)&#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//obj是锁对象，在同步代码块中，可以调用wait方法</span><br>                <span class="hljs-comment">//让当前拿到锁的线程，立即释放锁</span><br>                obj.wait();<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>              &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>; j &lt; <span class="hljs-number">20</span>; j++) &#123;<br>              System.out.println(name+<span class="hljs-string">&quot;线程: j = &quot;</span>+j);<br>                  <span class="hljs-keyword">if</span>(j==<span class="hljs-number">15</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-comment">//obj是锁对象，在同步代码块中，可以调用wait方法</span><br>                      <span class="hljs-comment">//让当前拿到锁的线程，立即释放锁</span><br>                      obj.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                      e.printStackTrace();<br>                    &#125;<br>                  &#125;<br>          &#125;<br>         &#125;<br>        &#125;<br>    &#125;;<br>    t1.start();<br>    t2.start();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>t1线程: i = <span class="hljs-number">0</span><br>t1线程: i = <span class="hljs-number">1</span><br>t1线程: i = <span class="hljs-number">2</span><br>t1线程: i = <span class="hljs-number">3</span><br>t1线程: i = <span class="hljs-number">4</span><br>t1线程: i = <span class="hljs-number">5</span><br>t2线程: j = <span class="hljs-number">10</span><br>t2线程: j = <span class="hljs-number">11</span><br>t2线程: j = <span class="hljs-number">12</span><br>t2线程: j = <span class="hljs-number">13</span><br>t2线程: j = <span class="hljs-number">14</span><br>t2线程: j = <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>可以看到，t1 线程和 t2 线程都没有运行完，但是代码不运行了，JVM 也没停住。</p><p>这是因为，当前调用锁对象的 wait 方法后，当前线程释放锁，然后进入到阻塞状态，并且等待其他线程先唤醒自己，如果没有其他线程唤醒自己，那么就一直等着。所以现在的情况是，两个线程t1 和 t2 都是在处于阻塞状态，等待别人唤醒自己，所以程序不运行了，但是也没结束。</p><br/><p>修改代码，加入 notify 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object obj = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;线程: i = &quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)&#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//在释放锁对象之前，叫醒等待池中等待obj锁对象的线程</span><br>                <span class="hljs-comment">//意思是告诉对方，我要释放锁了，你准备去抢把</span><br>                obj.notify();<br>                obj.wait();<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>              &#125;<br>            &#125;<br>          &#125;<br>          <span class="hljs-comment">//最后在执行完所有代码之前，再叫醒一次，防止等待池中还有其他线程在等待</span><br>          obj这个锁对象<br>            obj.notify();<br>        &#125;<br>      &#125;<br>    &#125;;<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">10</span>; j &lt; <span class="hljs-number">20</span>; j++) &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;线程: j = &quot;</span>+j);<br>            <span class="hljs-keyword">if</span>(j==<span class="hljs-number">15</span>)&#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//在释放锁对象之前，叫醒等待池中等待obj锁对象的线程</span><br>                <span class="hljs-comment">//意思是告诉对方，我要释放锁了，你准备去抢把</span><br>                obj.notify();<br>                obj.wait();<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>              &#125;<br>            &#125;<br>          &#125;<br>          <span class="hljs-comment">//最后在执行完所有代码之前，在叫醒一次，防止等待池中还线程在等待obj这个锁对象</span><br>          obj.notify();<br>        &#125;<br>      &#125;<br>    &#125;;<br>    t1.start();<br>    t2.start();<br>    <span class="hljs-comment">//主线程休眠1秒钟，给t1和t2点时间，等它们调用wait方法</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;t1线程当前的状态为：&quot;</span>+t1.getState());<br>    System.out.println(<span class="hljs-string">&quot;t2线程当前的状态为：&quot;</span>+t2.getState());<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>t1线程: i = <span class="hljs-number">0</span><br>t1线程: i = <span class="hljs-number">1</span><br>t1线程: i = <span class="hljs-number">2</span><br>t1线程: i = <span class="hljs-number">3</span><br>t1线程: i = <span class="hljs-number">4</span><br>t1线程: i = <span class="hljs-number">5</span><br>t2线程: j = <span class="hljs-number">10</span><br>t2线程: j = <span class="hljs-number">11</span><br>t2线程: j = <span class="hljs-number">12</span><br>t2线程: j = <span class="hljs-number">13</span><br>t2线程: j = <span class="hljs-number">14</span><br>t2线程: j = <span class="hljs-number">15</span><br>t1线程: i = <span class="hljs-number">6</span><br>t1线程: i = <span class="hljs-number">7</span><br>t1线程: i = <span class="hljs-number">8</span><br>t1线程: i = <span class="hljs-number">9</span><br>t2线程: j = <span class="hljs-number">16</span><br>t2线程: j = <span class="hljs-number">17</span><br>t2线程: j = <span class="hljs-number">18</span><br>t2线程: j = <span class="hljs-number">19</span><br>t1线程当前的状态为：TERMINATED<br>t2线程当前的状态为：TERMINATED<br></code></pre></td></tr></table></figure><p>可以看到，此时 t1 和 t2 俩个线程都执行完了，打印输出的结果也符合我们的预期。</p><br/><p>notify()：该方法可以在等待池中，随机唤醒一个等待指定锁对象的线程，使得这个线程进入到锁池中，而进入到锁池的线程， 一旦发现锁可用，就可以自动恢复到 RUNNABLE 状态了。</p><p>notifyAll()：该方法可以在等待池中，唤醒所有等待指定锁对象的线程，使得这个线程进入到锁池中，而进入到锁池的线程， 一旦发现锁可用，就可以自动恢复到 RUNNABLE 状态了。</p><h2 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4. 死锁"></a>4. 死锁</h2><p>简单的描述死锁就是：俩个线程 t1 和 t2，t1 拿着 t2 需要等待的锁不释放，而 t2 又拿着 t1 需要等待的锁不释放，两个线程就这样一直僵持下去。</p><p>在程序中要尽量避免出现死锁情况，一旦发生那么只能手动停止 JVM 的运行，然后查找并修改产生死锁的问题代码。可以通过 jconsole 查看到线程死锁的情况。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDeadLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>  <span class="hljs-keyword">private</span> Object obj1;<br>  <span class="hljs-keyword">private</span> Object obj2;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadDeadLock</span><span class="hljs-params">(Object obj1,Object obj2)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.obj1 = obj1;<br>    <span class="hljs-keyword">this</span>.obj2 = obj2;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    String name = Thread.currentThread().getName();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;Thread-0&quot;</span>.equals(name))&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj1) &#123;<br>          <span class="hljs-keyword">synchronized</span> (obj2) &#123;<br>            System.out.println(name+<span class="hljs-string">&quot; 运行了..&quot;</span>);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj2) &#123;<br>          <span class="hljs-keyword">synchronized</span> (obj1) &#123;<br>            System.out.println(name+<span class="hljs-string">&quot; 运行了..&quot;</span>);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Object obj1 = <span class="hljs-keyword">new</span> Object();<br>    Object obj2 = <span class="hljs-keyword">new</span> Object();<br>    Thread t1 = <span class="hljs-keyword">new</span> ThreadDeadLock(obj1,obj2);<br>    Thread t2 = <span class="hljs-keyword">new</span> ThreadDeadLock(obj1,obj2);<br>    t1.start();<br>    t2.start();<br>  &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程（三）线程的状态</title>
    <link href="/2021/06/23/CoreJava/24.%20%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <url>/2021/06/23/CoreJava/24.%20%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>java 中的线程状态和转换。</p><span id="more"></span><h2 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1. 线程的状态"></a>1. 线程的状态</h2><p><code>java.lang.Thread.State </code>枚举类型中（内部类形式），定义了线程的几种状态，其代码结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> threadStatus = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">State</span> </span>&#123;<br>        NEW,<br>        RUNNABLE,<br>        WAITING,<br>        TIMED_WAITING,<br>      TERMINATED;<br>    &#125;<br><br>    <span class="hljs-comment">//返回这个线程当前所处的状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> sun.misc.VM.toThreadState(threadStatus);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>状态转化图：</p><p><img src="https://i.loli.net/2021/06/23/DOiuZyTF9Ibdh2U.png" alt="线程状态图.jpg"></p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>NEW</td><td>线程刚被创建，还没调用 start 方法，或者刚刚调用了 start 方法。调用 start 方法不一定 “立即” 改变线程状态，中间可能需要一些步骤才完成一个线程的启动。</td></tr><tr><td>RUNNABLE</td><td>start 方法调用结束，线程由 NEW 变成 RUNNABLE。线程存活着，并尝试抢占 CPU 资源，或者已经抢占到 CPU 资源正在运行，这俩种情况的状态都显示为 RUNNABLE 。</td></tr><tr><td>BLOCKED</td><td>线程 A 和线程 B 都要执行方法 test，而且方法 test 被加了锁，线程 A 先拿到了锁去执行 test 方法，线程 B这时候需要等待线程 A 把锁释放。这时候线程 B 就是处理 BLOCKED。</td></tr><tr><td>WAITING</td><td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入 Waiting 状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用 notify 或者 notifyAll 方法才能够唤醒。</td></tr><tr><td>TIMED_WAITING</td><td>和 WAITING 状态类似，但是有一个时间期限，时间到了，自己也会主动醒来。</td></tr><tr><td>TERMINATED</td><td>run 方法执行结束的线程处于这种状态。</td></tr></tbody></table><p>其实 BLOCKED，WAITING，TIMED_WAITING 这三种都属于线程阻塞，只是触发的条件不同， 以及从阻塞状态中恢复过来的条件也不同而已。</p><p>线程在这三种情况的阻塞下，都具备相同的特点：</p><ul><li><p>线程不执行代码。</p></li><li><p>线程也不参与CPU时间片的争夺。</p></li></ul><br/><h2 id="2-一个线程经历的最普通的过程"><a href="#2-一个线程经历的最普通的过程" class="headerlink" title="2.  一个线程经历的最普通的过程"></a>2.  一个线程经历的最普通的过程</h2><p>NEW ——&gt; RUNNABLE ——&gt; RUNNING ——&gt; TERMINATED 这就是一个线程经历的最基本的状态变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        &#125;<br>      &#125;<br>    &#125;;<br>    System.out.println(t1.getState());<br>    <span class="hljs-comment">//启动t1线程</span><br>    t1.start();<br>    System.out.println(t1.getState());<br>    System.out.println(t1.getState());<br>    System.out.println(t1.getState());<br>    System.out.println(t1.getState());<br>    System.out.println(t1.getState());<br>    System.out.println(t1.getState());<br>    System.out.println(t1.getState());<br>    System.out.println(t1.getState());<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果： 注意需要多运行几次，因为可能每次运行的情况不一样</span><br>NEW<br>RUNNABLE<br>RUNNABLE<br>RUNNABLE<br>RUNNABLE<br>RUNNABLE<br>RUNNABLE<br>TERMINATED<br>TERMINATED<br></code></pre></td></tr></table></figure><ul><li><p>刚创建好的线程对象，是处于 NEW 状态。</p><br/></li><li><p>线程启动后，会处于 RUNNABLE 状态。其实这个 RUNNABLE 状态包含俩种情况： </p><ul><li><p>就绪状态，此时这个线程没有运行，因为没有抢到CPU的执行权。</p></li><li><p>运行状态，此时这个线程正在运行中，因为抢到CPU的执行权。</p></li></ul><br/></li><li><p>JavaAPI 中并没有定义就绪状态和运行状态，而是把这俩情况统一叫做RUNNABLE（可运行状态），但是一般我们为了能更加清楚的描述问题，会用上就绪状态和运行状态。</p><br/></li><li><p>从就绪状态到运行状态，之间会经过多次反复的CPU执行权的争夺（线程调度）。</p><br/></li><li><p>在线程多次抢到 CPU 执行权，“断断续续” 把 run 方法执行完之后，就变成了 TERMINATED 状态，之所以是 “断断续续” 的运行，是因为每次抢到 CPU 执行权的时候，只是运行很小的一个时间片， 完了之后还要重新抢夺下一个时间片，并且中间还有可能抢不到的情况。</p><br/></li><li><p>死亡后的线程，不能重新启动。</p></li></ul><br/><h2 id="3-Sleep-方法"><a href="#3-Sleep-方法" class="headerlink" title="3. Sleep 方法"></a>3. Sleep 方法</h2><p>线程类 Thread 中的 sleep 方法：该静态方法可以让当前执行的线程暂时休眠指定的毫秒数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//t1线程休眠10毫秒</span><br>          Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">//t1还没有启动，这里肯定是NEW状态</span><br>    System.out.println(t1.getState());<br>    <span class="hljs-comment">//启动t1线程</span><br>    t1.start();<br>    <span class="hljs-comment">//在循环期间查看t1的状态1000次</span><br>    <span class="hljs-comment">//这里t1的状态可能是RUNNABLE，也可能是TIMED_WAITING，也可能是TERMINATED</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>      System.out.println(t1.getState());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，线程执行了 sleep 方法后，会从 RUNNABLE 状态进入到 TIMED_WAITING 状态。这时候线程所处的是一种阻塞状态，是之前介绍过的三种阻塞情况的其中一种。这种阻塞的特点是：阻塞结束后，线程会自动回到 RUNNABLE 状态。</p><br/><h2 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="3. join 方法"></a>3. join 方法</h2><p>线程类 Thread 中的 join 方法：使用 join 方法，可以让当前线程阻塞，等待另一个指定的线程运行结束后，当前线程才可以继续运行。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span><span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="3-1-使用无参的-join-方法"><a href="#3-1-使用无参的-join-方法" class="headerlink" title="3.1 使用无参的 join 方法"></a>3.1 使用无参的 join 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//t1线程睡眠1秒钟</span><br>          Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>      &#125;<br>    &#125;;<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//t2线程调用t1.join方法</span><br>          <span class="hljs-comment">//t2线程进入阻塞状态</span><br>          <span class="hljs-comment">//t2线程要等到t1线程运行结束，才能恢复到RUNNABLE状态</span><br>          t1.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t2线程结束&quot;</span>);<br>      &#125;<br>    &#125;;<br>    t1.start();<br>    t2.start();<br>    <span class="hljs-comment">//让主线程休眠500毫秒，目的是为了给t1和t2点时间，让他们俩个线程进入状态</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">500</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    System.out.println(t2.getState());<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>WAITING<br>t1线程结束<br>t2线程结束<br></code></pre></td></tr></table></figure><p>t2 线程中，调用了 t1 对象的 join 方法，那么 t2 线程就会阻塞，等待 t1 线程的运行结束，t2 线程才能恢复。可以看出，线程执行了 join() 方法后，会从 RUNNABLE 状态进入到 WAITING 状态。</p><br/><h3 id="3-2-使用有参的-join-方法"><a href="#3-2-使用有参的-join-方法" class="headerlink" title="3.2 使用有参的 join 方法"></a>3.2 使用有参的 join 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//t1线程睡眠1秒钟</span><br>          Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>      &#125;<br>    &#125;;<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//t2线程调用t1.join方法</span><br>          <span class="hljs-comment">//t2线程进入阻塞状态</span><br>          <span class="hljs-comment">//t2线程要等到t1线程运行结束，才能恢复到RUNNABLE状态</span><br>          <span class="hljs-comment">//2000表示，当前线程t2最多阻塞2秒钟，2秒钟之内t1线程没有结束，那么t2线程就自动恢复</span><br>            t1.join(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t2线程结束&quot;</span>);<br>      &#125;<br>    &#125;;<br>    t1.start();<br>    t2.start();<br>    <span class="hljs-comment">//让主线程休眠500毫秒，目的是为了给t1和t2点时间，让他们俩个线程进入状态</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">500</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    System.out.println(t2.getState());<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>TIMED_WAITING<br>t1线程结束<br>t2线程结束<br></code></pre></td></tr></table></figure><p><code>t1.join(2000);</code>并不意味这 t1 马上执行，t1 还需要和其他线程抢占 CPU。可以看出，线程执行了 join(long million) 方法后，会从 RUNNABLE 状态进入到TIMED_WAITING 状态。</p><br/><h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><ul><li><p>如果指定了时间（有参 join），线程阻塞一定的时间后，会自动恢复到 RUNNABLE 状态，这种情况下，<strong>线程的状态为 TIMED_WAITING</strong>（有限期等待）。</p><br/></li><li><p>如果没有指定时间（无参 join），线程会一直阻塞着，直到某个条件满足时，才会自动恢复，这种情况下，<strong>线程的状态为 WAITING</strong>（无限期等待）。</p></li></ul><br/><h2 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="4. interrupt 方法"></a>4. interrupt 方法</h2><p>线程类 Thread 中的 interrupt 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Interrupts this thread</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面介绍 sleep 方法和 join 方法可知，这俩个方法都会抛出 InterruptedException 类型的异 常，说明调用 sleep 和 join 使线程进入阻塞状态的情况下，是有可能抛出 InterruptedException 类型的异常的。</p><br/><p>InterruptedException 异常类型指的是：线程 A 中，调用了线程 B 的 interrupt 方法，而此时线程B 处于阻塞状态，那么此时 sleep 方法或者 join 方法就会抛出被打断的异常。</p><br/><h3 id="4-1-使用-interrupt-方法"><a href="#4-1-使用-interrupt-方法" class="headerlink" title="4.1 使用 interrupt 方法"></a>4.1 使用 interrupt 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//t1线程休眠100秒</span><br>          Thread.sleep(<span class="hljs-number">100000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>      &#125;<br>    &#125;;<br>    t1.start();<br>    <span class="hljs-comment">//让主线程休眠500毫秒，目的是为了给t1时间，让它调用sleep方法而进入阻塞状态</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">500</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">//打断t1由于调用sleep方法而进入的阻塞状态</span><br>    t1.interrupt();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>java.lang.InterruptedException: sleep interrupted<br>at java.lang.Thread.sleep(Native Method)<br>at com.briup.sync.Test$<span class="hljs-number">1.</span>run(Test.java:<span class="hljs-number">11</span>)<br>t1线程结束<br></code></pre></td></tr></table></figure><p>可以看出，本来 t1 线程调用了 sleep 方法进入了阻塞状态，需要100后才会恢复的。但是我们在主线程中调用了 t1 线程对象的打断方法 interrupt 。那么此时 <code>Thread.sleep(100000); </code>这句代码就 会抛出被打断的异常，同时 t1 线程从阻塞状态恢复到 RUNNABL 状态，继续执行代码，输出了 t1 线程结束。</p><br/><h3 id="4-2-interrupt-方法的工作原理"><a href="#4-2-interrupt-方法的工作原理" class="headerlink" title="4.2 interrupt 方法的工作原理"></a>4.2 interrupt 方法的工作原理</h3><p>从Thread类的源码中可以看到： interrupt 方法中其实是调用了 interrupt0 这个本地方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != Thread.currentThread())<br>    checkAccess();<br>  <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br>    Interruptible b = blocker;<br>    <span class="hljs-keyword">if</span> (b != <span class="hljs-keyword">null</span>) &#123;<br>      interrupt0(); <span class="hljs-comment">// Just to set the interrupt flag</span><br>      b.interrupt(<span class="hljs-keyword">this</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  interrupt0();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt0</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>interrupt 方法是通过改变线程对象中的一个标识的值（true|false），来达到打断阻塞状态的效果。一个线程在阻塞状态下，会时刻监测这个标识的值是不是 true，如果一旦发现这个值变为 true，那么就抛出异常结束阻塞状态，并再把这个值改为 false。</p><br/><h3 id="4-3-isInterrupted-方法"><a href="#4-3-isInterrupted-方法" class="headerlink" title="4.3 isInterrupted 方法"></a>4.3 isInterrupted 方法</h3><p>线程类 Thread 中的 isInterrupted 方法：这个非静态方法，只是返回这个 “打断标识” 值，并且不会对这个值进行清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInterrupted</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> isInterrupted(<span class="hljs-keyword">false</span>);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Tests if some Thread has been interrupted. The interrupted state</span><br><span class="hljs-comment">* is reset or not based on the value of ClearInterrupted that is</span><br><span class="hljs-comment">* passed.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInterrupted</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> ClearInterrupted)</span></span>;<br><br></code></pre></td></tr></table></figure><br/><p>无论线程是否处于阻塞状态，其他线程都可以调用这个线程的 interrupt 方法，因为该方法只是改变线程对象中 “打断标识” 值而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-comment">//判断是否有其他线程调用了自己的interrupt方法</span><br>          <span class="hljs-comment">//调用类中的非静态方法：isInterrupted</span><br>          System.out.println(<span class="hljs-keyword">this</span>.isInterrupted());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>      &#125;<br>    &#125;;<br>    t1.start();<br>    t1.interrupt();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br>t1线程结束<br></code></pre></td></tr></table></figure><p>可以看出，吊用了 <code>t1.interrupt(); </code>后，t1 线程中的 “打断标识” 值设置为了 true，可以通过线程对象中的 isInterrupted 方法返回这个标识的值，并且不会修改这个值，所以输出显示的一直是 ture。</p><br/><h3 id="4-4-interrupted-方法"><a href="#4-4-interrupted-方法" class="headerlink" title="4.4 interrupted 方法"></a>4.4 interrupted 方法</h3><p>线程类 Thread 中的 interrupted 方法：这个静态方法，返回这个“打断标识”值，并且会对这个值进行清除（true-&gt;false）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1线程&quot;</span>)&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>          <span class="hljs-comment">//判断是否有其他线程调用了自己的interrupt方法</span><br>          <span class="hljs-comment">//调用类中的静态方法：interrupted</span><br>          System.out.println(Thread.interrupted());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1线程结束&quot;</span>);<br>      &#125;<br>    &#125;;<br>    t1.start();<br>    t1.interrupt();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br>t1线程结束<br></code></pre></td></tr></table></figure><p>可以看出，第一次返回 true 之后，后面在调用方法查看这个 “打断标识” 值，都是 false，因为静态方法 interrupted 返回 true 后，会直接把这个值给清除掉。（true-&gt;false）</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程（二）线程和线程组</title>
    <link href="/2021/06/23/CoreJava/23.%20%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%84/"/>
    <url>/2021/06/23/CoreJava/23.%20%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>在 java 中使用线程。</p><span id="more"></span><h2 id="1-线程的创建与启动"><a href="#1-线程的创建与启动" class="headerlink" title="1. 线程的创建与启动"></a>1. 线程的创建与启动</h2><p><code>java.lang.Thread</code> 是java中的线程类，所有的线程对象都必须是 Thread 类或其子类的实例。</p><p>每个线程的作用，就是完成我们给它指定的任务，实际上就是执行一段我们指定的代码。我们只需要在 Thread 类的子类中重写 run 方法，把执行的代码写入到 run 方法中即可，这就是线程的执行任务！ </p><p>当进行一些耗时的操作时，可以创建一个线程来执行这些操作，以提高效率。</p><br/><h3 id="1-1-通过继承-Thread-类创建线程"><a href="#1-1-通过继承-Thread-类创建线程" class="headerlink" title="1.1 通过继承  Thread  类创建线程"></a>1.1 通过继承  Thread  类创建线程</h3><p>Java中通过继承 Thread 类来创建并启动一个新的线程的步骤如下：</p><ol><li>定义 Thread 类的子类（可以是匿名内部类），并重写 Thread 类中的 run 方法， run 方法中的 代码就是线程的执行任务。</li><li>创建 Thread 子类的对象，这个对象就代表了一个要独立运行的新线程。</li><li>调用线程对象的 start 方法来启动该线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;新建了一个线程&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> CreateThread();<br>        t.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="1-2-通过实现-Runnable-接口创建线程"><a href="#1-2-通过实现-Runnable-接口创建线程" class="headerlink" title="1.2 通过实现 Runnable 接口创建线程"></a>1.2 通过实现 Runnable 接口创建线程</h3><p>除了继承 Thread 类后重写 run 方法之外，还可以利于 Runnable 接口来完成线程任务的指定。</p><p><code>java.lang.Runnable</code> 接口中只有一个抽象方法 run。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>其实 Thread 类也是 Runnable 接口的实现类，并且有通过 Runnable 对象创建对象的构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">publicclass Thread implements Runnable &#123;<br>  <span class="hljs-comment">//...</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, target, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>    &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CreateThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;创建一个线程。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Runnable runnable = <span class="hljs-keyword">new</span> CreateThread2();<br>        Thread t = <span class="hljs-keyword">new</span> Thread(runnable);<br>        t.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><p>实现 Runnable 接口比继承 Thread 类所具有的优势：</p><ol><li>可以把相同的一个执行任务（Runnable 接口的实现），交给不同的线程对象去执行。</li><li>可以避免 java 中的单继承的局限性。 </li><li>线程和执行代码各自独立，实现代码解耦</li></ol><br/><h3 id="1-3-run-方法与-strat-方法"><a href="#1-3-run-方法与-strat-方法" class="headerlink" title="1.3 run 方法与 strat 方法"></a>1.3 run 方法与 strat 方法</h3><p>Thread 类中的 start() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>    group.add(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        start0();<br>        started = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!started) &#123;<br>                group.threadStartFailed(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>            <span class="hljs-comment">/* do nothing. If start0 threw a Throwable then</span><br><span class="hljs-comment">              it will be passed up the call stack */</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>        target.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码可以看到 start 方法启动线程后，线程会自动执行 run 方法。 </p><p>千万不要直接调用 run 方法，这样就不是启动线程执行任务，而是普通的方法调用。</p><br/><h2 id="2-线程的名字"><a href="#2-线程的名字" class="headerlink" title="2.线程的名字"></a>2.线程的名字</h2><h3 id="2-1-指定线程的名字"><a href="#2-1-指定线程的名字" class="headerlink" title="2.1 指定线程的名字"></a>2.1 指定线程的名字</h3><p>在 Thread 类中有这样三个构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="hljs-number">0</span>);<br>   &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(String name)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, name, <span class="hljs-number">0</span>);<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target, String name)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, target, name, <span class="hljs-number">0</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>说明可以在创建线程的同时为线程指定一个名字。如果没有给线程命名，线程的默认名字是 Thread-x。</p><br/><h3 id="2-2-获取线程的名字"><a href="#2-2-获取线程的名字" class="headerlink" title="2.2 获取线程的名字"></a>2.2 获取线程的名字</h3><p>通过 Thread 类中的 currentThread 方法，可以获取当前线程的对象，然后调用线程对象的 getName 方法， 可以获取当前线程的名字。 注意，这里说的当前线程，指的是执行当前方法的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String name = Thread.currentThread().getName();<br>    System.out.println(<span class="hljs-string">&quot;执行当前main方法的线程是：&quot;</span>+name);<br><br>    Runnable run = <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            String name = Thread.currentThread().getName();<br>            System.out.println(<span class="hljs-string">&quot;执行当前run方法的线程是：&quot;</span>+name);<br>        &#125;<br>    &#125;;<br>  <br>  Thread t = <span class="hljs-keyword">new</span> Thread(run);<br>t.start();<br>&#125;<br>&#125;<br><span class="hljs-comment">//运行结果为：</span><br>执行当前main方法的线程是：main<br>执行当前run方法的线程是：Thread-<span class="hljs-number">0</span> <br><br></code></pre></td></tr></table></figure><br/><h2 id="3-main-线程"><a href="#3-main-线程" class="headerlink" title="3. main 线程"></a>3. main 线程</h2><p>使用 java 命令来运行一个类的时候，首先会启动 JVM（进程），JVM会在创建一个名字叫做 main 的线程，来执行类中的程序入口（main方法）。所以我们写在 main 方法中的代码，其实都是由名字叫做 main 的线程去执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取执行当前方法的线程对象</span><br>        Thread currentThread = Thread.currentThread();<br>        System.out.println(<span class="hljs-string">&quot;执行当前方法的线程名字为：&quot;</span>+currentThread.getName());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>执行当前方法的线程名字为：main<br></code></pre></td></tr></table></figure><img src="D:\Users\MaxSeal\Desktop\杰普实训\corejava\笔记\图片\main线程.png" style="zoom: 67%;" /><ol><li>使用 java 命令运行 Test 类，会先启动 JVM（启动进程）。 </li><li>应用类加载器通过 CLASSPATH 环境变量配置的路径，找到 Test.class 文件，并加载到方法区。 注意，这里会同时生产一个 Class 类型对象，来代表这个 Test 类型，并且会优先处理类中的静态代码（静态属性、静态方法、静态代码块） 。</li><li>JVM 创建并启动一个名字叫做 main 的线程。 </li><li>main 线程将 Test 中的 main 方法加载到栈区中。</li><li>在栈里面，main 线程就可以一行行的执行方法中的代码了 </li><li>如果在执行代码中，遇到了方法调用，那么线程会继续把被调用的方法，加载到栈中（压栈操作），然后执行栈顶这个最新添加进来的方法，栈顶方法执行完，就释放（出栈操作），然后在进行执行当前最新的栈顶方法。</li><li>代码执行过程输出执行结果 </li><li>当前是单线程程序，main 线程结束了，JVM 就停止了，如果是多线程程序，那么 JVM 要等所有线程都结束了才会停止。</li></ol><br/><h2 id="4-线程分类"><a href="#4-线程分类" class="headerlink" title="4. 线程分类"></a>4. 线程分类</h2><p>java 中，线程可以分为：</p><ul><li><p>前台线程，又叫做执行线程、用户线程：</p><ul><li>这种线程专门用来执行用户编写的代码，地位比较高。</li><li>JVM 是否会停止运行，就是要看当前是否还有前台线程没有执行完。</li></ul></li><li><p>后台线程，又叫做守护线程、精灵线程：</p><ul><li>这种线程是用来给前台线程服务的，给前台线程提供一个良好的运行环境，地位比较低。</li><li>JVM是否停止运行，根本不关心后台线程的运行情况和状态。</li></ul></li></ul><p>后台线程不一定比前台线程执行晚，主要看线程的优先级。</p><p>在主线程中，创建出来的线程对象，默认就是前台线程。在它启动之前，可以通过 <code>setDaemon(true)</code>方法把它设置为后台线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t线程&quot;</span>)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        String name = Thread.currentThread().getName();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(name+<span class="hljs-string">&quot;: hello &quot;</span>+i);<br>        &#125;<br>    &#125;<br>    &#125;;<br>  <br>    <span class="hljs-comment">//在启动线程之前，可以将其设置为后台线程，否则默认是前台线程</span><br>    t.setDaemon(<span class="hljs-keyword">true</span>);<br>    t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="5-线程的优先级"><a href="#5-线程的优先级" class="headerlink" title="5. 线程的优先级"></a>5. 线程的优先级</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_PRIORITY = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NORM_PRIORITY = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_PRIORITY = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>在 Thread 类的源码中，可以看到线程的优先级使用 int 类型数字表示，最大是10，最小是1，默认是5。</p><p>常用方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>setPriority()</code></td><td>设置优先级。</td></tr><tr><td><code>getPriority()</code></td><td>获取优先级。</td></tr></tbody></table><br/><p>当俩个线程争夺 CPU 的时候： </p><ul><li>优先级相同，获得CPU使用权的概率相同。</li><li>优先级不同，那么高优先级的线程<strong>有更高的概率</strong>获取到 CPU 的使用权。</li></ul><p>例如，t1 和 t2 线程各自运行10000次循环，看哪个线程先运行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t1线程&quot;</span>)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    String name = Thread.currentThread().getName();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    &#125;<br>    System.out.println(name+<span class="hljs-string">&quot;线程执行完毕&quot;</span>);<br>    &#125;<br>    &#125;;<br>  <br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">&quot;t2线程&quot;</span>)&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    String name = Thread.currentThread().getName();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    &#125;<br>    System.out.println(name+<span class="hljs-string">&quot;线程执行完毕&quot;</span>);<br>    &#125;<br>    &#125;;<br>  <br>    <span class="hljs-comment">// t1.setPriority(Thread.MAX_PRIORITY);</span><br>    <span class="hljs-comment">// t2.setPriority(Thread.MIN_PRIORITY);</span><br>    System.out.println(<span class="hljs-string">&quot;t1线程的优先级：&quot;</span>+t1.getPriority());<br>    System.out.println(<span class="hljs-string">&quot;t2线程的优先级：&quot;</span>+t2.getPriority());<br>    t1.start();<br>    t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，两个线程的优先级都是 5，那么两个线程争夺到 CPU 的使用权的概率一样。基本上俩个线程都有相同的概率先执行完。其实 t1 先稍微占了那么一点点的优势，因为毕竟在主线程的代码中，先启动了t1先，然后又启动了 t2。但是设置 t1 和 t2 优先级之后，在运行查看结果，会明显看到优先级高的线程，有更高的概率先执行完代码。</p><br/><h2 id="6-线程组"><a href="#6-线程组" class="headerlink" title="6. 线程组"></a>6. 线程组</h2><p>Java中使用 <code>java.lang.ThreadGroup</code> 类来表示线程组，它可以对一批线程进行管理，对线程组进行操作，同时也会对线程组里面的这一批线程操作。</p><br/><h3 id="6-1-创建线程组"><a href="#6-1-创建线程组" class="headerlink" title="6.1 创建线程组"></a>6.1 创建线程组</h3><p>查看 ThreadGroup 类的源码，可以发现有 2 个线程组构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个线程组，并指定一个名字。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadGroup</span><span class="hljs-params">(String name)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(Thread.currentThread().getThreadGroup(), name);<br>&#125;<br><br><span class="hljs-comment">//创建一个线程组，并指定一个名字，同时指定其父线程组。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadGroup</span><span class="hljs-params">(ThreadGroup parent, String name)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(checkParentAccess(parent), parent, name);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建线程组的时候，需要指定该线程组的名字。 </p><p>还可以指定其父线程组，如果没有指定，那么这个新创建的线程组的父线程组就是当前线程组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Thread t = <span class="hljs-keyword">new</span> Thread();<br>    ThreadGroup threadGroup = t.getThreadGroup();<br>    System.out.println(threadGroup);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>java.lang.ThreadGroup[name=main,maxpri=<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>只有在创建线程对象的时候，才能指定其所在的线程组，线程运行中途不能改变它所属的线程组。</p><br/><h3 id="6-2-常用方法"><a href="#6-2-常用方法" class="headerlink" title="6.2 常用方法"></a>6.2 常用方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>activeCount()</code></td><td>返回此线程组及其子组中活动线程数的估计。</td></tr><tr><td><code>activeGroupCount()</code></td><td>返回此线程组及其子组中活动组数的估计。</td></tr><tr><td><code>destroy()</code></td><td>销毁此线程组及其所有子组。</td></tr><tr><td><code>isDestroyed()</code></td><td>测试此线程组是否已被破坏。</td></tr><tr><td><code>checkAccess()</code></td><td>确定当前运行的线程是否有权限修改此线程组。</td></tr><tr><td><code>interrupt()</code></td><td>中断此线程组中的所有线程。</td></tr><tr><td><code>getMaxPriority()</code></td><td>返回此线程组的最大优先级。</td></tr><tr><td><code>setMaxPoriority(int pri)</code></td><td>设置组的最大优先级。</td></tr><tr><td><code>getName()</code></td><td>返回此线程组的名称。</td></tr><tr><td><code>getParent()</code></td><td>返回此线程组的父级。</td></tr><tr><td><code>parentOf(ThreadGroup g)</code></td><td>测试此线程组是线程组参数还是其祖先线程组之一。</td></tr><tr><td><code>setDaemon(boolean daemon)</code></td><td>更改此线程组的守护程序状态。</td></tr><tr><td><code>isDaemon()</code></td><td>测试此线程组是否是守护线程组。</td></tr><tr><td><code>list()</code></td><td>将有关此线程组的信息打印到标准输出。</td></tr><tr><td><code>toString()</code></td><td>返回此Thread组的字符串表示形式。</td></tr><tr><td><code>enumerate(Thread[] list)</code></td><td>将此线程组及其子组中的每个活动线程复制到指定的数组中。</td></tr><tr><td><code>enumerate(Thread[] list, boolean recurse)</code></td><td>将此线程组中的每个活动线程复制到指定的数组中。</td></tr><tr><td><code>enumerate(ThreadGroup[] list)</code></td><td>复制到该线程组及其子组中每个活动子组的指定数组引用。</td></tr><tr><td><code>enumerate(ThreadGroup[] list, boolean recurse)</code></td><td>复制到该线程组中每个活动子组的指定数组引用。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadGroup group = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">&quot;我的线程组&quot;</span>);<br>        Runnable run = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//让线程休眠一会，否则运行太快，死亡太快了</span><br>              Thread.sleep(<span class="hljs-number">10000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              e.printStackTrace();<br>            &#125;<br>            &#125;<br>        &#125;;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(group,run,<span class="hljs-string">&quot;t1线程&quot;</span>);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(group,run,<span class="hljs-string">&quot;t2线程&quot;</span>);<br>        Thread t3 = <span class="hljs-keyword">new</span> Thread(group,run,<span class="hljs-string">&quot;t3线程&quot;</span>);<br>        <span class="hljs-comment">//注意，启动后，三个线程都会进行休眠，等run方法运行完就“死亡”了</span><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        <span class="hljs-comment">//返回当前线程组中还没有“死亡”的线程个数</span><br>        System.out.println(<span class="hljs-string">&quot;线程组中还在存活的线程个数为：&quot;</span>+group.activeCount());<br>        <span class="hljs-comment">//准备好数组，保存线程组中还存活的线程</span><br>        Thread[] arr = <span class="hljs-keyword">new</span> Thread[group.activeCount()];<br>        <span class="hljs-comment">//将存活的线程集中存放到指定数组中，并返回本次存放到数组的存活线程个数</span><br>        System.out.println(<span class="hljs-string">&quot;arr数组中存放的线程个数为：&quot;</span>+group.enumerate(arr));<br>        <span class="hljs-comment">//输出数组中的内容</span><br>        System.out.println(<span class="hljs-string">&quot;arr数组中的内容为：&quot;</span>+Arrays.toString(arr));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>线程组中还在存活的线程个数为：<span class="hljs-number">3</span><br>arr数组中存放的线程个数为：<span class="hljs-number">3</span><br>arr数组中的内容为：[Thread[t1线程,<span class="hljs-number">5</span>,我的线程组], Thread[t2线程,<span class="hljs-number">5</span>,我的线程组], Thread[t3线程,<span class="hljs-number">5</span>,我的线程组]]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程（一）基本概念</title>
    <link href="/2021/06/22/CoreJava/22.%20%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/06/22/CoreJava/22.%20%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>多线程中的一些基本概念。</p><span id="more"></span><h2 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h2><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，也可以说是程序的一次执行过程。简单点的说“进程是正在运行的程序的实例”。</p><p>进程是系统进行资源分配和调度的一个独立单位。但引用线程之后，进程的功能发生了变化：<strong>进程只是资源分配的单位，不再是调度运行的单位，真正调度运行的基本单位变成了线程</strong>。</p><p>每个进程运行在受保护的独立的内存空间内，进程和进程之间互不干扰。</p><br/><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><p>线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位（<strong>系统调度的基本单位</strong>）。</p><p>线程自己<strong>基本上不拥有系统资源</strong>，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可<strong>与同属一个进程的其他的线程共享进程所拥有的全部资源</strong>。</p><p>一个线程可以创建和撤消另一个线程；同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中也呈现出间断性。相应地，线程也同样有就绪、阻塞和执行三种基本状态，有的系统中线程还有终止状态。</p><br/><h3 id="1-3-为什么使用线程"><a href="#1-3-为什么使用线程" class="headerlink" title="1.3 为什么使用线程"></a>1.3 为什么使用线程</h3><p>使用线程能<strong>提高系统内程序并发执行的速度，从而可进一步提高系统的吞吐量</strong>。</p><ul><li><p>进程间的通信比较复杂，而<strong>线程间的通信简单</strong>，通常情况下，需要使用共享资源，这些资源在线程间的通信比较容易</p></li><li><p>进程是重量级的，而<strong>线程是轻量级的</strong>，故多线程的方式系统开销更小。</p><br/></li></ul><h3 id="1-4-进程和线程的区别和联系"><a href="#1-4-进程和线程的区别和联系" class="headerlink" title="1.4 进程和线程的区别和联系"></a>1.4 进程和线程的区别和联系</h3><p>进程和线程的关系：</p><ul><li><p> 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。</p></li><li><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p></li><li><p>处理机分给线程，即真正在处理机上运行的是线程。</p></li><li><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p></li></ul><br/><p>线程与进程的比较：</p><ul><li><p>调度</p><p>在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位。而把进程作为资源拥有的基本单位，使传统进程的两个属性分开，线程便能轻装运行，从而可显著地提高系统的并发程度。在同一进程中，线程的切换不会引起进程的切换。在由一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。</p></li><li><p>并发性</p><p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统吞吐量。</p></li><li><p>拥有资源</p><p>不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立单位，它可以拥有自己的资源。一般地说，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源。</p></li><li><p>系统开销</p><p>由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 。</p></li></ul><br/><h2 id="2-并发和并行"><a href="#2-并发和并行" class="headerlink" title="2. 并发和并行"></a>2. 并发和并行</h2><ul><li><p>并发：</p><p>简单的来说就是指一个时间段内，多个任务同时处于运行活跃状态，而不是在同一时刻运行多个任务。因为CPU处理速度很快，所以看上去就是多个任务在同时执行，实际上就只有一个任务在执行。</p></li><li><p>并行：</p><p>并行相对来说能简单些，指若干个程序段同时在系统中运行，这些程序的执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，无论从微观还是宏观，程序都是一起执行的。</p></li></ul><br/><h2 id="3-时间片"><a href="#3-时间片" class="headerlink" title="3. 时间片"></a>3. 时间片</h2><p>时间片，当前一个线程要使用CPU的时候，CPU会分配给这个线程一小段时间（毫秒级别），这段时间就叫做时间片，也就是该线程允许使用CPU运行的时间。在这个期间，线程拥有CPU的使用权。 </p><p>如果在一个时间片结束时，线程还在运行，那么这时候，该线程就需要停止运行，并交出CPU的使用权，然后等待下一个CPU时间片的分配。 </p><p>所以，在宏观上，一段时间内，我们感觉俩个线程在同时运行代码，其实在微观中，这俩个线程在使用 一个CPU的时候，它们是交替着运行的。每个线程每次都是运行一个很小的时间片，然后就交出CPU使用权，只是它们俩个交替运行的速度太快了，给我们的感觉，好像是它们俩个线程在同时运行。</p><br/><h2 id="4-调度"><a href="#4-调度" class="headerlink" title="4. 调度"></a>4. 调度</h2><p>当两个或多个线程使用一个CPU来运行代码的时候，在操作系统的内核中，就会有相应的算法来控制线程获取CPU时间片的方式，从而使得这些线程可以按照某种顺序来使用 CPU 运行代码，这种情况被称为线程调用。 </p><p>常见的调度方式：</p><ul><li>时间片轮转：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 </li><li>抢占式调度：系统会让优先级高的线程优先使用 CPU（提高抢占到的概率），但是如果线程的优先级相同那么 会随机选择一个线程获取当前CPU的时间片。 JVM中的线程，使用的调度方式为抢占式调度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2021/06/21/CoreJava/21.%20%E5%BC%82%E5%B8%B8/"/>
    <url>/2021/06/21/CoreJava/21.%20%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p>程序在运行过程中，由于意外情况导致程序发生异常事件，默认情况下发生的异常会中断程序的运行。</p><span id="more"></span><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>程序在运行过程中，由于意外情况导致程序发生异常事件，默认情况下发生的异常会中断程序的运行。</p><p>在Java中，把常见的异常情况，都抽象成了对应的异常类型，那么每种异常类型都代表了一种特定的异常情况。 当程序中出现一种异常情况时，也会创建并抛出一个异常类型对象，这个对象就表示当前程序所出现的问题。</p><br/><h3 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h3><p>异常体系中的根类是： <code>java.lang.Throwable</code> ，该类下面有两个子类型，<code> java.lang.Error</code> 和 <code>java.lang.Exception</code>。我们一般说的异常，都是指的 Exception。</p><ul><li>Error ：表示错误情况，一般是程序中出现了比较严重的问题，并且程序自身并无法进行处理。 </li><li>Exception ：表示异常情况，程序中出了这种异常，大多是可以通过特定的方式进行处理和纠正的，并且处理完了之后，程序还可以继续往下正常运行。</li></ul><p>Exception 中并没有定义方法，它的方法都是从 Throwable 中继承过来的，其中常用的方式有：</p><table><thead><tr><th align="left">方法</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>printStackTrace()</code></td><td align="left">打印输出当前发送异常的详细信息。</td></tr><tr><td align="left"><code>getMessage()</code></td><td align="left">返回异常对象被抛出的时候，所携带的信息，一般是异常的发生原因。</td></tr><tr><td align="left"><code>printStackTrace(PrintWriter s) </code></td><td align="left">方法重载，可以指定字符输出流，对异常信息进行输出。</td></tr><tr><td align="left"><code>printStackTrace(PrintStream s) </code></td><td align="left">方法重载，可以指定字节输出流，对异常信息进行输出。</td></tr></tbody></table><br/><h3 id="1-3-异常的种类"><a href="#1-3-异常的种类" class="headerlink" title="1.3 异常的种类"></a>1.3 异常的种类</h3><p>我们平时使用的异常类型，都是 Exception 类的子类型，它们把异常划分成了两种：编译时异常和运行时异常。</p><ul><li><p>编译时异常，继承自 Exception 类，也称为 checked exception。编译器在编译期间，会主动检查这种异常，发现后会报错，并提示我们要对这种异常进行处理。 </p></li><li><p>运行时异常，继承自 RuntimeException 类，也称为 unchecked exception。编译器在编译期间，不会检查这种异常，也不要求我们去处理，但是在运行期间，代码中可能会抛出这种类型的异常。</p></li></ul><p><img src="C:\Users\MaxSeal\AppData\Roaming\Typora\typora-user-images\image-20210621150029919.png" alt="image-20210621150029919"></p><br/><h3 id="1-4-异常的传播"><a href="#1-4-异常的传播" class="headerlink" title="1.4 异常的传播"></a>1.4 异常的传播</h3><p>如果一个方法中抛出了异常，并且一直没有进行处理，那么这个异常将会抛给当前方法的调用者，并一直向上抛出，直到抛给 JVM，最后 JVM 将这个异常信息打印输出，同时程序运行的停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        test1();<br>        System.out.println(<span class="hljs-string">&quot;world&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>    test2();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>    test3();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>hello<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>at com.briup.demo.Test.test3(Test.java:<span class="hljs-number">16</span>)<br>at com.briup.demo.Test.test2(Test.java:<span class="hljs-number">13</span>)<br>at com.briup.demo.Test.test1(Test.java:<span class="hljs-number">10</span>)<br>at com.briup.demo.Test.main(Test.java:<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>可以看出，异常信息打印输出的内容，就是发生异常的时候，栈区中方法调用的情况！</p><ol><li>test3 方法中的第 16 行代码抛出异常，导致 test2 方法中的第 13 行也报错。</li><li>test2 方法中的第 13 行报错，导致 test1 方法的第 10 行也报错。</li><li>test1 方法中的第 10 行报错，导致 main 方法中的第 5 行也报错。</li><li>这时候，test3 方法中抛出的异常对象，就传播到了 main 方法中，main 中也没处理，那么就把这个异常抛给 JVM，JVM 就打印输出异常信息，然后 JVM 停止运行！ </li><li>所以程序最后停止在 main 方法中的第 5 行，下面的 world 也没有打印。因为 JVM 停止了，代码就不再往下执行了！</li></ol><p>如果，在异常传播的过程中，任何一个地方对异常进行了处理，那么JVM不会停止，程序还会正常 往下运行！</p><h2 id="2-异常抛出"><a href="#2-异常抛出" class="headerlink" title="2. 异常抛出"></a>2. 异常抛出</h2><h3 id="2-1-自动抛出异常"><a href="#2-1-自动抛出异常" class="headerlink" title="2.1 自动抛出异常"></a>2.1 自动抛出异常</h3><p>当前 java 代码中，出现了提前指定好的异常情况的时候，代码会自动创建异常对象，并且将该异常对象抛出。 </p><ul><li>例如，当代码中执行 <code>int a = 1/0;</code> 的时候，代码会自动创建并抛出 ArithmeticException 类型的异常对象，来表示当前的这种异常情况。（算术异常）</li><li>例如，当前代码中执行 <code>String str = null; str.toString(); </code>的时候，代码会自动创建并抛出 NullPointerException 类型的异常对象，来表示当前这种异常情况。（空指针异常）</li></ul><br/><h3 id="2-2-手动抛出异常"><a href="#2-2-手动抛出异常" class="headerlink" title="2.2 手动抛出异常"></a>2.2 手动抛出异常</h3><p>以上描述的异常情况，都是JVM中提前规定好的，我们不需要干预，JVM内部自己就会创建并抛出异常对象。 但是在其他的一些情况下，我们也可以手动的创建并抛出异常对象，其效果也是一样的。</p><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;tom&quot;</span>.equals(name))&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;用户名和预期不符！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上方法中抛出的是一个运行时异常，编译器不会做出检查，所以代码可以正常的编译运行。但是运行的时候，如果 name 的值不是 tom，代码就会报错。这个错误信息是我们自己抛出的。</p><br/><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;tom&quot;</span>.equals(name))&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;用户名和预期不符！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上方法中抛出的异常是编译异常，编译器会做检查，所以代码编译会报错，提示我们需要在 test 方法上声明出方法内抛出异常的类型，或者在方法内对这个异常进行处理。</p><br/><p>例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;tom&quot;</span>.equals(name))&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;用户名和预期不符！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 throws 关键字，声明方法所抛出的异常类型。</p><p>这个声明的目的，就是告诉 test 方法的调用者，你调用我的这个 test 方法的时候要小心啦，方法在运行的时候可能会抛出 Exception 类型的异常。这里描述为可能会抛出异常的原因是，只有name 的值不是 tom 的时候才会抛出异常，其他情况没有异常！</p><br/><h3 id="2-3-throw-和-throws"><a href="#2-3-throw-和-throws" class="headerlink" title="2.3 throw 和 throws"></a>2.3 throw 和 throws</h3><ul><li>throws 用在方法上，后面跟的是异常类，可以跟多个。用来声明异常。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常。</li><li>throw 用在方法内，后面跟的是异常对象。用来抛出具体的问题对象。</li><li>throw 表示抛出异常，执行 throw 则一定抛出了某种异常对象。</li></ul><br/><h2 id="3-异常捕获"><a href="#3-异常捕获" class="headerlink" title="3. 异常捕获"></a>3. 异常捕获</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>当一个方法内，抛出了编译异常的时候，编译器在编译期间检查到，就会报错，提示我们有两种修改方案： </p><ul><li><p>把这个异常在方法上进行声明抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String className)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException</span>&#123;<br>Class.forName(className);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们并没有处理 forName 方法抛出的异常，而是将这个异常继续声明抛出。那么将来谁调用我们的 test 方法，谁就要处理这个异常情况。</p></li></ul><br/><ul><li><p>把这个异常在方法内进行捕获处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String className)</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>    Class.forName(className);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>    e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了 try-catch 语句块，对可能抛出异常的代码进行异常捕获处理。 </p></li></ul><br/><h3 id="3-2-try-catch"><a href="#3-2-try-catch" class="headerlink" title="3.2 try - catch"></a>3.2 try - catch</h3><p>try-catch 语句块，就是用来对指定代码，进行异常捕获处理,并且处理完成后，JVM不会停止运行， 代码还可以正常的往下运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">//编写可能会出现异常的代码。</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型 e)&#123;<br><span class="hljs-comment">//处理异常的代码，可以是简单的输出异常信息，也可以使用日志进行了记录，也可以对数据进行修改纠正等操作。</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    Test t = <span class="hljs-keyword">new</span> Test();<br>    <span class="hljs-keyword">try</span> &#123;<br>    t.test(<span class="hljs-string">&quot;zs&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>   e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;world&quot;</span>);<br>    &#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;tom&quot;</span>.equals(name))&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;用户名不正确&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="3-3-捕获多种异常"><a href="#3-3-捕获多种异常" class="headerlink" title="3.3 捕获多种异常"></a>3.3 捕获多种异常</h3><p>如果 try 语句块中的多句代码，都会抛出异常，并且是不同类型的异常，那么 catch 语句块就有不同的写法，来处理这几个不同类型的异常。</p><br/><p>方法1：使用一个catch语句，里面使用 | 来表示捕获多种不同的异常类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String className = <span class="hljs-string">&quot;com.briup.demo.Student&quot;</span>;<br>    String methodName = <span class="hljs-string">&quot;sayHello&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//forName声明抛出ClassNotFoundException</span><br>        Class c = Class.forName(className);<br><br>        <span class="hljs-comment">//getMethod方法声明抛出NoSuchMethodException</span><br>        Method m = c.getMethod(methodName);<br><br>        <span class="hljs-comment">//invoke方法声明抛出IllegalAccessException和InvocationTargetException</span><br>        m.invoke(<span class="hljs-keyword">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | NoSuchMethodException |<br>    IllegalAccessException | InvocationTargetException e) &#123;<br>    e.printStackTrace();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><p>方法2：使用了多个catch语句，分别对不同的异常类型进行捕获处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String className = <span class="hljs-string">&quot;com.briup.demo.Student&quot;</span>;<br>    String methodName = <span class="hljs-string">&quot;sayHello&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//forName声明抛出ClassNotFoundException</span><br>        Class c = Class.forName(className);<br><br>        <span class="hljs-comment">//getMethod方法声明抛出NoSuchMethodException</span><br>        Method m = c.getMethod(methodName);<br><br>        <span class="hljs-comment">//invoke方法声明抛出IllegalAccessException和InvocationTargetException</span><br>        m.invoke(<span class="hljs-keyword">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>      e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>      e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>      e.printStackTrace();<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要求多个 catch 中的异常不能相同。</li><li>如果 catch 中的多个异常之间有子父类异常的关系的话，那么子类异常要求在上面的 catch 处理，父类异常在下面的 catch 处理。 因为如果父类型异常再最上面的话，下面 catch 语句代码，永远不会被执行。</li></ul><br/><p>方法3：抛出最大的异常类型 Exception</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String className = <span class="hljs-string">&quot;com.briup.demo.Student&quot;</span>;<br>    String methodName = <span class="hljs-string">&quot;sayHello&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//forName声明抛出ClassNotFoundException</span><br>        Class c = Class.forName(className);<br><br>        <span class="hljs-comment">//getMethod方法声明抛出NoSuchMethodException</span><br>        Method m = c.getMethod(methodName);<br><br>        <span class="hljs-comment">//invoke方法声明抛出IllegalAccessException和InvocationTargetException</span><br>        m.invoke(<span class="hljs-keyword">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>捕获的异常类型是 Exception，它最大的异常类型。由于多态的原因，Exception类型的引用e，可以捕获接收到任意类型的异常对象。</p><br/><h3 id="3-4-finally-语句"><a href="#3-4-finally-语句" class="headerlink" title="3.4 finally 语句"></a>3.4 finally 语句</h3><p>try-catch 语句块，虽然可以捕获并处理异常情况，但是它也会改变代码的执行流程。</p><p>要使用 finally 关键，就可以保证指定代码一定会执行。</p><br/><p>finally 中的代码总是会执行吗？</p><ul><li>如果一个方法内在执行 try{} 语句之前就已经 return 了，那么 finally 语句指定不会执行了，因为它根本没有进入 try 语句中。</li><li>如果在一个try语句中调用 <code>System.exit(0);</code> 方法，那么就会退出当前 java 虚拟机，那么 finally 也就没有执行的机会了。</li></ul><br/><p>一定要使用 finally 吗？</p><ul><li>不是，开发者可以根据自身的情况去决定是否使用 finally 关键字。</li></ul><br/><h3 id="3-5-try-catch-finally-的执行顺序"><a href="#3-5-try-catch-finally-的执行顺序" class="headerlink" title="3.5 try-catch-finally 的执行顺序"></a>3.5 try-catch-finally 的执行顺序</h3><p>情况1：try 块中没有抛出异常，try 和 finally 块中都有 return 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">finallyTest1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;try 块中的 i:&quot;</span> + i);<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;finally 块中的 i:&quot;</span> + i);<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最后返回的 i 是:&quot;</span>+ finallyTest1());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为：</span><br><span class="hljs-keyword">try</span>块中的 i:<span class="hljs-number">1</span><br><span class="hljs-keyword">finally</span>块中的 i:<span class="hljs-number">2</span><br>最后返回的 i 是: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><br/><p>情况2：try 块中没有抛出异常，仅 try 中有 return 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">finallyTest2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;try块中的i:&quot;</span> + i);<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;finally块中的i:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最后返回的i 是:&quot;</span>+ finallyTest2());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为：</span><br><span class="hljs-keyword">try</span>块中的i:<span class="hljs-number">1</span><br><span class="hljs-keyword">finally</span>块中的i:<span class="hljs-number">2</span><br>最后返回的i是:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br/><p>情况3：try 块中抛出异常， try、catch 和 finally 中都有 return 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">finallyTest3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;try块中的i:&quot;</span> + i);<br>            a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;catch块中的i:&quot;</span> + i);<br>            <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;finally块中的i:&quot;</span> + i);<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最后返回的i是:&quot;</span>+ finallyTest3());<br>    &#125;<br><br><span class="hljs-comment">// 结果为：</span><br><span class="hljs-keyword">try</span>块中的i:<span class="hljs-number">1</span><br><span class="hljs-keyword">catch</span>块中的i:<span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span>块中的i:<span class="hljs-number">3</span><br>最后返回的i是:<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><br/><p>情况4：try 块中抛出异常，catch 和 finally 中有 return，try 中没有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">finallyTest3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;try块中的i:&quot;</span> + i);<br>            a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;catch块中的i:&quot;</span> + i);<br>            <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;finally块中的i:&quot;</span> + i);<br>          <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最后返回的i是:&quot;</span>+ finallyTest3());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为：</span><br><span class="hljs-keyword">try</span>块中的i:<span class="hljs-number">1</span><br><span class="hljs-keyword">catch</span>块中的i:<span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span>块中的i:<span class="hljs-number">3</span><br>最后返回的i是:<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><br/><p>情况5：try 和 catch 中都有异常，finally 中无 return 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">finallyTest3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;try块中的i:&quot;</span> + i);<br>            a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;catch块中的i:&quot;</span> + i);<br>          a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;finally块中的i:&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最后返回的i是:&quot;</span>+ finallyTest3());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为</span><br><span class="hljs-keyword">try</span>块中的i:<span class="hljs-number">1</span><br><span class="hljs-keyword">catch</span>块中的i:<span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span>块中的i:<span class="hljs-number">3</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br>at FinallyTest.Test5.finallyTest3(Test5.java:<span class="hljs-number">15</span>)<br>at FinallyTest.Test5.main(Test5.java:<span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure><br/><p>情况6：try 和 catch 中都有异常，finally 中有 return 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">finallyTest3</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;try块中的i:&quot;</span> + i);<br>            a = <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;catch块中的i:&quot;</span> + i);<br>           a=<span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            i++;<br>            System.out.println(<span class="hljs-string">&quot;finally块中的i:&quot;</span> + i);<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最后返回的i是:&quot;</span>+ finallyTest3());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//结果为</span><br><span class="hljs-keyword">try</span>块中的i:<span class="hljs-number">1</span><br><span class="hljs-keyword">catch</span>块中的i:<span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span>块中的i:<span class="hljs-number">3</span><br>最后返回的i是:<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><br/><p>情况7：返回的引用类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">finallyTest3</span><span class="hljs-params">()</span></span>&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            list.add(<span class="hljs-number">1</span>);<br>            a = <span class="hljs-number">10</span>/<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> list;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            list.add(<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">return</span> list;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            list.add(<span class="hljs-number">3</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;最后返回的是:&quot;</span>+ finallyTest3());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论 finally 代码块是否返回值，其中的修改都会影响到对象。</p><br/><p>总结：</p><p>如果返回值是基本类型：</p><ul><li>若 finally 里没有 return 语句，则 finally 中的修改语句不会影响 try 或 catch 中 return 返回值。</li><li>若 finally 里也有 return 语句，则覆盖 try 或 catch 中的 return 语句。</li></ul><p>如果返回值是引用类型：</p><ul><li>无论 finally 代码有没有 return 语句，其中的修改语句都会影响到对象。</li></ul><br/><h2 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4. 自定义异常"></a>4. 自定义异常</h2><h3 id="4-1-意义"><a href="#4-1-意义" class="headerlink" title="4.1 意义"></a>4.1 意义</h3><p>JavaAPI 中已经存在的异常类，它们分别表示着某一种已知的异常情况。 但是，在我们开发的系统中，大多数业务功能里面总会出现一些新的异常情况，而这些异常情况是 JavaAPI 种没有定义的。</p><p>所以，在实际开发中，我们会自定义一些异常的类型，用来表示没有在 JavaAPI 种定义的异常情况。这样做的好处就是，我们通过观察系统的运行日志，就可以很快的知道当前系统是发生了什么事情，才导致出了这些异常情况。</p><br/><h3 id="4-2-自定义异常写法"><a href="#4-2-自定义异常写法" class="headerlink" title="4.2 自定义异常写法"></a>4.2 自定义异常写法</h3><ul><li><p>如果要自定义一个编译时异常类型，就自定义一个类，并继承 Exception </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginExceptin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginExceptin</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginExceptin</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/></li><li><p>如果要自定义一个运行时异常类型，就自定义一个类，并继承 RuntimeException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModifyUserInfoExceptin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ModifyUserInfoExceptin</span><span class="hljs-params">()</span></span>&#123;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ModifyUserInfoExceptin</span><span class="hljs-params">(String message)</span> </span>&#123;<br>  <span class="hljs-keyword">super</span>(message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2021/06/18/CoreJava/20.%20%E8%8C%83%E5%9E%8B/"/>
    <url>/2021/06/18/CoreJava/20.%20%E8%8C%83%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>泛型，即“参数化类型”。顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><span id="more"></span><h2 id="1-泛型的定义"><a href="#1-泛型的定义" class="headerlink" title="1. 泛型的定义"></a>1. 泛型的定义</h2><p>泛型，即“参数化类型”。顾名思义，就是<strong>将类型由原来的具体的类型参数化</strong>，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    T x;<br>    T y;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>T 是泛型参数，表示一种数据类型，具体是什么类型，需要将来使用 Point 的时候进行传参来确定。</li><li>如果将来 Point 在使用的时候，没有给泛型参数 T 传值，那么 T 默认就表示为 Object 类型。</li><li>T 是泛型参数的名字，也就是相当于形参，名字随便起，但是一般用一个有意义的大写字母。</li><li>给泛型参照传的值，只能是引用类型，不能是基本类型： Point(int) 编译报错。</li></ul><br/><h2 id="2-泛型的类型"><a href="#2-泛型的类型" class="headerlink" title="2. 泛型的类型"></a>2. 泛型的类型</h2><h3 id="2-1-泛型的种类"><a href="#2-1-泛型的种类" class="headerlink" title="2.1 泛型的种类"></a>2.1 泛型的种类</h3><p>java中的泛型分三种使用情况： 泛型类，泛型接口和泛型方法。</p><ul><li>泛型类，如果泛型参数定义在类上面，那么这个类就是一个泛型类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>Point&lt;String&gt; p = <span class="hljs-keyword">new</span> Point&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><br/><ul><li>泛型接口，如果泛型参数定义在接口上面，那么这个接口就是一个泛型接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  <span class="hljs-comment">//创建匿名内部类</span><br>  Action&lt;String&gt; a = <span class="hljs-keyword">new</span> Action&lt;&gt;()&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><br/><ul><li>泛型方法，如果泛型参数定义在方法上面，那么这个方法就是一个泛型方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>&#123;<br>  <span class="hljs-comment">//..</span><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Test t = <span class="hljs-keyword">new</span> Test();<br>    String str = t.test(<span class="hljs-string">&quot;hello&quot;</span>);<br>    Integer i = t.test(<span class="hljs-number">1</span>);<br>    Double d = t.test(<span class="hljs-number">10.5D</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>如果方法参数中有泛型 T，而方法的返回类型前没有泛型 T，该类型就不是泛型方法，而是泛型类。</p></li><li><p>泛型方法常用在工具类中（即该方法只是一种工具），与类的实例对象无关。</p></li><li><p>当泛型方法中的泛型 T 与类中的泛型 T 同名时会产生警报，因为编译器不确定你要使用哪个持有对象。</p></li></ul><br/><h3 id="2-2-思考题1"><a href="#2-2-思考题1" class="headerlink" title="2.2 思考题1"></a>2.2 思考题1</h3><p>在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。<strong>那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> T data;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Box</span><span class="hljs-params">()</span> </span>&#123;&#125; <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Box</span><span class="hljs-params">(T data)</span> </span>&#123;         <br>    <span class="hljs-keyword">this</span>.data = data;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Box&lt;String&gt; name = <span class="hljs-keyword">new</span> Box&lt;String&gt;(<span class="hljs-string">&quot;corn&quot;</span>);<br>        Box&lt;Integer&gt; age = <span class="hljs-keyword">new</span> Box&lt;Integer&gt;(<span class="hljs-number">712</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;name class:&quot;</span> + name.getClass());      <span class="hljs-comment">// Box</span><br>        System.out.println(<span class="hljs-string">&quot;age class:&quot;</span> + age.getClass());        <span class="hljs-comment">// Box</span><br>        System.out.println(name.getClass() == age.getClass());    <span class="hljs-comment">// true</span><br><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>在使用泛型类时，虽然传入了不同的泛型实参，但<strong>并没有真正意义上生成不同的类型</strong>，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box）。</p><br/><h3 id="2-3-思考题2"><a href="#2-3-思考题2" class="headerlink" title="2.3 思考题2"></a>2.3 思考题2</h3><p> Integer 是 Object 的子类型，那么  ArrayList<Integer> 和 ArrayList<Object> 之间是否有子父类的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译通过，父类型的引用，指向子类对象。</span><br>Object o = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//编译通过，Object[] 类型兼容所有的【引用】类型数组。</span><br>Object[] arr = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//编译失败，类型不兼容，int[] 是基本类型数组。</span><br>Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//编译失败，错误信息：ArrayList&lt;Integer&gt;无法转为ArrayList&lt;Object&gt;</span><br><span class="hljs-comment">//在编译期间，ArrayList&lt;Integer&gt; 和 ArrayList&lt;Object&gt;是俩个不同的类型，并且没有子父类型的关系</span><br>ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>虽然 Integer 是 Object 的子类型，但是 ArrayList<Integer> 和 ArrayList<Object> 之间没有子父类型的关系，它们就是两个不同的类型。因此，两边的 &lt;&gt; 里的类型要一致。</p><br/><h3 id="2-4-类型擦除"><a href="#2-4-类型擦除" class="headerlink" title="2.4 类型擦除"></a>2.4 类型擦除</h3><p>泛型类型仅存在于编译期间，编译后的字节码和运行时不包含泛型信息，所有的泛型类型映射到同一份字节码。 </p><p>由于泛型是 JDK1.5 才加入到 Java 语言特性的，Java 让编译器擦除掉关于泛型类型的信息，这样使得 Java 可以向后兼容之前没有使用泛型的类库和代码，因为在字节码（class）层面是没有泛型概念的。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译报错</span><br><span class="hljs-comment">//因为在编译后，泛型信息会被擦除, 那么一个类会就存在了俩个一样的方法 public void run(List list)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(List&lt;String&gt; list)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(List&lt;Integer&gt; list)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//编译报错</span><br>    <span class="hljs-comment">//ArrayList&lt;Integer&gt; 和 ArrayList&lt;Long&gt; 在编译期间是不同的类型</span><br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Long&gt;();<br>  <br>    <span class="hljs-comment">//但是编译完成后，它们对应的是同一份 class 文件：ArrayList.class</span><br>    ArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    ArrayList&lt;Long&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Long&gt;();<br>    System.out.println(list1.getClass() == list2.getClass()); <span class="hljs-comment">//true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>泛型信息被擦除后，所有的泛型类型都会统一变为原始类型：Object 。</li><li>Java 的泛型只存在于编译时期，泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。</li></ul><br/><h2 id="3-通配符"><a href="#3-通配符" class="headerlink" title="3. 通配符"></a>3. 通配符</h2><h3 id="3-1-通配符使用"><a href="#3-1-通配符使用" class="headerlink" title="3.1 通配符使用"></a>3.1 通配符使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(Collection&lt;Integer&gt; c)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(Collection&lt;String&gt; c)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">(Collection&lt;Object&gt; c)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>test1 方法【只能】接收泛型是 Integer 类型的集合对象 </li><li>test2 方法【只能】接收泛型是 String 类型的集合对象</li><li>test3 方法【只能】接收泛型是 Object 类型的集合对象 </li></ul><p>原因：由于泛型的类型之间没有多态。</p><br/><p>可以使用通配符（?）来表示泛型的父类型：这时候 test 方法中的参数类型，使用了泛型，并且使用问号来表示这个泛型的类型，这个问号就是通配符，可以匹配所有的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Test t = <span class="hljs-keyword">new</span> Test();<br>    t.test(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());<br>    t.test(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());<br>    t.test(<span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;());<br>    t.test(<span class="hljs-keyword">new</span> ArrayList&lt;任意类型&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="3-2-通配符带来的问题"><a href="#3-2-通配符带来的问题" class="headerlink" title="3.2 通配符带来的问题"></a>3.2 通配符带来的问题</h3><p>使用通配符（?）的集合，不能再往其中添加数据，但是可以添加 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;?&gt; c;<br>c = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br><span class="hljs-comment">//编译报错</span><br><span class="hljs-comment">//因为变量c所声明的类型是Collection，同时泛型类型是通配符（?）</span><br><span class="hljs-comment">//那么编译器也不知道这个?将来会是什么类型，因为这个?只是一个通配符</span><br><span class="hljs-comment">//所以，编译器不允许使用变量c来向集合中添加新数据。</span><br>c.add(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-comment">//编译通过</span><br><span class="hljs-comment">//但是有一个值是可以添加到集合中的，null</span><br><span class="hljs-comment">//集合中一定存的是引用类型，null是所有引用类型共同的一个值，所以一定可以添加进去。</span><br>c.add(<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><br/><p>虽然不能添加数据，但可以遍历数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello4&quot;</span>);<br>    Collection&lt;?&gt; c = list;<br><br>    <span class="hljs-keyword">for</span>(Object obj : c)&#123;<br>    System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="4-泛型的边界"><a href="#4-泛型的边界" class="headerlink" title="4. 泛型的边界"></a>4. 泛型的边界</h2><h3 id="4-1-泛型的上限"><a href="#4-1-泛型的上限" class="headerlink" title="4.1 泛型的上限"></a>4.1 泛型的上限</h3><p>使用 extends 可以定义泛型的上限，这个就表示将来泛型所接收的类型最大是什么类型。</p><p>泛型简单的用 extends 统一的表示了原有的 extends 和 implements 的概念，但仍要遵循应用的体系，即<strong>只能继承一个类，但可以实现多个接口</strong>。所以某个类型需要用 extends 限定，且有多种类型的时候，只能存在一个是类，并且类写在第一位，接口列在后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T extends SomeClass &amp; interface1 &amp; interface2 &amp; interface3&gt;<br></code></pre></td></tr></table></figure><br/><p>例如：list 就可以接收泛型是 Number 或者 Number 子类型的 List 集合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;? extends Number&gt; list;<br>  <br>    <span class="hljs-comment">//list可以指向泛型是Number或者Number【子】类型的集合对象</span><br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Double&gt;();<br>  <br>    <span class="hljs-comment">//编译报错，因为String不是Number类型，也不是Number的子类型</span><br>    <span class="hljs-comment">//list = new ArrayList&lt;String&gt;();</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-2-extends-的使用场景"><a href="#4-2-extends-的使用场景" class="headerlink" title="4.2 extends 的使用场景"></a>4.2 extends 的使用场景</h3><ul><li><p>在声明泛型类或者泛型接口的时候可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T x;<br>    <span class="hljs-keyword">private</span> T y;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><br/><ul><li><p>在声明泛型方法的时候可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T extends Action&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><br/><ul><li><p>在声明变量的时候可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;? extends Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Long&gt;();<br>    t.test(list);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-泛型的下限"><a href="#4-3-泛型的下限" class="headerlink" title="4.3  泛型的下限"></a>4.3  泛型的下限</h3><p>使用 super 可以定义泛型的下限，这个就表示将来泛型所接收的类型最小是什么类型。</p><p>例如：list 就可以接收泛型是 Number 或者 Number 父类型的 List 集合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;? <span class="hljs-keyword">super</span> Number&gt; list;<br>  <br>    <span class="hljs-comment">//list可以指向泛型是Number或者Number【父】类型的集合对象</span><br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Serializable&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>  <br>    <span class="hljs-comment">//编译报错，因为String不是Number类型，也不是Number的父类型</span><br>    <span class="hljs-comment">//list = new ArrayList&lt;String&gt;();</span><br>  <br>    <span class="hljs-comment">//编译报错，因为Integer不是Number类型，也不是Number的父类型</span><br>    <span class="hljs-comment">//list = new ArrayList&lt;Integer&gt;();</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-4-super-的使用场景"><a href="#4-4-super-的使用场景" class="headerlink" title="4.4  super 的使用场景"></a>4.4  super 的使用场景</h3><ul><li><p>在<strong>声明泛型类</strong>或者<strong>泛型接口</strong>的时候<strong>不能使用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译报错</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">super</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>  <span class="hljs-keyword">private</span> T x;<br>  <span class="hljs-keyword">private</span> T y;<br>&#125;<br><br><span class="hljs-comment">//编译报错</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">super</span> <span class="hljs-title">Person</span>&gt;</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><br/><ul><li><p>在<strong>声明泛型方法</strong>的时候<strong>不能使用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译报错</span><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">super</span> Action&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><br/><ul><li><p>在<strong>声明变量</strong>的时候<strong>可以使用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Number&gt; list)</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;? <span class="hljs-keyword">super</span> Number&gt; list;<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br><br>    <span class="hljs-comment">//假设Student 继承了 Person</span><br>    List&lt;? <span class="hljs-keyword">super</span> Student&gt; list;<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Pesson&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2021/06/18/CoreJava/19.%20%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/06/18/CoreJava/19.%20%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><span id="more"></span><h2 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1. 类加载过程"></a>1. 类加载过程</h2><h2 id="2-反射的作用"><a href="#2-反射的作用" class="headerlink" title="2. 反射的作用"></a>2. 反射的作用</h2><p>Java中编译类型有两种：</p><ul><li><strong>静态编译</strong>：在编译时确定类型，绑定对象即通过。</li><li><strong>动态编译</strong>：运行时确定类型，绑定对象。动态编译最大限度地发挥了Java的灵活性，体现了多态的应用，可以减低类之间的耦合性。</li></ul><p><strong>Java反射是Java被视为动态（或准动态）语言的一个关键性质</strong>。反射可以在运行时加载、探知、使用编译期间完全未知的类。即 Java 程序可以加载一个运行时才得知名称的类，获取其完整构造，并生成其对象实体、或对其属性设值、或唤起其方法。</p><br/><p>实现Java反射机制的类都位于<code>java.lang.reflect</code>包中：</p><ol><li><p>Class 类：代表一个类。</p></li><li><p>Field 类：代表类的成员变量（类的属性）。</p></li><li><p>Method 类：代表类的方法。</p></li><li><p>Constructor 类：代表类的构造方法。</p></li><li><p>Array 类：提供了动态创建数组，以及访问数组的元素的静态方法。</p></li></ol><br/><h2 id="3-Class-类"><a href="#3-Class-类" class="headerlink" title="3. Class 类"></a>3. Class 类</h2><p>一个类有成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><ul><li>类本身也是一个对象，我们定义的所有类都是 Class 类的对象。</li><li>类里面的属性都是 Field 类的对象。</li><li>类里面的方法都是 Method 类的对象。</li><li>类里面的构造器都是 Constructor 类的对象。</li></ul><br/><h3 id="3-1-使用-Class-对象表示其他类型"><a href="#3-1-使用-Class-对象表示其他类型" class="headerlink" title="3.1 使用 Class 对象表示其他类型"></a>3.1 使用 Class 对象表示其他类型</h3><h4 id="3-1-1-使用Class类的对象来表示基本类型"><a href="#3-1-1-使用Class类的对象来表示基本类型" class="headerlink" title="3.1.1 使用Class类的对象来表示基本类型"></a>3.1.1 使用Class类的对象来表示基本类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//这个对象c就代表java中的int类型</span><br>    Class c = <span class="hljs-keyword">int</span>.class;<br>  <br>    <span class="hljs-comment">//判断对象c所代表的类型是否是基本类型</span><br>    System.out.println(c.isPrimitive());<br>  <br>    <span class="hljs-comment">//获取对象c所代表的类型的名字</span><br>    System.out.println(c.getName());<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><br/><h4 id="3-1-2-使用-Class-类的对象来表示类类型"><a href="#3-1-2-使用-Class-类的对象来表示类类型" class="headerlink" title="3.1.2 使用 Class 类的对象来表示类类型"></a>3.1.2 使用 Class 类的对象来表示类类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//这个对象c就代表Student类</span><br>    Class c = Student.class;<br>    System.out.println(c.getName());<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>com.briup.demo.Student<br></code></pre></td></tr></table></figure><br/><h4 id="3-1-3-使用-Class-类的对象来表示接口类型"><a href="#3-1-3-使用-Class-类的对象来表示接口类型" class="headerlink" title="3.1.3 使用 Class 类的对象来表示接口类型"></a>3.1.3 使用 Class 类的对象来表示接口类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//这个对象c就代表List接口类型</span><br>    Class c = List.class;<br>    System.out.println(c.isInterface());<br>    System.out.println(c.getName());<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-keyword">true</span><br>java.util.List<br></code></pre></td></tr></table></figure><br/><h4 id="3-1-4-使用Class类的对象来表示数组类型"><a href="#3-1-4-使用Class类的对象来表示数组类型" class="headerlink" title="3.1.4 使用Class类的对象来表示数组类型"></a>3.1.4 使用Class类的对象来表示数组类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  <span class="hljs-comment">//这个对象c代表数组类型</span><br>  Class c;<br>  c = <span class="hljs-keyword">int</span>[].class;<br>  c = <span class="hljs-keyword">int</span>[][].class;<br>  c = Student[].class;<br>  System.out.println(c.isArray());<br>  System.out.println(c.getSimpleName());<br>  <span class="hljs-comment">//返回组成该数组具体类型是什么</span><br>  System.out.println(c.getComponentType().getSimpleName());<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-keyword">true</span><br>Student[]<br>Student<br></code></pre></td></tr></table></figure><br/><h3 id="3-2-获取-Class-对象"><a href="#3-2-获取-Class-对象" class="headerlink" title="3.2 获取 Class 对象"></a>3.2 获取 Class 对象</h3><p>在 java 中，每种类型（基本类型和引用类型）加载到内存之后，都会在内存中生成一个 Class 类型对象， 这个对象就代表这个具体的 java 类型，并且保存了这个类型中的基本信息。 </p><h4 id="3-2-1-获取基本类型的-class-对象"><a href="#3-2-1-获取基本类型的-class-对象" class="headerlink" title="3.2.1 获取基本类型的 class 对象"></a>3.2.1 获取基本类型的 class 对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c = 基本类型.class;<br></code></pre></td></tr></table></figure><br/><h4 id="3-2-2-获取接口类型的-Class-对象"><a href="#3-2-2-获取接口类型的-Class-对象" class="headerlink" title="3.2.2 获取接口类型的 Class 对象"></a>3.2.2 获取接口类型的 Class 对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c1 = 接口名.class;<br>Class c2 = Class.forName(<span class="hljs-string">&quot;包名+接口名&quot;</span>)<br></code></pre></td></tr></table></figure><br/><h4 id="3-2-3-获取数组类型的-Class-对象"><a href="#3-2-3-获取数组类型的-Class-对象" class="headerlink" title="3.2.3 获取数组类型的 Class 对象"></a>3.2.3 获取数组类型的 Class 对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c1 = 类型[].class;<br>Class c2 = 数组对象.getClass();<br></code></pre></td></tr></table></figure><br/><h4 id="3-2-4-获取类类型的-Class-对象"><a href="#3-2-4-获取类类型的-Class-对象" class="headerlink" title="3.2.4 获取类类型的 Class 对象"></a>3.2.4 获取类类型的 Class 对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c1 = 类名.class;<br>Class c2 = Class.forName(<span class="hljs-string">&quot;包名+类名&quot;</span>);<br>Class c3 = 该类的对象.getClass();<br></code></pre></td></tr></table></figure><br/><h2 id="4-通过反射获取类的信息"><a href="#4-通过反射获取类的信息" class="headerlink" title="4. 通过反射获取类的信息"></a>4. 通过反射获取类的信息</h2><p>常用方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>getName()</code></td><td>获取类的名字，全限定名。</td></tr><tr><td><code>getSimpleName()</code></td><td>获取类的名字，简单类名。</td></tr><tr><td><code>getPackage()</code></td><td>获取类所属包名。</td></tr><tr><td><code>getModifiers()</code></td><td>获取类的修饰符。</td></tr><tr><td><code>getSuperclass()</code></td><td>获取类的父类。</td></tr><tr><td><code>getInterfaces()</code></td><td>获取类实现的所有接口。</td></tr><tr><td><code>isAssignableFrom()</code></td><td>某个类是否是另一类的父类。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    Student stu = <span class="hljs-keyword">new</span> Student();<br>    Class c = stu.getClass();<br>  <br>    <span class="hljs-comment">//获取类的名字，全限定名</span><br>    System.out.println(c.getName());<br>  <br>    <span class="hljs-comment">//获取类的名字，简单类名</span><br>    System.out.println(c.getSimpleName());<br>  <br>    <span class="hljs-comment">//获取类所属包的名字</span><br>    System.out.println(c.getPackage().getName());<br>  <br>    <span class="hljs-comment">//获取类的修饰符</span><br>    System.out.println(Modifier.toString(c.getModifiers()));<br>  <br>    <span class="hljs-comment">//获取类的父类型的名字</span><br>    System.out.println(c.getSuperclass().getName());<br>  <br>    <span class="hljs-comment">//获取类实现的所有接口</span><br>    System.out.println(Arrays.toString(c.getInterfaces()));<br>  <br>    Class c2 = Object.class;<br>    Class c3 = Action.class;<br><br>    <span class="hljs-comment">//判断c2代表的类型是不是c代表类型 的父类型</span><br>    System.out.println(c2.isAssignableFrom(c));<br>  <br>    <span class="hljs-comment">//判断c3代表的类型是不是c代表类型 的父类型</span><br>    System.out.println(c3.isAssignableFrom(c));<br><br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="5-通过反射获取属性信息"><a href="#5-通过反射获取属性信息" class="headerlink" title="5. 通过反射获取属性信息"></a>5. 通过反射获取属性信息</h2><p>常用方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>getFields()</code></td><td>获取类中所有属性，包括从父类继承的。（不包括 private 修饰的）</td></tr><tr><td><code>getField(String name)</code></td><td>根据名字获取类中属性。（不能获取 private 修饰的）</td></tr><tr><td><code>getDeclaredFields()</code></td><td>获取类的所有属性。（包括 private 修饰的）</td></tr><tr><td><code>getDeclaredField(String name)</code></td><td>根据名字获取类中属性。（能获取 private 修饰的）</td></tr><tr><td><code>setAccessible()</code></td><td>设置私有属性可以被访问。</td></tr><tr><td><code>getName()</code></td><td>获取方法名。</td></tr><tr><td><code>getModifiers()</code></td><td>获取属性的修饰符。</td></tr><tr><td><code>getType()</code></td><td>获取属性的类型。</td></tr><tr><td><code>set()</code></td><td>设置属性值。</td></tr><tr><td><code>get()</code></td><td>获取属性值。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">checkName</span><span class="hljs-params">(String name)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getName</span><span class="hljs-params">(String name)</span></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>&#123; System.out.println(<span class="hljs-string">&quot;被调用了&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(String name,String password)</span></span>&#123;  &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,String name,String password)</span></span>&#123;  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;<br>        Class&lt;?&gt; userClass = User.class;<br>        Object user = userClass.newInstance(); <br><br>   <span class="hljs-comment">// 获取类中的所有属性</span><br>        Field[] userFields = userClass.getDeclaredFields();<br><br>        <span class="hljs-comment">// 获取属性的信息</span><br>        <span class="hljs-keyword">for</span> (Field userField: userFields) &#123;<br>            <span class="hljs-keyword">int</span> modifiers = userField.getModifiers();  <span class="hljs-comment">// 获取修饰符</span><br>            String modifierName =  Modifier.toString(modifiers);<br>            String fieldName = userField.getName();    <span class="hljs-comment">// 获取属性名</span><br>            String fieldType = userField.getType().getSimpleName();  <span class="hljs-comment">// 获取属性类型</span><br>            System.out.println(modifierName + <span class="hljs-string">&quot; &quot;</span> + fieldType + <span class="hljs-string">&quot; &quot;</span> + fieldName);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Field userField: userFields) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;name&quot;</span>.equals(userField.getName()))&#123;<br>                userField.set(user, <span class="hljs-string">&quot;tom&quot;</span>);   <span class="hljs-comment">//修改属性值</span><br>                System.out.println(userField.get(user).toString());  <span class="hljs-comment">// 获取属性值</span><br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><br/><h2 id="6-通过反射获取方法信息"><a href="#6-通过反射获取方法信息" class="headerlink" title="6. 通过反射获取方法信息"></a>6. 通过反射获取方法信息</h2><p>常用方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>getMethods()</code></td><td>获取类中所有的方法。（不包括 private 修饰的）</td></tr><tr><td><code>getMethod(String name, Class... parameterTypes)</code></td><td>根据方法名和参数列表获取类中的方法。（不能获取 private 修饰的）</td></tr><tr><td><code>getDeclaredMethods()</code></td><td>获取类中所有的方法。（包括 private 修饰的）</td></tr><tr><td><code>getDeclaredMethod(String name, Class... parameterTypes)</code></td><td>根据方法名和参数列表获取类中的方法。（能获取 private 修饰的）</td></tr><tr><td><code>getModifiers()</code></td><td>获取方法的修饰符。</td></tr><tr><td><code>getReturnType()</code></td><td>获取方法的返回值类型。</td></tr><tr><td><code>getExceptionTypes()</code></td><td>获取方法抛出的异常类型。</td></tr><tr><td><code>getName()</code></td><td>获取方法名。</td></tr><tr><td><code>getParameters()</code></td><td>获取方法的参数列表。</td></tr><tr><td><code>getParameterTypes()</code></td><td>获取方法的参数的类型。</td></tr><tr><td><code>getParameterCount()</code></td><td>获取方法的参数个数。</td></tr><tr><td><code>invoke()</code></td><td>调用方法</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;<br>       Class&lt;?&gt; userClass = User.class;<br>       Object user = userClass.newInstance();<br><br>       Method[] userMethods = userClass.getDeclaredMethods();<br>       <span class="hljs-keyword">for</span> (Method userMethod : userMethods) &#123;<br>           String methodName = userMethod.getName();  <span class="hljs-comment">// 获取方法名</span><br>           String userModifiers = Modifier.toString(userMethod.getModifiers()); <span class="hljs-comment">// 获取修饰符</span><br>           String returnType = userMethod.getReturnType().toString(); <span class="hljs-comment">// 获取返回值类型</span><br>           Class&lt;?&gt;[] exceptionTypes = userMethod.getExceptionTypes(); <span class="hljs-comment">// 返回异常类型</span><br>           Parameter[] parameters = userMethod.getParameters();  <span class="hljs-comment">// 获取所有参数</span><br>           Class&lt;?&gt;[] parameterTypes = userMethod.getParameterTypes(); <span class="hljs-comment">// 获取参数类型</span><br>           <span class="hljs-keyword">int</span> parameterCount = userMethod.getParameterCount(); <span class="hljs-comment">// 获取参数个数</span><br>           System.out.println(userModifiers + <span class="hljs-string">&quot; &quot;</span> + returnType + <span class="hljs-string">&quot; &quot;</span> + methodName);<br>       &#125;<br>  <br>  Method doSomething = userClass.getMethod(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>        doSomething.invoke(user);  <span class="hljs-comment">// 调用方法</span><br>   &#125;<br></code></pre></td></tr></table></figure><br/><h2 id="7-通过反射获取构造器"><a href="#7-通过反射获取构造器" class="headerlink" title="7. 通过反射获取构造器"></a>7. 通过反射获取构造器</h2><p>常用方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>getConstructors()</code></td><td>获取当前类中的所有构造器。（不包括 private 修饰的）</td></tr><tr><td><code>getConstructor(Class... parameterTypes)</code></td><td>根据参数列表获取类中特定的构造器。（不能获取 private 修饰的）</td></tr><tr><td><code>getDeclaredConstructors()</code></td><td>获取当前类中的所有构造器。（包括 private 修饰的）</td></tr><tr><td><code>getDeclaredConstructor(Class... parameterTypes)</code></td><td>根据参数列表获取类中特定的构造器。（能获取 private 修饰的）</td></tr><tr><td><code>getName()</code></td><td>获取构造器的名字。</td></tr><tr><td><code>getModifiers()</code></td><td>获取构造器的修饰符。</td></tr><tr><td><code>getParameterTypes()</code></td><td>获取构造器所有参数的参数类型。</td></tr><tr><td><code>getExceptionTypes()</code></td><td>获取构造器抛出的异常类型。</td></tr></tbody></table><br/><h2 id="8-通过反射创建对象"><a href="#8-通过反射创建对象" class="headerlink" title="8. 通过反射创建对象"></a>8. 通过反射创建对象</h2><h3 id="8-1-通过反射使用无参构造器"><a href="#8-1-通过反射使用无参构造器" class="headerlink" title="8.1 通过反射使用无参构造器"></a>8.1 通过反射使用无参构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    Class c = Student.class;<br>  <br>    <span class="hljs-comment">//默认调用类中的无参构造器来创建对象</span><br>    Object obj = c.newInstance();<br>    System.out.println(obj);<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="8-2-通过反射使用有参构造器"><a href="#8-2-通过反射使用有参构造器" class="headerlink" title="8.2 通过反射使用有参构造器"></a>8.2 通过反射使用有参构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    Class c = Student.class;<br>    <span class="hljs-comment">//获取类中的俩参构造器</span><br>    Constructor constructor = c.getConstructor(String.class, <span class="hljs-keyword">int</span>.class);<br>  <br>    <span class="hljs-comment">//调用有参构造器创建对象，并传入对应的参数值</span><br>    Object obj = constructor.newInstance(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);<br>    System.out.println(obj);<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="9-通过反射获取注解"><a href="#9-通过反射获取注解" class="headerlink" title="9. 通过反射获取注解"></a>9. 通过反射获取注解</h2><p>常用方法：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>getAnnotations()</code></td><td>获取类上所有的注解。</td></tr><tr><td><code>getAnnotation(注解名.class)</code></td><td>获取类上的指定注解。</td></tr><tr><td><code>isAnnotationPresent(注解名.class)</code></td><td>是否使用某注解。</td></tr><tr><td><code>annotationType()</code></td><td>获取注解的类型。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注解</title>
    <link href="/2021/06/18/CoreJava/18.%20%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/06/18/CoreJava/18.%20%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>注解（Annotation），是 jdk1.5 引入的技术，用它可以对 java 中的某一个段程序进行说明或标注，并且这个注解的信息可以被其他程序使用特定的方式读取到，从而完成相应的操作。</p><span id="more"></span> <h2 id="1-注解的定义"><a href="#1-注解的定义" class="headerlink" title="1. 注解的定义"></a>1. 注解的定义</h2><p>注解（Annotation），是 jdk1.5 引入的技术，用它可以对 java 中的某一个段程序进行说明或标注，并且这个注解的信息可以被其他程序使用特定的方式读取到，从而完成相应的操作。</p><p>例如 <code>@Override</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>注解和注释的区别：</p><ul><li>注解是给其他程序看的，通过参数的设置，可以在编译后 class 文件中保留注解的信息，其他程序读取后，可以完成特定的操作。 </li><li>注释是给程序员看的，无论怎么设置，编译后 class 文件中都是【没有】注释信息，方便程序员快速了解代码的作用或结构。</li></ul><br/><h2 id="2-Java-的内置注解"><a href="#2-Java-的内置注解" class="headerlink" title="2. Java 的内置注解"></a>2. Java 的内置注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 <code>java.lang</code> 中，剩下 4 个在 <code>java.lang.annotation</code> 中。</p><p>作用在代码的注解是：</p><ul><li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li><li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。</li></ul><p>作用在其他注解的注解（元注解）：</p><ul><li><code>@Retention</code> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</li><li><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。</li><li><code>@Inherited</code> - 标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)</li></ul><p>从 Java 7 开始，额外添加了 3 个注解:</p><ul><li><code>@SafeVarargs</code> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><code>@FunctionalInterface</code> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li><code>@Repeatable</code> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><br/><h2 id="3-Annotation-接口"><a href="#3-Annotation-接口" class="headerlink" title="3. Annotation 接口"></a>3. Annotation 接口</h2><h3 id="3-1-Annotation-接口的结构"><a href="#3-1-Annotation-接口的结构" class="headerlink" title="3.1 Annotation 接口的结构"></a>3.1 Annotation 接口的结构</h3><img src="https://i.loli.net/2021/06/18/qgfIcj7kQaedTn2.png" alt="Annotation结构.png" style="zoom: 50%;" /><ul><li><p>1 个 Annotation 和 1 个 RetentionPolicy 关联。</p><p>可以理解为：每1个 Annotation 对象，都会有唯一的 RetentionPolicy 属性。</p></li></ul><ul><li><p>1 个 Annotation 和 1~n 个 ElementType 关联。</p><p>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</p></li><li><p>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</p></li></ul><br/><h3 id="3-2-Annotation-组成部分"><a href="#3-2-Annotation-组成部分" class="headerlink" title="3.2 Annotation 组成部分"></a>3.2 Annotation 组成部分</h3><p>java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：</p><ul><li>Annotation 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Annotation</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;<br><br>    Class&lt;? extends Annotation&gt; annotationType();  <br>&#125;<br></code></pre></td></tr></table></figure><br/><ul><li>枚举类型 ElementType</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ElementType</span> </span>&#123;<br>    TYPE,               <span class="hljs-comment">/* 类、接口（包括注释类型）或枚举声明  */</span><br><br>    FIELD,              <span class="hljs-comment">/* 字段声明（包括枚举常量）  */</span><br><br>    METHOD,             <span class="hljs-comment">/* 方法声明  */</span><br><br>    PARAMETER,          <span class="hljs-comment">/* 参数声明  */</span><br><br>    CONSTRUCTOR,        <span class="hljs-comment">/* 构造方法声明  */</span><br><br>    LOCAL_VARIABLE,     <span class="hljs-comment">/* 局部变量声明  */</span><br><br>    ANNOTATION_TYPE,    <span class="hljs-comment">/* 注释类型声明  */</span><br><br>    PACKAGE             <span class="hljs-comment">/* 包声明  */</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><ul><li>枚举类型 RetentionPolicy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RetentionPolicy</span> </span>&#123;<br>    SOURCE,            <span class="hljs-comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该注解信息了  */</span><br><br>    CLASS,             <span class="hljs-comment">/* 编译器将注解存储于类对应的.class文件中。默认行为  */</span><br><br>    RUNTIME            <span class="hljs-comment">/* 编译器将注解存储于class文件中，并且可由JVM读入 */</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="4-自定义注解的写法"><a href="#4-自定义注解的写法" class="headerlink" title="4. 自定义注解的写法"></a>4. 自定义注解的写法</h2><p>日常开发中新建 Java 类，我们使用 class、interface 比较多，而注解和它们一样，也是一种类的类型，他是用的修饰符为 @interface。</p><p>使用 @interface 定义注解时，意味着它实现了 <code>java.lang.annotation.Annotation</code> 接口。它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名称 &#123;<br>  <span class="hljs-keyword">public</span> 属性类型 属性名();   <span class="hljs-comment">// 实际上是一个抽象方法，但是可以在括号里传值。</span><br><span class="hljs-comment">// public 属性类型 属性名() default 默认值;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>public 可以省去不写，默认就是 public。</p><br/><h3 id="4-1-注解属性类型"><a href="#4-1-注解属性类型" class="headerlink" title="4.1 注解属性类型"></a>4.1 注解属性类型</h3><ul><li><p>基本数据类型</p></li><li><p>String 类型</p></li><li><p>枚举类型</p></li><li><p>注解类型</p></li><li><p>Class 类型</p></li><li><p>以上类型的一维数组类型</p></li></ul><br/><h3 id="4-2-注解成员变量赋值"><a href="#4-2-注解成员变量赋值" class="headerlink" title="4.2 注解成员变量赋值"></a>4.2 注解成员变量赋值</h3><p>如果注解又多个属性，则可以在注解括号中用“，”号隔开分别给对应的属性赋值，如下例子，注解在父类中赋值属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;mao&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 18</span>;<br>&#125;<br><br><span class="hljs-meta">@MyTestAnnotation(name = &quot;father&quot;,age = 50)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="5-元注解"><a href="#5-元注解" class="headerlink" title="5. 元注解"></a>5. 元注解</h2><p>在我们进行自定义注解的时候，一般会使用到元注解，来设置自定义注解的基本特点。所以，<strong>元注解也就是对注解进行基本信息设置的注解</strong>。</p><p>元注解分别有：</p><ul><li><p><code>@Target</code>：用于描述注解的使用范围，例如用在类上面还是方法上面。</p></li><li><p><code>@Retention</code>：用于描述注解的保存策略，是保留到源代码中、字节码文件中、还是加载到内存中。</p></li><li><p><code>@Documented</code>：用于描述该注解将会被 javadoc 生产到 API 文档中 。</p></li><li><p><code>@Inherited</code>：用于表示某个被标注的类型是被继承的，如果一个使用了<code>@Inherited</code>修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该 class 的子类。</p></li><li><p><code>@Repeatable</code>（JDK1.8加入）：用于标识某注解可以在同一个声明上使用多次。</p></li></ul><br/><h3 id="5-1-Target"><a href="#5-1-Target" class="headerlink" title="5.1 @Target"></a>5.1 @Target</h3><p>使用 <code>@Target</code> 元注解<strong>表示注解作用的范围</strong>。注解的使用范围，都定义在了一个枚举类  ElementType 中。</p><ul><li><code>@Target(ElementType.TYPE)</code> ：作用接口、类、枚举、注解。</li><li><code>@Target(ElementType.PACKAGE) </code>：作用于包。</li><li><code>@Target(ElementType.FIELD)</code> ：作用属性字段、枚举的常量。</li><li><code>@Target(ElementType.METHOD)</code> ：作用方法。</li><li><code>@Target(ElementType.PARAMETER) </code>：作用方法参数。</li><li><code>@Target(ElementType.CONSTRUCTOR) </code>：作用构造函数。</li><li><code>@Target(ElementType.LOCAL_VARIABLE)</code>：作用局部变量。</li><li><code>@Target(ElementType.ANNOTATION_TYPE)</code>：作用于注解。（@Retention注解中就使用该属性）</li><li><code>@Target(ElementType.TYPE_PARAMETER)</code> ：作用于类型泛型，即泛型方法、泛型类、泛型接口。（jdk1.8加入）</li><li><code>@Target(ElementType.TYPE_USE)</code>： 类型使用，可以用于标注任意类型除了 class 。（jdk1.8加入）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="5-2-Retention"><a href="#5-2-Retention" class="headerlink" title="5.2 @Retention"></a>5.2 @Retention</h3><p>使用 <code>@Retention</code> 元注解<strong>表示注解存在阶段</strong>。通过使用枚举类 RetentionPolicy 来表示注解保留时期。</p><ul><li><code>@Retention(RetentionPolicy.SOURCE)</code>：注解仅存在于源码中，在 class 字节码文件中不包含。</li><li><code>@Retention(RetentionPolicy.CLASS)</code>：默认的保留策略，注解会在 class 字节码文件中存在，但运行时无法获得。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>： 注解会 JVM 内存中存在，在运行时可以通过反射获取到。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用情形：</p><ul><li>如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解。</li><li>如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就用 CLASS 注解。</li><li>如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，使用 SOURCE 注解。</li></ul><p>因为 RUNTIME 的生命周期最长，所以其他俩种情况能作用到的阶段，使用 RUNTIME 也一定能作用到。</p><br/><h3 id="5-3-Inherited"><a href="#5-3-Inherited" class="headerlink" title="5.3 @Inherited"></a>5.3 @Inherited</h3><p>一个被 <code>@Inherited</code>注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**自定义注解*/</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br>&#125;<br><br><span class="hljs-comment">/**父类标注自定义注解*/</span><br><span class="hljs-meta">@MyTestAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br><br><span class="hljs-comment">/**子类*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br><br><span class="hljs-comment">/**测试子类获取父类自定义注解*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><br>      <span class="hljs-comment">//获取 Son 的 class 对象</span><br>       Class&lt;Son&gt; sonClass = Son.class;<br>      <span class="hljs-comment">// 获取Son类上的注解 MyTestAnnotation 可以执行成功</span><br>      MyTestAnnotation annotation = sonClass.getAnnotation(MyTestAnnotation.class);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="5-4-Documented"><a href="#5-4-Documented" class="headerlink" title="5.4 @Documented"></a>5.4 @Documented</h3><p>它的作用是能够将注解中的元素包含到 Javadoc 中去。</p><br/><h3 id="5-5-Repeatable"><a href="#5-5-Repeatable" class="headerlink" title="5.5 @Repeatable"></a>5.5 @Repeatable</h3><p>被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**一个人喜欢玩游戏，他喜欢玩英雄联盟，绝地求生，极品飞车，尘埃4等，则我们需要定义一个人的注解，他属性代表喜欢玩游戏集合，一个游戏注解，游戏属性代表游戏名称*/</span><br><br><span class="hljs-comment">/**玩家注解*/</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> People &#123;<br>    Game[] value() ;<br>&#125;<br><br><span class="hljs-comment">/**游戏注解*/</span><br><span class="hljs-meta">@Repeatable(People.class)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Game &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">/**玩游戏类*/</span><br><span class="hljs-meta">@Game(value = &quot;LOL&quot;)</span><br><span class="hljs-meta">@Game(value = &quot;PUBG&quot;)</span><br><span class="hljs-meta">@Game(value = &quot;NFS&quot;)</span><br><span class="hljs-meta">@Game(value = &quot;Dirt4&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayGame</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="6-注解的作用"><a href="#6-注解的作用" class="headerlink" title="6. 注解的作用"></a>6. 注解的作用</h2><h3 id="6-1-编译检查"><a href="#6-1-编译检查" class="headerlink" title="6.1 编译检查"></a>6.1 编译检查</h3><p> 注解具有“让编译器进行编译检查的作用”。</p><p>例如：@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。 </p><br/><h3 id="6-2-在反射中使用注解"><a href="#6-2-在反射中使用注解" class="headerlink" title="6.2 在反射中使用注解"></a>6.2 在反射中使用注解</h3><p>在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。</p><p>这也意味着，我们可以在反射中解析并使用 Annotation。</p><br/><h3 id="6-3-根据-Annotation-生成帮助文档"><a href="#6-3-根据-Annotation-生成帮助文档" class="headerlink" title="6.3 根据 Annotation 生成帮助文档"></a>6.3 根据 Annotation 生成帮助文档</h3><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p><br/><h3 id="6-4-能够帮忙查看查看代码"><a href="#6-4-能够帮忙查看查看代码" class="headerlink" title="6.4 能够帮忙查看查看代码"></a>6.4 能够帮忙查看查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p><p>另外，我们也可以通过自定义 Annotation 来实现一些功能。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举</title>
    <link href="/2021/06/18/CoreJava/17.%20%E6%9E%9A%E4%B8%BE/"/>
    <url>/2021/06/18/CoreJava/17.%20%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<p>枚举，是 JDK1.5 引入的新特性，可以通过关键字 enum 来定义枚举类。</p><span id="more"></span><h2 id="1-枚举的定义"><a href="#1-枚举的定义" class="headerlink" title="1. 枚举的定义"></a>1. 枚举的定义</h2><ul><li>枚举，是 JDK1.5 引入的新特性，可以通过关键字 enum 来定义枚举类。 </li><li>枚举类是一种特殊的类，它和普通类一样可以使用构造器、定义成员变量和方法，也能实现一个或多个接口。 但是<strong>枚举类不能继承其他类。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123;<br>BLACK, WHITE<br>&#125;<br></code></pre></td></tr></table></figure><p><code>public enum Color</code> ，表示这是一个枚举类型，名字叫 Color 。</p><p><code>BLACK, WHITE</code> 表示这个枚举类型有俩个固定的对象，一个叫 BLACK，另一个叫 WHITE。</p><br/><p>使用 javap 命令对Color.class文件进行反向解析：</p><img src="https://i.loli.net/2021/06/18/tkOny1p3wcAbBlZ.png" alt="反编译枚举类.png" style="zoom: 67%;" /><p>可以看出：</p><ul><li><p>枚举类是一个 final 修饰的类，枚举类型都会默认继承<code>java.lang.Enum</code> 类，而不是 Object 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">E</span>&gt;&gt;</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>枚举中所定义的对象，其实就是类里面的 <code>public static final </code>修饰的常量，并且这些常量会在静态代码块中做初始化。 </p></li><li><p>枚举类型中还一个默认的私有构造器，说明我们在外面并不能自己去创建枚举类型的对象。</p></li><li><p>枚举类型中还有默认添加进来的方法 </p><ul><li><p><code>values() </code>：可以返回这个枚举类型的所有对象，返回类型是数组。</p></li><li><p><code>valueOf(String str)</code> ：通过一个字符串可以返回枚举对象，这个字符串参数就是枚举对象的名字 。</p></li></ul></li><li><p>枚举类型会从父类中继承过来一些方法（具体可以查看其固定的父类型）</p><ul><li><p><code>String name()</code>：返回这个枚举对象的名字 。</p></li><li><p><code>int ordinal()</code>：返回这个枚举对象的编号，默认从 0 开始。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//声明枚举类型的引用</span><br>    Color c;<br>  <br>    <span class="hljs-comment">//引用指向对象</span><br>    c = Color.BLACK;<br>  <br>    <span class="hljs-comment">//默认调用toString方法，父类中重写了toString方法，返回枚举对象的名字</span><br>    System.out.println(c);<br>  <br>    <span class="hljs-comment">//引用指向对象</span><br>    c = Color.WHITE;<br>  <br>    <span class="hljs-comment">//默认调用toString方法，父类中重写了toString方法，返回枚举对象的名字</span><br>    System.out.println(c);<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>BLACK<br>WHITE<br></code></pre></td></tr></table></figure><br/><h2 id="2-意义"><a href="#2-意义" class="headerlink" title="2. 意义"></a>2. 意义</h2><p>java中的类，从语法形式上来说，可以创建出一个类的无数个对象。 例如，学生类 Student，我们可以创建出10个、20个等不同数量的学生对象，并且从意义讲确实也没有问题，因为实际情况中确实会存在很多不同的学生。 </p><p>但是这其实还存在另一种情况：一个类的对象，从意义上来说，对象个数是固定的。 例如， Gender 这个类，表示人的性别，从语法上来说，可以创建出无数个性别对象，但是从实际意义 上看，我们只需要俩个对象就可以了，一个表示男、一个表示女。 </p><p>那么，在这个时候，我们就需要去对 Gender 类的对象创建作出限制，不让用户创建很 Gender 类型的对象，因为如果创建了很多对象，那么会占用内存空间，同时这么多对象也没什么实际意义，最终还是只能表示俩种情况，男和女。 </p><p>解决这个问题的方式是，可以将 Gender 定义为一个枚举类型（enum），我们就可以在枚举类型中，提前将这个类型的对象个数和对象名字都固定下来，并且之后的使用中不会改变，也不会再创建其他对象。</p><br/><h2 id="3-获取枚举对象"><a href="#3-获取枚举对象" class="headerlink" title="3. 获取枚举对象"></a>3. 获取枚举对象</h2><p>以 Gender 这个枚举类型为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span></span>&#123;<br>MALE,FEMALE<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>方式1：使用类名直接访问类中定义的对象。</p><p>因为类中定义的对 static final 修饰的态常量，所以可以使用 <code>类名.对象</code>的方式访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  <br>    <span class="hljs-comment">//最常用的一种方式</span><br>    Gender g = Gender.MALE;<br>    g = Gender.FEMALE;<br>  <br>    <span class="hljs-comment">//可以调用从父类型Enum以及Object中继承过来的方法</span><br>    System.out.println(g.name());<br>    System.out.println(g.ordinal());<br>    System.out.println(g.toString());<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>方式2：通过 <code>valueOf()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><span class="hljs-comment">//通过字符串参数，可以获取到 Gender 中的指定的一个对象</span><br>    String name = <span class="hljs-string">&quot;MALE&quot;</span>;<br>    Gender g = Gender.valueOf(name);<br>    System.out.println(g.name());<br>    System.out.println(g.ordinal());<br>    System.out.println(g.toString());<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>方法3：通过 <code>Enum.valueOf()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//通过字符串确定是哪一个枚举类型</span><br>    Class c = Class.forName(<span class="hljs-string">&quot;com.briup.demo.Genger&quot;</span>);<br>  <br>    <span class="hljs-comment">//通过字符串确定是哪一个名字的枚举对象</span><br>    String name = <span class="hljs-string">&quot;FEMALE&quot;</span>;<br>  <br>    <span class="hljs-comment">//可以通过改变字符串，获取到java中任何一个枚举类型中的任意一个枚举对象</span><br>    Enum g = Enum.valueOf(c,name);<br>    System.out.println(g.name());<br>    System.out.println(g.ordinal());<br>    System.out.println(g.toString());<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="4-枚举中定义属性和方法"><a href="#4-枚举中定义属性和方法" class="headerlink" title="4. 枚举中定义属性和方法"></a>4. 枚举中定义属性和方法</h2><p>在枚举类型中，除了可以指定对象的个数和名称之外，还可以定义属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span></span>&#123;<br>  MALE,FEMALE;<br>  <span class="hljs-keyword">private</span> String name;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;Gender test...&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String name)</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;hello &quot;</span>+name);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  Gender g = Gender.MALE;<br>  g.test();<br>  g.setName(<span class="hljs-string">&quot;我是男生&quot;</span>);<br>  System.out.println(g.getName());<br>  Gender.print(<span class="hljs-string">&quot;jack&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类型中的第一行代码，要求一定是指定枚举对象的个数和名字，同时最后面加分号。</p><p>在这行代码下， 才可以定义枚举类型的属性和方法。</p><br/><h2 id="5-枚举中定义构造器"><a href="#5-枚举中定义构造器" class="headerlink" title="5. 枚举中定义构造器"></a>5. 枚举中定义构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span></span>&#123;<br>  MALE,FEMALE;<br>  <span class="hljs-keyword">private</span> String name;<br>  <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Gender</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Gender</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Gender&#123;name=&quot;</span>+name+<span class="hljs-string">&quot;&#125;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举中的构造器，只能使用 private 修饰，或者不写修饰符，那么默认也是 private，同时还可以构造器重载。</p><p>调用构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//该代码，可以对Gender.class进行类加载</span><br>    Class.forName(<span class="hljs-string">&quot;com.briup.demo.Gender&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>有参构造器被调用<br>有参构造器被调用<br></code></pre></td></tr></table></figure><br/><h2 id="6-枚举中定义抽象方法"><a href="#6-枚举中定义抽象方法" class="headerlink" title="6.  枚举中定义抽象方法"></a>6.  枚举中定义抽象方法</h2><p>枚举类中定义抽象方法，必须将抽象方法进行实现。因为枚举类型是 final 修饰的类，不可能有子类型来实现这个抽象方法，所以就必须是自己的对象去实现这个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span></span>&#123;<br>    MALE()&#123;<br>    <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男生测试&quot;</span>);<br>        &#125;<br>     &#125;,FEMALE()&#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;女生测试&quot;</span>);<br>          &#125;<br>      &#125;;<br>  <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法和匿名内部类的写法很相似， <code>MALE()&#123;...&#125;,</code> <code>FEMALE()&#123;...&#125;;</code></p><br/><h2 id="7-枚举类实现接口"><a href="#7-枚举类实现接口" class="headerlink" title="7. 枚举类实现接口"></a>7. 枚举类实现接口</h2><p>枚举类型已经有默认的父类型<code>java.lang.Enum</code>，我们就不能让它在继承其他父类了，但是我们可以让枚举类型实现指定的接口。</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>MALE,FEMALE;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;枚举中统一实现接口中的抽象方法&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>    MALE()&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男生对象中，单独实现接口中的抽象方法&quot;</span>);<br>&#125;<br>&#125;,FEMALE()&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;女生对象中，单独实现接口中的抽象方法&quot;</span>);<br>      &#125;<br>&#125;;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="8-枚举使用总结"><a href="#8-枚举使用总结" class="headerlink" title="8. 枚举使用总结"></a>8. 枚举使用总结</h2><p>对于枚举类型的使用，大多数情况下，我们在枚举中列出它的的每一个对象即可，偶尔会添加几个自定义的属性和方法，并不会写的那么复杂，否则就没什么意义了。 </p><p>在项目中，只要一个类型的对象个数和名称能固定下来的，就可以考虑使用枚举类型来表示。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2021/06/15/CoreJava/16.%20%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2021/06/15/CoreJava/16.%20%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>集合是 JavaAPI 中提供的一种容器工具，可以用来存储多个数据。 </p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>集合是 JavaAPI 中提供的一种容器工具，可以用来存储多个数据。 </p><h3 id="1-1-集合和数组之间的区别"><a href="#1-1-集合和数组之间的区别" class="headerlink" title="1.1 集合和数组之间的区别"></a>1.1 集合和数组之间的区别</h3><ul><li><p>数组的长度是固定的，集合的长度是可变的。</p></li><li><p>数组中存储的是同一类型的元素，集合中存储的数据可以是不同类型的。</p></li><li><p>数组中可以存放基本类型数据或者对象，集合中只能存放对象。 </p></li><li><p>数组是由 JVM 中现有的类型+[] 组合而成的，除了一个 length 属性，还有从 Object 中继承过来的方法之外，数组对象就调用不到其他属性和方法。 </p></li><li><p>集合是由 JavaAPI 中的 java.util 包里面所提供的接口和实现类组成的，这里面定义并实现了很多方法，可以使用集合对象直接调用这些方法，从而操作集合存放的数据。</p></li></ul><br/><h3 id="1-2-集合框架中主要有三个要素组成"><a href="#1-2-集合框架中主要有三个要素组成" class="headerlink" title="1.2 集合框架中主要有三个要素组成"></a>1.2 集合框架中主要有三个要素组成</h3><ol><li><p>接口：整个集合框架的上层结构，都是用接口进行组织的。 接口中定义了集合中必须要有的基本方法。 通过接口还把集合划分成了几种不同的类型，每一种集合都有自己对应的接口。 </p></li><li><p>实现类：对于上层使用接口划分好的集合种类，每种集合的接口都会有对应的实现类。 每一种接口的实现类很可能有多个，每个的实现方式也会各有不同。 </p></li><li><p>数据结构：每个实现类都实现了接口中所定义的最基本的方法，例如对数据的存储、检索、操作等方法。 但是不同的实现类，它们存储数据的方式不同，也就是使用的数据结构不同。</p></li></ol><br/><h3 id="1-3-集合的分类"><a href="#1-3-集合的分类" class="headerlink" title="1.3 集合的分类"></a>1.3 集合的分类</h3><p>按照其存储结构可以分为两大类： <code>java.util.Collection</code> 和 <code>java.util.Map</code>。其他的集合接口，都是由这俩个接口派生出来的。</p><br/><h2 id="2-Collection-接口"><a href="#2-Collection-接口" class="headerlink" title="2. Collection 接口"></a>2. Collection 接口</h2><h3 id="2-1-Collection-框架的结构图"><a href="#2-1-Collection-框架的结构图" class="headerlink" title="2.1 Collection 框架的结构图"></a>2.1 Collection 框架的结构图</h3><p>Collection 接口是单列集合类的父接口，这种集合可以将数据一个一个的存放到集合中。它有两个重要的子接口，分别是 <code>java.util.List</code> 和 <code>java.util.Set</code>。（下图展示的只是一部分，详情查看 API）</p><img src="https://i.loli.net/2021/06/15/pbLlatR7QhSjdIB.png" alt="Collecton结构.png" style="background-color: #fff;"  /><br/><h3 id="2-2-Collection-集合的方法"><a href="#2-2-Collection-集合的方法" class="headerlink" title="2.2 Collection 集合的方法"></a>2.2 Collection 集合的方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>向集合中添加元素。</td></tr><tr><td><code>boolean addAll(Collection c)</code></td><td>把一个指定集合中的所有数据，添加到当前集合中。</td></tr><tr><td><code>boolean contains(Object o) </code></td><td>判断当前集合中是否包含给定的对象。</td></tr><tr><td><code>boolean containsAll(Collection c)</code></td><td>判断当前集合中是否包含给定的集合的所有元素。</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>把给定的对象，在当前集合中删除。</td></tr><tr><td><code>boolean removeAll(Collection c)</code></td><td>把给定的集合中的所有元素，在当前集合中删除。</td></tr><tr><td><code>void clear()</code></td><td>清空集合中所有的元素。</td></tr><tr><td><code>boolean retainAll(Collection c)</code></td><td>判断俩个集合中是否有相同的元素，如果有当前集合只保留相同元素，如果没有则清空。</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断当前集合是否为空。</td></tr><tr><td><code>Iterator iterator() </code></td><td>返回遍历这个集合的迭代器对象。</td></tr><tr><td><code>int size() </code></td><td>返回集合中元素的个数。</td></tr><tr><td><code>Object[] toArray()</code></td><td>把集合中的元素，存储到数组中。</td></tr><tr><td><code>T[] toArray(T[] a)</code></td><td>把集合中的元素，存储到数组中，并指定数组的类型。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// ArrayList 类是 Collection 集合的一个实现类。</span><br>    Collection c1 = <span class="hljs-keyword">new</span> ArrayList();<br>    c1.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>    c1.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>    c1.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>  <br>    <span class="hljs-comment">//默认调用集合的toString方法，输出集合中内容</span><br>    System.out.println(<span class="hljs-string">&quot;操作之前集合中元素:&quot;</span>+c1);<br>    System.out.println(<span class="hljs-string">&quot;集合中的元素个数：&quot;</span>+c1.size());<br>    System.out.println(<span class="hljs-string">&quot;集合中是否包含hello1：&quot;</span>+c1.contains(<span class="hljs-string">&quot;hello1&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;删除hello1：&quot;</span>+c1.remove(<span class="hljs-string">&quot;hello1&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;操作之后集合中元素:&quot;</span>+c1);<br>  <br>    Object[] objects = c1.toArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;<br>    System.out.println(objects[i]);<br>    &#125;<br>    c1.clear();<br>    System.out.println(<span class="hljs-string">&quot;集合中内容为：&quot;</span>+c1);<br>    System.out.println(c1.isEmpty());<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="3-Iterator-迭代器"><a href="#3-Iterator-迭代器" class="headerlink" title="3. Iterator 迭代器"></a>3. Iterator 迭代器</h2><p>为了能够方便的遍历集合中的每一个元素，API 中提供了一个迭代器接口： <code>java.util.Iterator</code>。使用该接口可以很方便的迭代出集合中的元素。<code>java.lang.Iterable</code> 接口中，定义了获取迭代器的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span> </span>&#123;<br><span class="hljs-function">Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p><code>java.util.Collection</code> 接口继承了 <code>java.lang.Iterable</code> 接口，所以 Collection 接口及其子接口中，都有 <code>Iterator iterator()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterable</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><p><code>java.util.Iterator</code> 接口中，主要定义俩个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回当前迭代器中是否还有下一个对象</span><br>    <span class="hljs-function">Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//获取迭代器中的下一个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><p>迭代器方式获取集合中的每一个元素，是 Collection 集合及其子类型集合通用的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection c1 = <span class="hljs-keyword">new</span> ArrayList();<br>    c1.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>    c1.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>    c1.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>  <br><span class="hljs-comment">//获取c1集合的迭代器对象</span><br>Iterator iterator = c1.iterator();<br>  <br><span class="hljs-comment">//判断迭代器中，是否还有下一个元素</span><br>    <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>        <span class="hljs-comment">//如果有的话，就取出来</span><br>        Object obj = iterator.next();<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="4-List-集合"><a href="#4-List-集合" class="headerlink" title="4. List 集合"></a>4. List 集合</h2><p><code>java.util.List</code> 接口继承了 Collection 接口，是常用的一种集合类型。 </p><h3 id="4-1-List-集合的特点"><a href="#4-1-List-集合的特点" class="headerlink" title="4.1 List 集合的特点"></a>4.1 List 集合的特点</h3><ul><li>List 是一种有序的集合。 例如，向集合中存储的元素顺序是 8、2、5。那么集合中就是按照这个顺序进行存储的。</li><li>List 是一种带索引的集合，可以通过元素的下标索引，精确查找对应的元素数据。</li><li>List 是一种可以存放重复数据的集合可以把相同的数据，在 List 集合中多次保存。</li></ul><br/><h3 id="4-2-List-接口中的方法"><a href="#4-2-List-接口中的方法" class="headerlink" title="4.2 List 接口中的方法"></a>4.2 List 接口中的方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>E get(int index)</code></td><td>返回集合中指定位置的元素。</td></tr><tr><td><code> int indexOf(Object o)</code></td><td>查找定元素在集合中的索引（从前往后查到的第一个元素）。</td></tr><tr><td><code>int lastIndexOf(Object o)</code></td><td>查收指定元素在集合中的索引（从后往前查到的第一个元素）。</td></tr><tr><td><code>void add(int index, E element)</code></td><td>将指定的元素，添加到该集合中的指定位置上。</td></tr><tr><td><code>boolean addAll(int index, Collection c)</code></td><td>从指定位置开始，把另一个集合的所有元素添加进来。</td></tr><tr><td><code>E set(int index, E element)</code></td><td>用指定元素替换集合中指定位置的元素,并返回被替代的旧元素。</td></tr><tr><td><code>E remove(int index)</code></td><td>移除列表中指定位置的元素, 并返回被移除的元素。</td></tr><tr><td><code>List subList(int fromIndex, int toIndex)</code></td><td>根据指定开始和结束位置，截取出集合中的一部分数据。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建List集合对象</span><br>    List list = <span class="hljs-keyword">new</span> ArrayList();<br>  <br>    <span class="hljs-comment">// 往尾部添加 指定元素</span><br>    list.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>    System.out.println(list);<br>  <br>    <span class="hljs-comment">// add(int index,String s) 往指定位置添加</span><br>    list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>    System.out.println(list);<br>  <br>    <span class="hljs-comment">// 删除索引位置为2的元素</span><br>    System.out.println(<span class="hljs-string">&quot;删除索引位置为2的元素&quot;</span>);<br>    System.out.println(list.remove(<span class="hljs-number">2</span>));<br>    System.out.println(list);<br>  <br>    <span class="hljs-comment">// 修改指定位置元素</span><br>    list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;briup&quot;</span>);<br>    System.out.println(list);<br>  <br>    <span class="hljs-comment">// 遍历集合</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>  <br>    <span class="hljs-comment">// 使用foreach遍历</span><br>    <span class="hljs-keyword">for</span>(Object obj : list)&#123;<br>    System.out.println(obj);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>  <br>    <span class="hljs-comment">// 使用迭代器进行遍历集合</span><br>    Iterator it = list.iterator();<br>    <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>        Object obj = it.next();<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-3-ArarryList"><a href="#4-3-ArarryList" class="headerlink" title="4.3 ArarryList"></a>4.3 ArarryList</h3><p><code>java.util.ArrayList</code> 是最常用的一种 List 类型集合。 </p><ul><li>ArrayList 类中使用数组来实现数据的存储， 所以它的特点是就是：<strong>增删慢，查找快。</strong> </li><li>在日常的开发中，查询数据也是用的最多的功能，所以 ArrayList 是最常用的集合。 但是，如果项目中对性能要求较高，并且在集合中大量的数据做增删操作，那么 ArrayList 就不太适合了。</li></ul><br/><h3 id="4-4-Vector"><a href="#4-4-Vector" class="headerlink" title="4.4 Vector"></a>4.4 Vector</h3><p>Vector 内部也是<strong>采用了数组来存储数据</strong>。但是 Vector 中方法的定义，可以看到多大数方法都使用了 synchronized 关键字，来给当前方法加锁。所以 Vector 中的方法大多数都是<strong>线程安全</strong>的方法，在多线并发访问的环境中，可以使用 Vector 来保证集合中元据操作的安全。</p><br/><h3 id="4-5-LinkedList"><a href="#4-5-LinkedList" class="headerlink" title="4.5 LinkedList"></a>4.5 LinkedList</h3><h4 id="4-5-1-特点"><a href="#4-5-1-特点" class="headerlink" title="4.5.1 特点"></a>4.5.1 特点</h4><ul><li><p><code>java.util.LinkedList</code> 存储数据采用的数据结构是链表，所以它的特点是：<strong>增删快，查找慢</strong>。这里描述的快和慢，需要在大量的数据操作下，才可以体现，<strong>如果数据量不大的话，集合每一种集合的操作几乎没有任何区别</strong>。</p></li><li><p><strong>线程不安全，但是效率高</strong>。</p></li></ul><br/><h4 id="4-5-2-结构"><a href="#4-5-2-结构" class="headerlink" title="4.5.2 结构"></a>4.5.2 结构</h4><img src="https://i.loli.net/2021/06/15/U9xHFIu7nojDOba.png" style= "background-color : #fff;"><p>LinkedList 是一个双向链表。除了头节点（head）和尾节点（tail）之外，其他节点都含有俩个引用，一 个引用指向它的上一个节点，另一个引用指向它的的下一个节点。</p><h4 id="4-5-3-特有方法"><a href="#4-5-3-特有方法" class="headerlink" title="4.5.3 特有方法"></a>4.5.3 特有方法</h4><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>void addFirst(E e) </code></td><td>将指定元素插入此列表的开头。</td></tr><tr><td><code>void addLast(E e) </code></td><td>将指定元素添加到此列表的结尾。</td></tr><tr><td><code>E getFirst()</code></td><td>返回此列表的第一个元素。</td></tr><tr><td><code>E getLast() </code></td><td>返回此列表的最后一个元素。</td></tr><tr><td><code>E pop() </code></td><td>从此列表所表示的堆栈处弹出一个元素。</td></tr><tr><td><code>void push(E e) </code></td><td>将元素推入此列表所表示的堆栈。</td></tr><tr><td><code>E removeFirst() </code></td><td>移除并返回此列表的第一个元素。</td></tr><tr><td><code>E removeLast()</code></td><td>移除并返回此列表的最后一个元素。</td></tr></tbody></table><h4 id="4-5-4-队列"><a href="#4-5-4-队列" class="headerlink" title="4.5.4 队列"></a>4.5.4 队列</h4><p>LinkedList 类不仅实现了 List 接口，还实现了 Queue 接口以及子接口 Deque。</p><img src="https://i.loli.net/2021/06/15/3JUAS9pxuLWeHdf.png" ><p>Queue 是队列接口， Deque 是双端队列。 </p><p>JavaAPI 中提供了 <code>java.util.Stack</code> 来实现栈结构，但官方目前已不推荐使用，而是推荐使用 <code>java.util.Deque</code> 双端队列来实现队列与栈的各种需求。所以 LinkedList 同时具有队列和栈的操作方法，pop 和 push 都是栈结构的操作方法。所以， <strong>LinkedList 集合也可以作为栈和队列的数据结构来使用</strong>。</p><br/><h2 id="5-Set-集合"><a href="#5-Set-集合" class="headerlink" title="5. Set 集合"></a>5. Set 集合</h2><p><code>java.util.Set</code> 接口继承了 Collection 接口，是常用的一种集合类型。 </p><h3 id="5-1-Set-集合的特点"><a href="#5-1-Set-集合的特点" class="headerlink" title="5.1 Set 集合的特点"></a>5.1 Set 集合的特点</h3><ul><li>Set 是一种无序的集合。</li><li>Set 是一种不带下标索引的集合。</li><li>Set 是一种不能存放重复数据的集合。</li><li>Set 接口中的方法，都继承自它的父接口，即 set 接口中没有特有的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello4&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello5&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello5&quot;</span>); <br>  <span class="hljs-comment">// 不会编译报错，但是不会加到集合里，即集合中就只有一个 hello5。</span><br><br>        <span class="hljs-comment">// 使用 foreach 打印集合内的元素。</span><br>        <span class="hljs-keyword">for</span>(Object obj:set)&#123;<br>            System.out.println(obj);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br><br>        <span class="hljs-comment">// 使用迭代器打印集合内的元素。</span><br>        Iterator&lt;String&gt; it = set.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            Object obj = it.next();<br>            System.out.println(obj);<br>        &#125;<br><br>        <span class="hljs-comment">// 两次打印结果相同：hello1 hello4 hello5 hello2 hello3 </span><br>        <span class="hljs-comment">// set 的无序性体现在：集合内存放的顺序和添加的顺序不同。</span><br>      <br>    &#125;<br></code></pre></td></tr></table></figure><br/><h3 id="5-2-HashSet"><a href="#5-2-HashSet" class="headerlink" title="5.2 HashSet"></a>5.2 HashSet</h3><p><code>java.util.HashSet</code> 类的实现，主要依靠的是 HashMap，而 HashMap 的实现主要是利用哈希表。</p><p>HashSet 为什么是无序的，它是怎么判断元素是否是重复的？</p><ul><li>HashSet 中存储元素是无序的，主要因为它是<strong>靠对象的哈希值来确定元素在集合中的存储位置</strong>。 </li><li>HashSet 中元素不可重复，主要是<strong>靠对象的 hashCode 和 equals 方法来判断对象是否重复</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  String name;<br>  <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br>  <br><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set set = <span class="hljs-keyword">new</span> HashSet();<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>      System.out.println(obj);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果为：</span><br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，HashSet 并没有把 name 和 age 都相同的对象，当做相同的对象进行去重。原因是，<strong>HashSet 中判断对象是否重复是根据对象的 hashCode 值和 equals 的比较结果</strong>，而不是根据对象的 name 和 age 值是否相等！ </p><p>如果俩个对象的 hashCode 值相等，那么再使用 equals 判断是否俩对象是否相同， 如果俩个对象的 hashCode 值不同等，那么就不再使用 equals 进行判断了，因为 hashCode 不同的俩个对象一定是不同的俩个对象！</p><p>所以，想要将 Student 对象根据我们的要求进行去重，就要重写 Student 中的 hashCode 方法和 equals 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>        <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>        <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Student student = (Student) o;<br>        <span class="hljs-keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);<br>     &#125;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set set = <span class="hljs-keyword">new</span> HashSet();<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>  <br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果：</span><br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br></code></pre></td></tr></table></figure><p><code>java.util.Objects </code>是 JDK1.7 提供的一个对象的工具类，里面定义的一些静态方法，提供了操作对象的方法。</p><p>例如：<code>equals(Object a, Object b)</code> 可以判断俩个对象是否相等，当然也可以直接进行 equals 判断。</p><p>例如：<code>hash(Object... values)</code> 可以根据若干个参数计算出一个哈希值，当然也可以自己设置哈希值。</p><br/><h3 id="5-3-TreeSet"><a href="#5-3-TreeSet" class="headerlink" title="5.3 TreeSet"></a>5.3 TreeSet</h3><p>TreeSet 是 Set 接口的子接口 SortedSet 的实现类。</p><p>TreeSet 可以将我们存进去的数据进行排序，排序的方式有俩种：</p><ul><li>自然排序 </li><li>比较器排序（也称客户化排序）</li></ul><br/><h4 id="5-3-1-自然排序"><a href="#5-3-1-自然排序" class="headerlink" title="5.3.1 自然排序"></a>5.3.1 自然排序</h4><p>如果一个类，实现了 <code>java.lang.Comparable</code> 接口，那么这个类的俩个对象就是可以比较大小的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>compareTo 方法使用说明： <code>int result = o1.compareTo(o2);</code> </p><ul><li>result 的值大于0，说明 o1 比 o2 大。 </li><li>result 的值小于0，说明 o1 比 o2 小。 </li><li>result 的值等于0，说明 o1 与 o2 相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set set = <span class="hljs-keyword">new</span> TreeSet();<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">5</span>);<br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>    System.out.println(obj);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出结果：1 3 5 7</span><br></code></pre></td></tr></table></figure><p>Integer 类是实现了 Comparable 接口的，那么 Integer 类的俩个对象之间就可以调用 compareTo 方法比较大小了，当前对象比较出来大小，那么对象就可以按照从小到大的顺序进行排序。 所以，<strong>数据排序的前提，一定是可以比较出数据的大小</strong>。</p><br/><p>给自定义类型进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set&lt;Student&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>  <br>  <span class="hljs-comment">// 这里的 Student 类和上面一样。</span><br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;mary&quot;</span>,<span class="hljs-number">23</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">21</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lucy&quot;</span>,<span class="hljs-number">22</span>));<br>  <br>    <span class="hljs-keyword">for</span>(Student student : set)&#123;<br>        System.out.println(student);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果报错：</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassCastException: com.briup.demo.Student<br>cannot be cast to java.lang.Comparable<br></code></pre></td></tr></table></figure><p>报错原因，<strong>TreeSet 中会把对象强制为 Comparable 类型</strong>，因为转成 Comparable 类型就可以调用 compareTo 方法进行俩个对象的比较大小了。但是这里的 Student 没有实现该接口，所以报错了。</p><p>Student 类实现 Comparable 接口，并在 compareTo 方法中，编写比较大小的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span></span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>        <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>        <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student other)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age - other.age;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set set = <span class="hljs-keyword">new</span> TreeSet();<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;mary&quot;</span>,<span class="hljs-number">23</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">21</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lucy&quot;</span>,<span class="hljs-number">22</span>));<br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;jack&#x27;</span>, age=<span class="hljs-number">21</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;lucy&#x27;</span>, age=<span class="hljs-number">22</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;mary&#x27;</span>, age=<span class="hljs-number">23</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，现在学生对象在 TreeSet 中，就可以按照我们定义的规则进行从小到大排序了。</p><br/><h4 id="5-3-2-比较器排序"><a href="#5-3-2-比较器排序" class="headerlink" title="5.3.2 比较器排序"></a>5.3.2 比较器排序</h4><p><strong>比较器排序比自然排序优先级更高。</strong></p><p>假设现在 Student 类已经写好了，但是没有实现 Comparable 接口，同时我们又不愿意直接修改 Student 类的代码，那么在这种情况下，Student 对象在 TreeSet 中是否还能排序呢？</p><p><code> java.util.Comparator</code> 接口，是一个比较器接口，它的实现类可以对俩个对象作出大小的比较，即使对象没有实现 Comparable 接口，也可以进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比较器的使用规则： <code>int result = compare(o1, o2); </code></p><ul><li>result 的值大于 0，说明 o1 比 o2 大，o2 放在 o1 前面。</li><li>result 的值小于 0，说明 o1 比 o2 小 ，o1 放在 o2 前面。</li><li>result 的值等于 0，说明 o1 与 o2 相等 ，位置不变。</li><li>o1 是新加入的值，o2 是已经加入的值（顺序和加入顺序一样）</li></ul><p>注意，这里和自然排序的规则是一样的，<strong>只关心正数、负数、零，不关心具体的值是多少。</strong></p><br/><p>在TreeSet类重载的构造器中，有一个构造器可以接收比较器对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;<br><span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;&gt;(comparator));<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>给学生对象排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//使用 Comparator 接口，创建出匿名内部类对象，这个对象就是要用的比较器对象</span><br>Comparator c = <span class="hljs-keyword">new</span> Comparator() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>            Student s1 = (Student) o1;<br>            Student s2 = (Student) o2;<br>            <span class="hljs-keyword">return</span> s1.age &gt; s2.age? <span class="hljs-number">1</span> : (s1.age==s2.age? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>);<br>        &#125;<br>&#125;;<br>  <br>    <span class="hljs-comment">//创建TreeSet对象的时候，把比较器对象传入</span><br>    Set set = <span class="hljs-keyword">new</span> TreeSet(c);<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;mary&quot;</span>,<span class="hljs-number">23</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">21</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lucy&quot;</span>,<span class="hljs-number">22</span>));<br>  <br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;jack&#x27;</span>, age=<span class="hljs-number">21</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;lucy&#x27;</span>, age=<span class="hljs-number">22</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;mary&#x27;</span>, age=<span class="hljs-number">23</span>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="6-Map-接口"><a href="#6-Map-接口" class="headerlink" title="6. Map 接口"></a>6. Map 接口</h2><h3 id="6-1-Map-集合的特点"><a href="#6-1-Map-集合的特点" class="headerlink" title="6.1 Map 集合的特点"></a>6.1 Map 集合的特点</h3><p>Map 类型集合中，每次需要存一对数据，key-value（键值对）。</p><ul><li><p> key 值必须是唯一的，value 值允许重复。</p></li><li><p>键（key）和值（value）一一映射，一个 key 对应一个 value 。</p></li><li><p>在 Map 中，通过 key 值，可以快速的找到对应的 value 值。</p></li><li><p>如果键值相同，后面加入的会覆盖前面的。</p></li></ul><br/><h3 id="6-2-Map-接口中的方法"><a href="#6-2-Map-接口中的方法" class="headerlink" title="6.2 Map 接口中的方法"></a>6.2 Map 接口中的方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>V put(K key, V value)</code></td><td>把 key-value 存到当前 Map 集合中。</td></tr><tr><td><code>void putAll(Map m) </code></td><td>把指定 map 中的所有 key-value，存到当前 Map 集合中。</td></tr><tr><td><code>boolean containsKey(Object key) </code></td><td>当前 Map 集合中是否包含指定的 key 值。</td></tr><tr><td><code>boolean containsValue(Object value)</code></td><td>当前 Map 集合中是否包含指定的 value 值。</td></tr><tr><td><code>V get(Object key)</code></td><td>通过指定的 key 值，获取对应的 value 值。</td></tr><tr><td><code>V remove(Object key) </code></td><td>移除指定 key 及其对应的 value。</td></tr><tr><td><code>Set keySet() </code></td><td>返回 Map 集合中所有的 key 值 。</td></tr><tr><td><code>Collection&lt;V&gt; values()</code></td><td>返回 Map 集合中所有的 value 值。</td></tr><tr><td><code>Set&lt;Map.Entry&lt;k,V&gt;&gt; entrySet()</code></td><td>把 Map 集合中的的 key-value 封装成 Entry 类型对象，再存放到 set 集合中，并返回。</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断当前 Map 集合是否为空。</td></tr><tr><td><code>int size() </code></td><td>返回当前 Map 集合中的元素个数。</td></tr><tr><td><code>void clear() </code></td><td>清空当前 Map 集合中的所有数据。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map map = <span class="hljs-keyword">new</span> HashMap();<br>    map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>    map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;map是否为空：&quot;</span>+map.isEmpty());<br>    System.out.println(<span class="hljs-string">&quot;map中元素的个数：&quot;</span>+map.size());<br>    System.out.println(<span class="hljs-string">&quot;map中是否包含指定key值1：&quot;</span>+map.containsKey(<span class="hljs-number">1</span>));<br>    System.out.println(<span class="hljs-string">&quot;map中是否包含指定value值mary：&quot;</span>+map.containsValue(<span class="hljs-string">&quot;mary&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;map中获取指定key值1对应的value值：&quot;</span>+map.get(<span class="hljs-number">1</span>));<br>    System.out.println(<span class="hljs-string">&quot;map中获取指定key值5对应的value值：&quot;</span>+map.get(<span class="hljs-number">5</span>));<br>  <br><span class="hljs-comment">/* Map集合的这三种遍历方式 */</span><br>    System.out.println(<span class="hljs-string">&quot;--------获取map中所有的kay值--------&quot;</span>);<br>    Set keys = map.keySet();<br>    <span class="hljs-keyword">for</span>(Object key : keys)&#123;<br>        System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>    &#125;<br>  <br>    System.out.println(<span class="hljs-string">&quot;--------获取map中所有的value值--------&quot;</span>);<br>    Collection values = map.values();<br>    <span class="hljs-keyword">for</span>(Object value : values)&#123;<br>      System.out.println(value);<br>    &#125;<br>  <br>System.out.println(<span class="hljs-string">&quot;--------获取map中所有的key-value(键值对),封装成Entry类型对象--------&quot;</span>);<br>    Set entrySet = map.entrySet();<br>    <span class="hljs-keyword">for</span>(Object obj : entrySet)&#123;<br>    Map.Entry entry = (Map.Entry) obj;<br>      System.out.println(entry.getKey()+<span class="hljs-string">&quot; : &quot;</span>+entry.getValue());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="6-3-HashMap"><a href="#6-3-HashMap" class="headerlink" title="6.3 HashMap"></a>6.3 HashMap</h3><p>存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一性，需要重写键的 hashCode() 方法和 equals() 方法。（重要，最常用）</p><br/><h3 id="6-4-HashTable"><a href="#6-4-HashTable" class="headerlink" title="6.4 HashTable"></a>6.4 HashTable</h3><p>和之前 List 集合中的 Vector 的功能类似，可以在多线程环境中，保证集合中的数据的操作安全。类中的方法大多数使用了 synchronized 修饰符进行加锁。（线程安全）</p><br/><h3 id="6-5-TreeMap"><a href="#6-5-TreeMap" class="headerlink" title="6.5 TreeMap"></a>6.5 TreeMap</h3><p>该类是 Map 接口的子接口 SortedMap 下面的实现类，和 TreeSet 类似，它可以对 key 值进行排序，同时构造器也可以接收一个比较器对象作为参数。</p><h4 id="6-51-自然排序"><a href="#6-51-自然排序" class="headerlink" title="6.51 自然排序"></a>6.51 自然排序</h4><p>使用方式和 TreeSet 一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>  map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>  map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>  map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br><br>  Set&lt;Integer&gt; keys = map.keySet();<br><br>  <span class="hljs-keyword">for</span>(Integer key : keys)&#123;<br>    System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="6-52-比较器排序"><a href="#6-52-比较器排序" class="headerlink" title="6.52 比较器排序"></a>6.52 比较器排序</h4><p>使用方式和 TreeSet 一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Comparator&lt;Integer&gt; c = <span class="hljs-keyword">new</span> Comparator() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>      Integer k1 = (Integer) o1;<br>      Integer k2 = (Integer) o2;<br>      <span class="hljs-keyword">return</span> k1.compareTo(k2);<br>    &#125;<br>  &#125;;<br><br>  TreeMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(c);<br>  map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>  map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>  map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>  Set&lt;Integer&gt; keys = map.keySet();<br>  <span class="hljs-keyword">for</span>(Integer key : keys)&#123;<br>    System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="6-6-LinkedHashMap"><a href="#6-6-LinkedHashMap" class="headerlink" title="6.6 LinkedHashMap"></a>6.6 LinkedHashMap</h3><p>该类是 HashMap 的子类，存储数据采用的哈希表结构 + 链表结构。通过链表结构可以保证元素的存取顺序一致。（存入顺序就是取出顺序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Map&lt;Integer,String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>  map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>  map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>  map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br><br>  Set&lt;Integer&gt; keys = map.keySet();<br>  <span class="hljs-keyword">for</span>(Integer key : keys)&#123;<br>    System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-number">4</span> : mary<br><span class="hljs-number">2</span> : jack<br><span class="hljs-number">1</span> : tom<br><span class="hljs-number">3</span> : lucy<br><br></code></pre></td></tr></table></figure><br/><h3 id="6-7-Map-的遍历"><a href="#6-7-Map-的遍历" class="headerlink" title="6.7 Map 的遍历"></a>6.7 Map 的遍历</h3><h4 id="6-7-1-遍历-key-值"><a href="#6-7-1-遍历-key-值" class="headerlink" title="6.7.1 遍历 key 值"></a>6.7.1 遍历 key 值</h4><p>使用 Map 接口中的 <code>keySet()</code> 方法，返回 Map 集合中所有的 key 值的 Set 集合。拿到 Set 集合后，遍历 Set 集合拿到 Map 中每个key值，通过 key 值可以获取到对应的 value 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>    map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  <br>    Set&lt;Integer&gt; keys = map.keySet();<br>    <span class="hljs-keyword">for</span>(Integer key : keys)&#123;<br>        System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h4 id="6-7-2-遍历-Value-值"><a href="#6-7-2-遍历-Value-值" class="headerlink" title="6.7.2 遍历 Value 值"></a>6.7.2 遍历 Value 值</h4><p>使用 Map 接口中的 <code>values()</code> 方法，返回 Map 集合中所有的 value 值的集合。但是通过该方式拿不到 value 值对应的 key 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>    map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  <br>    Collection values = map.values();<br>    <span class="hljs-keyword">for</span>(Object value : values)&#123;<br>      System.out.println(value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h4 id="6-7-3-使用-entrySet-方法"><a href="#6-7-3-使用-entrySet-方法" class="headerlink" title="6.7.3 使用 entrySet 方法"></a>6.7.3 使用 entrySet 方法</h4><p>Map 接口中有定义了一个内部接口 Entry（类似于内部类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;<br>  <span class="hljs-comment">// ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-function">K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个 Entry 类型的对象，可以代表 Map 集合中的一组 key-value（键值对），并且提供了获取 key 值和 value 值的方法。</p><p>Map 接口中的 entrySet() 方法，就是将 Map 集合中的每一组 key-value（键值对）都封装成一个 Entry 类型对象，并且把这些个 Entry 对象存放到Set集合中，并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>    map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br><br>    Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();<br>    <span class="hljs-keyword">for</span>(Map.Entry entry : entrySet)&#123;<br>      System.out.println(entry.getKey()+<span class="hljs-string">&quot; : &quot;</span>+entry.getValue());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h2 id="7-Collections-集合工具类"><a href="#7-Collections-集合工具类" class="headerlink" title="7. Collections 集合工具类"></a>7. Collections 集合工具类</h2><p><code>java.util.Collections</code> 是一个工具类，专门用来操作集合对象的，里面都是静态方法，可以直接调用。</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>fill()</code></td><td>使用指定元素替换指定列表中的所有元素。</td></tr><tr><td><code>max()</code></td><td>根据元素的自然顺序，返回给定集合的最大元素。</td></tr><tr><td><code>min()</code></td><td>根据元素的自然顺序，返回给定集合的最小元素。</td></tr><tr><td><code>revserse()</code></td><td>反转集合中的元素。</td></tr><tr><td><code>sort()</code></td><td>根据元素的自然顺序，对指定列表按升序进行排序。</td></tr><tr><td><code>shuffle()</code></td><td>使用默认随机源对指定列表进行置换。</td></tr><tr><td><code>addAll()</code></td><td>往集合中添加一些元素。</td></tr><tr><td><code>synchronizedCollection</code></td><td>把非线程安全的 Collection 类型集合，转为线程安全的集合。</td></tr><tr><td><code>synchronizedList</code></td><td>把非线程安全的 List 类型集合，转为线程安全的集合。</td></tr><tr><td><code>synchronizedSet</code></td><td>把非线程安全的 Set 类型集合，转为线程安全的集合。</td></tr><tr><td><code>synchronizedMap</code></td><td>把非线程安全的 Map 类型集合，转为线程安全的集合。</td></tr></tbody></table><ul><li><p><code>fill()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Collections.fill(list, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>max() &amp; min()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">9</span>);<br>list.add(<span class="hljs-number">3</span>);<br>System.out.println(Collections.max(list));<br>System.out.println(Collections.min(list));<br></code></pre></td></tr></table></figure></li><li><p><code>reverse()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">9</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Collections.reverse(list);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>sort()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">9</span>);<br>list.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//如果需要，也可以在第二个参数位置传一个比较器对象</span><br><span class="hljs-comment">//Collections.sort(list,c);</span><br>Collections.sort(list);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>shuffle()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">9</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Collections.shuffle(list);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>addAll()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">//注意，addAll的第二个参数，是可变参数</span><br>Collections.addAll(list,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String 类</title>
    <link href="/2021/06/14/CoreJava/13.%20String%20%E7%B1%BB/"/>
    <url>/2021/06/14/CoreJava/13.%20String%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>String 类代表字符串。Java 程序中的所有字符串字面值都作为此类的实例实现。</p><span id="more"></span><h2 id="1-String-特点"><a href="#1-String-特点" class="headerlink" title="1. String 特点"></a>1. String 特点</h2><ul><li><p>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p></li><li><p><strong>String 类的值是 final 类型的</strong>，一旦声明则不可以改变，所以<strong>只要一个值改变就会生成一个新的 String 类型对象</strong>，但是原来的字符串还是存在的，并且产生垃圾。</p></li><li><p>String 底层使用一个字符数组来维护的。</p></li><li><p>存储 String 数据也不一定从数组的第 0 个元素开始的，而是从 offset 所指的元素开始。</p></li></ul><h2 id="2-创建字符串对象两种方式"><a href="#2-创建字符串对象两种方式" class="headerlink" title="2. 创建字符串对象两种方式"></a>2. 创建字符串对象两种方式</h2><h3 id="2-1-直接赋值方式创建对象"><a href="#2-1-直接赋值方式创建对象" class="headerlink" title="2.1 直接赋值方式创建对象"></a>2.1 直接赋值方式创建对象</h3><p>直接赋值方式创建对象是在方法区的常量池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;hello&quot;</span>;   <span class="hljs-comment">//直接赋值的方式</span><br></code></pre></td></tr></table></figure><h3 id="2-2-通过构造方法创建字符串对象"><a href="#2-2-通过构造方法创建字符串对象" class="headerlink" title="2.2 通过构造方法创建字符串对象"></a>2.2 通过构造方法创建字符串对象</h3><p>通过构造方法创建字符串对象是在堆内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//实例化的方式</span><br></code></pre></td></tr></table></figure><h3 id="2-3-两种创建方法的比较"><a href="#2-3-两种创建方法的比较" class="headerlink" title="2.3  两种创建方法的比较"></a>2.3  两种创建方法的比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);<br>        String str3 = str2;  <span class="hljs-comment">//引用传递，str3 直接指向 st2 的堆内存地址</span><br>        String str4 = <span class="hljs-string">&quot;hello&quot;</span>;<br>       <br>         System.out.println(str1==str2);  <span class="hljs-comment">//false</span><br>         System.out.println(str1==str3);  <span class="hljs-comment">//false</span><br>         System.out.println(str3==str2);  <span class="hljs-comment">//true</span><br>         System.out.println(str1==str4);  <span class="hljs-comment">//true</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在字符串中，如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象 “Lance” 放入对象池，<strong>每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象</strong>，这样，所有直接赋值的String对象，如果利用相同的 “Lance” ，则 String对象 == 返回 true；</p><ul><li><p>直接赋值<code>String str = &quot;hello&quot;</code>：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p></li><li><p>构造方法<code>String str =  new String(&quot;hello&quot;);</code>会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过<code>public  String intern();</code>方法进行手工入池。<strong>在开发的过程中不会采用构造方法进行字符串的实例化。</strong></p></li></ul><h2 id="3-和-equals"><a href="#3-和-equals" class="headerlink" title="3. == 和 equals"></a>3. == 和 equals</h2><p>==：</p><ul><li>基本数据类型：比较的是基本数据类型的值是否相同</li><li>引用数据类型：比较的是引用数据类型的地址值是否相同</li></ul><p>equals:</p><ul><li>equals比较的是字符串内容。</li><li>在开发的过程中，equals()通过接受参数，可以避免空指向。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>))&#123;  <span class="hljs-comment">//此时会出现空指向异常</span><br>  ...<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;hello&quot;</span>.equals(str))&#123;  <span class="hljs-comment">//此时equals会处理null值，可以避免空指向异常</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h2><h3 id="4-1-String-的判断功能"><a href="#4-1-String-的判断功能" class="headerlink" title="4.1 String 的判断功能"></a>4.1 String 的判断功能</h3><ul><li><code>boolean equals(Object obj)</code>：比较字符串的内容是否相同。</li><li><code>boolean equalsIgnoreCase(String str)</code>： 比较字符串的内容是否相同，忽略大小写。</li><li><code>boolean startsWith(String str)</code>： 判断字符串对象是否以指定的 str 开头。</li><li><code>boolean endsWith(String str)</code>： 判断字符串对象是否以指定的 str 结尾。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>           <span class="hljs-comment">// 创建字符串对象</span><br>        String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;Hello&quot;</span>;<br> <br>        <span class="hljs-comment">// boolean equals(Object obj):比较字符串的内容是否相同</span><br>        System.out.println(s1.equals(s2));<br>        System.out.println(s1.equals(s3));<br>        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);<br> <br>        <span class="hljs-comment">// boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span><br>        System.out.println(s1.equalsIgnoreCase(s2));<br>        System.out.println(s1.equalsIgnoreCase(s3));<br>        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);<br> <br>        <span class="hljs-comment">// boolean startsWith(String str):判断字符串对象是否以指定的str开头</span><br>        System.out.println(s1.startsWith(<span class="hljs-string">&quot;he&quot;</span>));<br>        System.out.println(s1.startsWith(<span class="hljs-string">&quot;lo&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-String-的获取功能"><a href="#4-2-String-的获取功能" class="headerlink" title="4.2 String 的获取功能"></a>4.2 String 的获取功能</h3><ul><li> <code>int length()</code>：获取字符串的长度，其实也就是字符个数。</li><li> <code>char charAt(int index)</code>：获取指定索引处的字符。</li><li> <code>int indexOf(String str)</code>：获取 str 在字符串对象中第一次出现的索引。</li><li> <code>String substring(int start)</code>：从 start 开始截取字符串。</li><li> <code>String substring(int start,int end)</code>：从 start 开始，到 end 结束截取字符串。包括 start，不包括 end。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>          <span class="hljs-comment">// 创建字符串对象</span><br>        String s = <span class="hljs-string">&quot;helloworld&quot;</span>;<br> <br>        <span class="hljs-comment">// int length():获取字符串的长度，其实也就是字符个数</span><br>        System.out.println(s.length());<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br> <br>        <span class="hljs-comment">// char charAt(int index):获取指定索引处的字符</span><br>        System.out.println(s.charAt(<span class="hljs-number">0</span>));<br>        System.out.println(s.charAt(<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br> <br>        <span class="hljs-comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引</span><br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;l&quot;</span>));<br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;owo&quot;</span>));<br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;ak&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br> <br>        <span class="hljs-comment">// String substring(int start):从start开始截取字符串</span><br>        System.out.println(s.substring(<span class="hljs-number">0</span>));<br>        System.out.println(s.substring(<span class="hljs-number">5</span>));<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br> <br>        <span class="hljs-comment">// String substring(int start,int end):从start开始，到end结束截取字符串</span><br>        System.out.println(s.substring(<span class="hljs-number">0</span>, s.length()));<br>        System.out.println(s.substring(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>));<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-String的转换功能"><a href="#4-3-String的转换功能" class="headerlink" title="4.3 String的转换功能"></a>4.3 String的转换功能</h3><ul><li><code>char[] toCharArray()</code>：把字符串转换为字符数组。</li><li><code>String toLowerCase()</code>：把字符串转换为小写字符串。</li><li><code>String toUpperCase()</code>：把字符串转换为大写字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>         <span class="hljs-comment">// 创建字符串对象</span><br>        String s = <span class="hljs-string">&quot;abcde&quot;</span>;<br> <br>        <span class="hljs-comment">// char[] toCharArray():把字符串转换为字符数组</span><br>        <span class="hljs-keyword">char</span>[] chs = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; chs.length; x++) &#123;<br>            System.out.println(chs[x]);<br>        &#125;<br> <br>        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);<br> <br>        <span class="hljs-comment">// String toLowerCase():把字符串转换为小写字符串</span><br>        System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>.toLowerCase());<br>        <span class="hljs-comment">// String toUpperCase():把字符串转换为大写字符串</span><br>        System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>.toUpperCase());<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-其他常用方法"><a href="#4-4-其他常用方法" class="headerlink" title="4.4 其他常用方法"></a>4.4 其他常用方法</h3><ul><li><code>String trim()</code>：去除字符串两端空格。</li><li><code>String[] split(String str)</code>：按照指定符号分割字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>          <span class="hljs-comment">// 创建字符串对象</span><br>        String s1 = <span class="hljs-string">&quot;helloworld&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot; helloworld &quot;</span>;<br>        String s3 = <span class="hljs-string">&quot; hello world &quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s1 + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s1.trim() + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s2 + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s2.trim() + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s3 + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s3.trim() + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br> <br>        <span class="hljs-comment">// String[] split(String str)</span><br>        <span class="hljs-comment">// 创建字符串对象</span><br>        String s4 = <span class="hljs-string">&quot;aa,bb,cc&quot;</span>;<br>        String[] strArray = s4.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; strArray.length; x++) &#123;<br>            System.out.println(strArray[x]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-String-的不可变性"><a href="#5-String-的不可变性" class="headerlink" title="5. String 的不可变性"></a>5. String 的不可变性</h2><p><strong>String 类的值是 final 类型的</strong>，一旦声明则不可以改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String a = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String b = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String c = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>        System.out.println(a==b);  <span class="hljs-comment">//true</span><br>        System.out.println(a.equals(b));  <span class="hljs-comment">//true</span><br>        System.out.println(a==c);  <span class="hljs-comment">//false</span><br>        System.out.println(a.equals(c));  <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-1-内存分析"><a href="#5-1-内存分析" class="headerlink" title="5.1 内存分析"></a>5.1 内存分析</h3><p><img src="https://i.loli.net/2021/06/14/3nJWdZQxhqO6cMi.png" alt="String.png"></p><p>因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式，每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法<strong>仅仅适合于通过 = 符号进行的初始化</strong>。　　</p><h3 id="5-2-String不可变的好处"><a href="#5-2-String不可变的好处" class="headerlink" title="5.2 String不可变的好处"></a>5.2 String不可变的好处</h3><ul><li>可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。</li><li>我们的程序中大量使用了 String 字符串，有可能是出于安全性考虑。</li><li>当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。</li></ul><h2 id="6-字符串常量池"><a href="#6-字符串常量池" class="headerlink" title="6. 字符串常量池"></a>6. 字符串常量池</h2><h3 id="6-1-字符串常量池概述"><a href="#6-1-字符串常量池概述" class="headerlink" title="6.1 字符串常量池概述"></a>6.1 字符串常量池概述</h3><ul><li><p>常量池表（Constant_Pool table）</p><p>​    Class文件中存储所有常量（包括字符串）的table。</p><p>​    这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。</p></li><li><p>运行时常量池（Runtime Constant Pool）　</p><p>​    JVM内存中方法区的一部分，这是运行时的内容。这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class    对应一个运行时常量池。上一句中说绝大部分是因为：除了 Class中常量池内容，还可能包括动态生成并加入这里的内容。</p></li><li><p>字符串常量池（String Pool）</p></li></ul><p>​            这部分也在方法区中，但与运行时常量池不是一个概念，字符串常量池是 JVM 实例全局共享的，全局只有一个。</p><p>​            JVM 规范要求进入这里的String实例叫“被驻留的 interned string ”，各个JVM可以有不同的实现，HotSpot 是设置了一个哈希表            StringTable 来引用堆中的字符串实例，被引用就是被驻留。</p><h3 id="6-2-亨元模式"><a href="#6-2-亨元模式" class="headerlink" title="6.2 亨元模式"></a>6.2 亨元模式</h3><p>其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 ——共享元素模式。</p><p>一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”</p><h3 id="6-3-详细分析"><a href="#6-3-详细分析" class="headerlink" title="6.3 详细分析"></a>6.3 详细分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;abc&quot;</span>;  <span class="hljs-comment">// 在常量池中</span><br><br>String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// 在堆上</span><br></code></pre></td></tr></table></figure><ul><li><p>当直接赋值时，字符串 “abc” 会被存储在常量池中，只有1份，此时的赋值操作等于是创建 0 个或 1 个对象。如果常量池中已经存在了 “abc”，那么不会再创建对象，直接将引用赋值给 str1；如果常量池中没有 “abc”，那么创建一个对象，并将引用赋值给 str1。</p></li><li><p>通过<code>new String(“abc”);</code>的形式又是如何呢？答案是 1 个或 2 个。当 JVM 遇到上述代码时，会先检索常量池中是否存在 “abc”，如果不存在 “abc” 这个字符串，则会先在常量池中创建这个一个字符串。然后再执行 new 操作，会在堆内存中创建一个存储 “abc” 的 String 对象，对象的引用赋值给 str2。此过程创建了2个对象。当然，如果检索常量池时发现已经存在了对应的字符串，那么只会在堆内创建一个新的String对象，此过程只创建了1个对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>答案是2个？还真不一定。之所以单独列出这个问题是想提醒大家一点：没有直接的赋值操作（str=“abc”），并不代表常量池中没有“abc”这个字符串。也就是说衡量创建几个对象、常量池中是否有对应的字符串，不仅仅由你是否创建决定，还要看程序启动时其他类中是否包含该字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span>;<br></code></pre></td></tr></table></figure><p>上面的问题涉及到字符串常量重载“+”的问题，当一个字符串由多个字符串常量拼接成一个字符串时，它自己也肯定是字符串常量。字符串常量的“+”号连接Java虚拟机会在程序编译期将其优化为连接后的值。</p><p>就上面的示例而言，在编译时已经被合并成“abcdef”字符串，因此，<strong>只会创建1个对象</strong>。并没有创建临时字符串对象abc和def，这样减轻了垃圾收集器的压力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;def&quot;</span>);<br></code></pre></td></tr></table></figure><p>创建了4个，5个，还是6个对象？</p><p>4个对象的说法：常量池中分别有 “abc” 和 “def”，堆中对象 new String(“def”) 和 “abcdef”。</p><p>这种说法对吗？不完全对，如果说上述代码创建了几个字符串对象，那么可以说是正确的。但上述的代码 Java 虚拟机在编译的时候同样会优化，会创建一个 StringBuilder 来进行字符串的拼接，实际效果类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;def&quot;</span>);<br><span class="hljs-keyword">new</span> StringBuilder().append(<span class="hljs-string">&quot;abc&quot;</span>).append(s).toString();<br></code></pre></td></tr></table></figure><p>很显然，多出了一个 StringBuilder 对象，上面的准确回答应该是创建了4个字符串对象和1个 StringBuilder 对象。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String 类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Math 类</title>
    <link href="/2021/06/14/CoreJava/11.%20Math%20%E7%B1%BB/"/>
    <url>/2021/06/14/CoreJava/11.%20Math%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><span id="more"></span><h3 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h3><p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p><h3 id="1-abs"><a href="#1-abs" class="headerlink" title="1. abs()"></a>1. abs()</h3><p>返回参数的绝对值。参数可以是 int, float, long, double, short, byte类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = -<span class="hljs-number">80</span>;<br><span class="hljs-keyword">float</span> b = -<span class="hljs-number">90.0f</span>;<br><span class="hljs-keyword">double</span> c = -<span class="hljs-number">100</span>;<br><br>System.out.println(Math.abs(a));  <span class="hljs-comment">// 结果为 80</span><br>System.out.println(Math.abs(b));  <span class="hljs-comment">// 结果为 90.0</span><br>System.out.println(Math.abs(c));  <span class="hljs-comment">// 结果为 100.0</span><br></code></pre></td></tr></table></figure><h3 id="2-ceil"><a href="#2-ceil" class="headerlink" title="2. ceil()"></a>2. ceil()</h3><p>返回大于等于( &gt;= )给定参数的的最小整数，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.ceil(d));  <span class="hljs-comment">// 结果为 4.0</span><br>System.out.println(Math.ceil(f));  <span class="hljs-comment">// 结果为 -2.0</span><br></code></pre></td></tr></table></figure><h3 id="3-floor"><a href="#3-floor" class="headerlink" title="3. floor()"></a>3. floor()</h3><p>返回大于等于( &lt;= )给定参数的的最小整数，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.floor(d));  <span class="hljs-comment">// 结果为 3.0</span><br>System.out.println(Math.floor(f));  <span class="hljs-comment">// 结果为 -3.0</span><br></code></pre></td></tr></table></figure><h3 id="4-rint"><a href="#4-rint" class="headerlink" title="4. rint()"></a>4. rint()</h3><p>返回最接近参数的整数值，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.rint(d));  <span class="hljs-comment">// 结果为 3.0</span><br>System.out.println(Math.rint(f));  <span class="hljs-comment">// 结果为 -2.0</span><br></code></pre></td></tr></table></figure><h3 id="5-round"><a href="#5-round" class="headerlink" title="5. round()"></a>5. round()</h3><p>返回一个最接近的 int、long 型值，四舍五入。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> a = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">double</span> b = <span class="hljs-number">3.5</span>;<br><span class="hljs-keyword">float</span> c = <span class="hljs-number">4.1f</span>;<br><span class="hljs-keyword">float</span> d = <span class="hljs-number">4.6f</span>;<br><br>System.out.println(Math.round(a)); <span class="hljs-comment">// 结果为 3</span><br>System.out.println(Math.round(b)); <span class="hljs-comment">// 结果为 4</span><br>System.out.println(Math.round(c)); <span class="hljs-comment">// 结果为 4</span><br>System.out.println(Math.round(d)); <span class="hljs-comment">// 结果为 5</span><br></code></pre></td></tr></table></figure><h3 id="6-max-amp-min"><a href="#6-max-amp-min" class="headerlink" title="6. max() &amp; min()"></a>6. max() &amp; min()</h3><ul><li><p>max() 方法用于返回两个参数中的最大值。</p></li><li><p>min() 方法用于返回两个参数中的最小值。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Math.max(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>));  <span class="hljs-comment">// 结果为 13   </span><br>System.out.println(Math.min(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>));  <span class="hljs-comment">// 结果为 24</span><br></code></pre></td></tr></table></figure><h3 id="7-次方运算"><a href="#7-次方运算" class="headerlink" title="7. 次方运算"></a>7. 次方运算</h3><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">exp()</td><td align="center">返回自然数底数e的参数次方。</td></tr><tr><td align="center">log()</td><td align="center">返回参数的自然数底数的对数值。</td></tr><tr><td align="center">sqrt()</td><td align="center">返回参数的算术平方根。</td></tr><tr><td align="center">pow()</td><td align="center">返回第一个参数的第二个参数次方。</td></tr></tbody></table><h3 id="8-三角函数"><a href="#8-三角函数" class="headerlink" title="8. 三角函数"></a>8. 三角函数</h3><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">sin()</td><td align="center">返回指定 double 类型参数的正弦值。</td></tr><tr><td align="center">cos()</td><td align="center">返回指定 double 类型参数的余弦值。</td></tr><tr><td align="center">tan()</td><td align="center">返回指定 double 类型参数的正切值。</td></tr><tr><td align="center">asin()</td><td align="center">返回指定 double 类型参数的反正弦值。</td></tr><tr><td align="center">acos()</td><td align="center">返回指定 double 类型参数的反余弦值。</td></tr><tr><td align="center">atan()</td><td align="center">返回指定 double 类型参数的反正切值。</td></tr><tr><td align="center">atan2()</td><td align="center">用于将矩形坐标 (x, y) 转换成极坐标 (r, theta)，返回所得角 theta。</td></tr><tr><td align="center">toDegrees()</td><td align="center">将参数转化为角度。</td></tr><tr><td align="center">toRadians()</td><td align="center">将角度转换为弧度。</td></tr><tr><td align="center">random()</td><td align="center">返回一个随机数，随机数范围为 0.0 =&lt; Math.random &lt; 1.0。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math 类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内部类</title>
    <link href="/2021/06/14/CoreJava/9.%20%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2021/06/14/CoreJava/9.%20%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>内部类，不是在一个 java 源文件中编写俩个平行的类，而是在一个类的内部再定义另外的一个类。</p><span id="more"></span><h2 id="1-内部类的分类"><a href="#1-内部类的分类" class="headerlink" title="1. 内部类的分类"></a>1. 内部类的分类</h2><ul><li>成员内部类 </li><li>静态内部类 </li><li>局部内部类</li><li>匿名内部类</li></ul><br/><h2 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2. 成员内部类"></a>2. 成员内部类</h2><p>在类中，可以定义成员方法、成员变量，除此之外，还可以定义成员内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberOuterClass</span></span>&#123;<br>  <span class="hljs-comment">//外部类的属性</span><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">//外部类的方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">/* 成员内部类 声明开始 */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberInnerClass</span></span>&#123;<br>      <span class="hljs-keyword">private</span> String name;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>  &#125;<br>  <span class="hljs-comment">/* 成员内部类 声明结束 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>成员内部类中，不能编写静态的属性和方法。</p><p>当前这个代码，编译成功后，会生成俩个class文件，一个对应外部类，一个对应内部类。 编译生成的俩个class文件的名字分别为： <code>MemberOuterClass.class</code> 和 <code>MemberOuterClass$MemberInnerClass.class</code></p><br/><h3 id="2-1-成员内部类访问外部类"><a href="#2-1-成员内部类访问外部类" class="headerlink" title="2.1 成员内部类访问外部类"></a>2.1 成员内部类访问外部类</h3><ul><li>访问内部类自己的属性：<code>this.属性名</code></li><li>访问外部类的非静态属性/方法：<code>类名.this.属性名/方法名</code></li><li>访问外部类的静态属性/方法：<code>类名.属性名/方法名</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberOuterClass</span> </span>&#123;<br>    <span class="hljs-comment">//外部类的属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-comment">//外部类的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>    <span class="hljs-comment">/* 成员内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberInnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>      <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;<br>          <span class="hljs-comment">//访问当前run方法中的参数name</span><br>            System.out.println(name);<br>          <br>            <span class="hljs-comment">//访问内部类自己的属性name</span><br>            System.out.println(<span class="hljs-keyword">this</span>.name);<br>          <br>            <span class="hljs-comment">//访问外部类的非静态属性</span><br>            System.out.println(MemberOuterClass.<span class="hljs-keyword">this</span>.name);<br>          <br>            <span class="hljs-comment">//访问外部类的静态属性</span><br>            System.out.println(MemberOuterClass.age);<br>          <br>            <span class="hljs-comment">//访问外部类的非静态方法</span><br>            MemberOuterClass.<span class="hljs-keyword">this</span>.run();<br>          <br>            <span class="hljs-comment">//访问外部类的静态方法</span><br>            MemberOuterClass.go();<br>        &#125;<br>&#125;<br><span class="hljs-comment">/* 成员内部类 声明结束 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="2-2-外部类访问成员内部类"><a href="#2-2-外部类访问成员内部类" class="headerlink" title="2.2 外部类访问成员内部类"></a>2.2 外部类访问成员内部类</h3><p>外部类访问成员内部类需要先创建内部类的对象，再通过<code>内部类.属性名/方法名</code>进行访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberOuterClass</span> </span>&#123;<br>  <br><span class="hljs-comment">//外部类的方法，访问成员内部类的属性和方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//需要创建内部类对象，然后才可以访问</span><br>      MemberInnerClass t = <span class="hljs-keyword">new</span> MemberInnerClass();<br>      System.out.println(t.name);<br>      System.out.println(t.age);<br>      t.run(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">/* 成员内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberInnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-comment">/* 成员内部类 声明结束 */</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-3-在其他类中使用成员内部类"><a href="#2-3-在其他类中使用成员内部类" class="headerlink" title="2.3 在其他类中使用成员内部类"></a>2.3 在其他类中使用成员内部类</h3><p> 如果这个成员内部类不是 private 修饰的，那么在其他类中就可以访问到这个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.maxseal.demo;<br><span class="hljs-keyword">import</span> com.maxseal.demo.MemberOuterClass.MemberInnerClass;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MemberOuterClass moc = <span class="hljs-keyword">new</span> MemberOuterClass();<br>        MemberInnerClass mic = moc.<span class="hljs-function">new <span class="hljs-title">MemberInnerClass</span><span class="hljs-params">()</span></span>;<br>        mic.run(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这个内部类需要 import 导入，并且是 <code>外部类.内部类</code> 的形式导入。</p></li><li><p>在创建对象的时候，需要先创建出外部类对象，然后使用外部类对象再创建内部类对象。形式为： <code>外部类对象.new 内部类对象()</code>;</p></li></ul><br/><h3 id="2-4-思考题"><a href="#2-4-思考题" class="headerlink" title="2.4 思考题"></a>2.4 思考题</h3><ol><li><p>类的内部除了嵌套另一个类之外，是否还可以嵌套接口？</p><p>可以，不仅类中可以嵌套接口，接口的内部也可以嵌套其他接口。</p><br/></li><li><p>思考，什么情况下会使用内部类？</p><p>在对事物进行抽象的时候，若一个事物内部还包含其他事物，就可以考虑使用内部类这种结构。</p><p>例如，汽车（Car）中包含发动机（Engine） ，这时， Engine 类就可以考虑（非必须）使用内部类来描述，定义在 Car 类中的成员位置。这样设计，既可以表示 Car 和 Engine 的紧密联系的程度，也可以在 Engine 类中很方便的使用到 Car 里面的属性和方法。</p></li></ol><br/><h2 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h2><p>静态内部类和成员内部类是类似的，只是这个内部类，多了 static 关键字进行修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticOuterClass</span></span>&#123;<br>    <span class="hljs-comment">/* 静态内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span></span>&#123;<br>    &#125;<br>    <span class="hljs-comment">/* 静态内部类 声明结束 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>静态内部类中，可以编写静态的属性和方法，另外在四种内部类中，只有静态内部类可以编写静态属性和方法。</p></li><li><p>编译生成的俩个class文件的名字分别为：``StaticOuterClass.class<code>和</code>StaticOuterClass$StaticInnerClass.class`</p><br/></li></ul><h3 id="3-1-静态内部类访问外部类"><a href="#3-1-静态内部类访问外部类" class="headerlink" title="3.1 静态内部类访问外部类"></a>3.1 静态内部类访问外部类</h3><p>在静态内部类中访问不了外部类中的非静态属性和方法。</p><ul><li>访问自己的静态属性：<code>属性名</code></li><li>访问自己的非静态属性：<code>this.属性名</code></li><li>访问外部类的静态属性：<code>类名.属性</code></li><li>访问外部类的静态方法：<code>类名.方法名</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticOuterClass</span> </span>&#123;<br>    <span class="hljs-comment">//外部类的属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-comment">//外部类的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-comment">/* 静态内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;<br>            <span class="hljs-comment">//访问当前run方法中的参数name</span><br>            System.out.println(name);<br><br>            <span class="hljs-comment">//访问内部类自己的属性name</span><br>            System.out.println(<span class="hljs-keyword">this</span>.name);<br><br>            <span class="hljs-comment">//访问内部类自己的静态属性age</span><br>            System.out.println(age);<br><br>            <span class="hljs-comment">//静态内部类中，无法访问外部类的非静态属性和方法</span><br>            <span class="hljs-comment">//访问外部类的静态属性和方法</span><br>            System.out.println(StaticOuterClass.age);<br>            StaticOuterClass.go();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 静态内部类 声明结束 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-外部类访问静态内部类"><a href="#3-2-外部类访问静态内部类" class="headerlink" title="3.2 外部类访问静态内部类"></a>3.2 外部类访问静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticOuterClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//外部类中，访问静态类中的静态属性</span><br>      System.out.println(StaticInnerClass.age);<br>      <br>      <span class="hljs-comment">//外部类中，访问静态内部类中的非静态属性和方法</span><br>      StaticInnerClass sic = <span class="hljs-keyword">new</span> StaticInnerClass();<br>      System.out.println(sic.name);<br>      sic.run(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">/* 静态内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>    &#125;<br><span class="hljs-comment">/* 静态内部类 声明结束 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-在其他类中使用静态内部类"><a href="#3-3-在其他类中使用静态内部类" class="headerlink" title="3.3 在其他类中使用静态内部类"></a>3.3 在其他类中使用静态内部类</h3><p>如果这个静态内部类不是 private 修饰的，那么在其他类中就可以访问到这个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.briup.sync.StaticOuterClass.StaticInnerClass;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      StaticInnerClass sic = <span class="hljs-keyword">new</span> StaticInnerClass();<br>      sic.run(<span class="hljs-string">&quot;tom&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个内部类需要 import 导入，并且是 <code>外部类.内部类</code>的形式导入。 </li><li>在创建对象的时候，直接使用这个静态内部类的名字即可：<code> new 静态内部类对象();</code> ，不再 需要依赖外部类对象了。</li></ul><br/><h2 id="4-局部内部类"><a href="#4-局部内部类" class="headerlink" title="4. 局部内部类"></a>4. 局部内部类</h2><p>局部内部类，是另一种形式的内部。在声明在外部类的方法中，相当于方法中的局部变量的位置，它的作用范围只是在当前方法中。 </p><p>局部内部类是最不常用的一种内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalOuterClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-comment">/* 局部内部类 声明开始 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span></span>&#123;&#125;<br>        <span class="hljs-comment">/* 局部内部类 声明结束 */</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="4-1-局部内部类访问外部类"><a href="#4-1-局部内部类访问外部类" class="headerlink" title="4.1 局部内部类访问外部类"></a>4.1 局部内部类访问外部类</h3><ul><li>访问自己的非静态属性：<code>this.属性名</code></li><li>访问外部类的非静态属性/方法：<code>类名.this.属性名/方法名</code></li><li>访问外部类的静态属性/方法：<code>类名.属性名/方法名</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalOuterClass</span> </span>&#123;<br>    <span class="hljs-comment">//外部类的属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-comment">//外部类的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-comment">/* 局部内部类 声明开始 */</span><br>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span></span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span></span>&#123;<br>              <span class="hljs-comment">//访问当前test方法中的参数name</span><br>              System.out.println(name);<br>            <br>              <span class="hljs-comment">//访问内部类自己的属性name</span><br>              System.out.println(<span class="hljs-keyword">this</span>.name);<br>            <br>              <span class="hljs-comment">/*注意，sayHello方法的参数name，无法访问，因为实在没有办法表示了，换成其他</span><br><span class="hljs-comment">              名字后，就可以访问了，不要叫name就行*/</span><br>            <br>              <span class="hljs-comment">//访问外部类的非静态属性</span><br>              System.out.println(LocalOuterClass.<span class="hljs-keyword">this</span>.name);<br>            <br>              <span class="hljs-comment">//访问外部类的非静态方法</span><br>              LocalOuterClass.<span class="hljs-keyword">this</span>.run();<br>            <br>              <span class="hljs-comment">//访问外部类的静态属性和方法</span><br>              System.out.println(LocalOuterClass.age);<br>              LocalOuterClass.go();<br>&#125;<br>&#125;<br><span class="hljs-comment">/* 局部内部类 声明结束 */</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><p>局部内部类中，访问当前方法中的变量，这个变量必须是 final 修饰的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span></span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-comment">/* 局部内部类 声明开始 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span></span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>          System.out.println(name);<br>          System.out.println(num);<br>      &#125;<br>   &#125;<br>  <span class="hljs-comment">/* 局部内部类 声明结束 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="4-2-外部类访问局部内部类"><a href="#4-2-外部类访问局部内部类" class="headerlink" title="4.2 外部类访问局部内部类"></a>4.2 外部类访问局部内部类</h3><p>局部内部类，只能在当前声明的方法中进行使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-comment">/* 局部内部类 声明开始 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span></span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      &#125;<br>&#125;<br><span class="hljs-comment">/* 局部内部类 声明结束 */</span><br>  <br>    <span class="hljs-comment">//创建局部内部类对象</span><br>    LocalInnerClass lic = <span class="hljs-keyword">new</span> LocalInnerClass();<br>  <br>    <span class="hljs-comment">//对象访问属性</span><br>    System.out.println(lic.num);<br>  <br>    <span class="hljs-comment">//对象调用方法</span><br>    lic.test();<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="5-匿名内部类"><a href="#5-匿名内部类" class="headerlink" title="5. 匿名内部类"></a>5. 匿名内部类</h2><p>匿名内部类，是一种没有名字的内部类，它是内部类的一种简化写法。在之后的代码中，匿名内部类是使用最多的一种内部类。 </p><p>在普通的代码中，使用一个接口的步骤如下： </p><ul><li>声明一个类，去实现这个接口 </li><li>实现这个接口中的抽象方法（重写） </li><li>在其他代码中，创建这个类的对象 </li><li>调用类中实现（重写）后的方法 </li></ul><p>其实，在这个过程中，我们的目的就是把接口中的抽象方法给实现（重写）了，最后再调用到这个实现后（重写）的方法。 那么，使用匿名内部类，就可以把这个过程给给简化了，让我们更加方便的调用到实现（重写）后的方法！</p><br/><h3 id="5-1-匿名类的格式"><a href="#5-1-匿名类的格式" class="headerlink" title="5.1 匿名类的格式"></a>5.1 匿名类的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">父类或者接口类型 变量名 = <span class="hljs-keyword">new</span> 父类或者接口()&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//调用实现（重写）后的方法</span><br>变量名.method();<br></code></pre></td></tr></table></figure><br/><h3 id="5-2-匿名类的两种形式"><a href="#5-2-匿名类的两种形式" class="headerlink" title="5.2 匿名类的两种形式"></a>5.2 匿名类的两种形式</h3><ul><li>利用一个父类，进行声明并创建匿名内部类对象，这个匿名内部类默认就是这个父类的子类型。</li><li>利用一个接口，进行声明并创建匿名内部类对象，这个匿名内部类默认就是这个接口的实现类。</li></ul><p>注意事项：</p><ul><li>匿名内部类必须依托于一个父类型或者一个接口。</li><li>匿名内部类在声明的同时，就必须创建出对象，否则后面就没法创建了。</li><li>匿名内部类中无法定义构造器。</li></ul><br/><h3 id="5-3-利用父类型来声明并创建匿名内部类对象"><a href="#5-3-利用父类型来声明并创建匿名内部类对象" class="headerlink" title="5.3 利用父类型来声明并创建匿名内部类对象"></a>5.3 利用父类型来声明并创建匿名内部类对象</h3><p>如果利用父类型声明这个匿名内部类，那么这个匿名内部类默认就是这个父类型的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal animal = <span class="hljs-keyword">new</span> Animal()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类中的默认实现&quot;</span>);<br>            &#125;<br>  &#125;;<br>animal.run();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="5-4-利用接口来声明并创建匿名内部类对象"><a href="#5-4-利用接口来声明并创建匿名内部类对象" class="headerlink" title="5.4 利用接口来声明并创建匿名内部类对象"></a>5.4 利用接口来声明并创建匿名内部类对象</h3><p>如果利用接口声明这个匿名内部类，那么这个匿名内部类默认就是这个接口的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a = <span class="hljs-keyword">new</span> Action()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名内部类中的默认实现&quot;</span>);<br>        &#125;<br>&#125;;<br>a.run();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="6-内部类的选择"><a href="#6-内部类的选择" class="headerlink" title="6. 内部类的选择"></a>6. 内部类的选择</h2><p>假设现在已经确定了要使用内部类，那么一般情况下，该如何选择？ </p><ol><li><p>考虑这个内部类，如果需要反复的进行多次使用（必须有名字） 在这个内部类中，</p><ul><li><p>如果需要定义静态的属性和方法，选择使用静态内部类。</p></li><li><p>如果需要访问外部类的非静态属性和方法，选择使用成员内部类 。</p></li></ul></li><li><p>考虑这个内部类，如果只需要使用一次（可以没有名字） 选择使用匿名内部类 。</p></li><li><p>局部内部类几乎不会使用。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内部类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>final 关键字</title>
    <link href="/2021/06/14/CoreJava/7.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/06/14/CoreJava/7.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>final 修饰符可以修饰类、方法和变量。</p><span id="more"></span><h2 id="1-final-变量"><a href="#1-final-变量" class="headerlink" title="1. final 变量"></a>1. final 变量</h2><ul><li><p>final 表示“最后的、最终的含义”，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p></li><li><p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p></li><li><p>final 修饰的变量不会被默认初始化。</p></li></ul><br/><h3 id="1-1-final-修饰局部变量："><a href="#1-1-final-修饰局部变量：" class="headerlink" title="1.1 final 修饰局部变量："></a>1.1 final 修饰局部变量：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-comment">//编译报错,不能再次赋值,传参的时候已经赋过了</span><br>  a = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br>  a = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//编译报错,不能再次赋值</span><br>  a = <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><br/><h3 id="1-2-final-修饰非静态成员变量"><a href="#1-2-final-修饰非静态成员变量" class="headerlink" title="1.2 final 修饰非静态成员变量"></a>1.2 final 修饰非静态成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明的同时赋值 </li><li>匿名代码块中赋值 </li><li>构造器中赋值，此时还有额外要求：类中出现的所有构造器都要赋值，否则报错。</li></ul><br/><h3 id="1-3-final-修饰静态成员变量"><a href="#1-3-final-修饰静态成员变量" class="headerlink" title="1.3 final 修饰静态成员变量"></a>1.3 final 修饰静态成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明的同时赋值 </li><li>静态代码块中赋值</li></ul><br/><h3 id="1-4-final-修饰引用类型的变量："><a href="#1-4-final-修饰引用类型的变量：" class="headerlink" title="1.4 final 修饰引用类型的变量："></a>1.4 final 修饰引用类型的变量：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Student s = <span class="hljs-keyword">new</span> Student();<br><span class="hljs-comment">//编译通过,可以修改s指向对象中的属性值</span><br>s.setName(<span class="hljs-string">&quot;tom&quot;</span>);<br>s.setName(<span class="hljs-string">&quot;zs&quot;</span>);<br><span class="hljs-comment">//编译报错,不能修改引用s指向的内存地址</span><br>s = <span class="hljs-keyword">new</span> Student();<br></code></pre></td></tr></table></figure><p>此时final指的是，引用s的指向的对象不能改变，但是可以使用s来操作当前指向的对象属性和方法。</p><br/><h2 id="2-final-方法"><a href="#2-final-方法" class="headerlink" title="2. final 方法"></a>2. final 方法</h2><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-comment">//编译报错</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-final-类"><a href="#3-final-类" class="headerlink" title="3. final 类"></a>3. final 类</h2><p>用 final 修饰的类不能被继承，也就是说这个类是没有子类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span></span>&#123;<br>&#125;<br><span class="hljs-comment">//编译报错</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Go</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Action</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修饰符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>abstract 关键字</title>
    <link href="/2021/06/14/CoreJava/8.%20abstract%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/06/14/CoreJava/8.%20abstract%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>abstract 方法和类的使用方式和注意事项。</p><span id="more"></span><h2 id="1-abstract-方法"><a href="#1-abstract-方法" class="headerlink" title="1. abstract 方法"></a>1. abstract 方法</h2><ul><li><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p></li><li><p>抽象方法不能被声明成 final 和 static。</p></li><li><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p></li><li><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p></li><li><p>抽象方法的声明以分号结尾。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法的声明：public void test()</span><br><span class="hljs-comment">//方法的实现：&#123;&#125;</span><br><br><span class="hljs-comment">//这就是一个普通方法，既有方法的声明，又有方法的实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br><span class="hljs-comment">//这就是一个只有声明没有实现的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//这样的方法需要使用abstract修饰符来修饰，说明它是一个抽象方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><br/><h2 id="2-abstract-类"><a href="#2-abstract-类" class="headerlink" title="2. abstract 类"></a>2. abstract 类</h2><ul><li><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p></li><li><p>一个类不能同时被 abstract 和 final 修饰。</p></li><li><p>如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p></li><li><p>抽象类可以包含抽象方法和非抽象方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><span class="hljs-comment">//子类重写父类中的run方法，这时候就变得非常明确了，就是一只猫走路的方式</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;我是一只猫，我踮起脚尖，优雅的走着猫步&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>  <span class="hljs-comment">//子类重写父类中的run方法，这时候就变得非常明确了，就是一只狗走路的方式</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;我是一只狗，我迈开抓子，悠悠晃晃的走着&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//编译报错，抽象类不能实例化创建对象</span><br>  <span class="hljs-comment">//Animal animal = new Animal();</span><br>  <br>  <span class="hljs-comment">//声明父类的引用，准备使用多态</span><br>  Animal animal;<br>  <br>  <span class="hljs-comment">//指向子类对象</span><br>  animal = <span class="hljs-keyword">new</span> Cat();<br>  <br>  <span class="hljs-comment">//调用方法，子类重写，调用到重写后的方法</span><br>  animal.run();<br>  <br>  <span class="hljs-comment">//指向子类对象</span><br>  animal = <span class="hljs-keyword">new</span> Dog();<br>  <br>  <span class="hljs-comment">//调用方法，子类重写，调用到重写后的方法</span><br>  animal.run();<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h2><ul><li><p>接口的内部主要就是封装了抽象方法和静态常量。</p></li><li><p>接口的定义和类很类似，但是接口需要使用 interface 关键字来定义。</p></li><li><p>接口最终也会被编译成.class文件。</p></li><li><p>接口里面的属性，默认就是 public static final 修饰的。</p></li><li><p>接口里面的方法，默认就是 public abstract 修饰的。</p></li><li><p>JDK8中，还允许在接口中编写静态方法和默认方法。</p></li><li><p>JDK9中，还允许在接口中编写私有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用interface关键字来定义接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br>  <span class="hljs-comment">//接口中的静态常量</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String OPS_MODE = <span class="hljs-string">&quot;auto&quot;</span>;<br>  <br>  <span class="hljs-comment">//接口中的抽象方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>  <br>  <span class="hljs-comment">//接口的抽象方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><br/><h3 id="2-1-接口实现"><a href="#2-1-接口实现" class="headerlink" title="2.1 接口实现"></a>2.1 接口实现</h3><ul><li>类和类之间的关系是继承，类和接口之间的关系是实现。</li><li>一个类只能继承一个类，但是能实现了一个或多个接口。</li><li>一个类实现了接口，那么就要实现接口中所有的抽象方法，否则这个类自己就必须声明为抽象类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//类实现接口，并且实现了接口中所有的抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mark</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">star</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//类实现接口，并且实现了接口中所有的抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span>, <span class="hljs-title">Mark</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">star</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="2-2-接口继承"><a href="#2-2-接口继承" class="headerlink" title="2.2 接口继承"></a>2.2 接口继承</h3><p>类和类之间是单继承，接口和接口之间是多继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现该接口的类，将具有run的功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实现该接口的类，将具有fly的功能</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实现该接口的类，将具有run的功能，fly的功能，以及Action接口独有的doSomething功能</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Runable</span>,<span class="hljs-title">Flyable</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实现类，实现Action接口，就必须要实现Action及其父接口中的所有抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="2-3-接口的引用指向它的实现类对象"><a href="#2-3-接口的引用指向它的实现类对象" class="headerlink" title="2.3 接口的引用指向它的实现类对象"></a>2.3 接口的引用指向它的实现类对象</h3><p>多态的前提是继承，必须要先有子父类关系才行，而类和接口之间的实现关系，其实也是继承的一 种形式，所以在类和接口的实现关系中，也可以使用多态。</p><p>接口的引用指向它的实现类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentTest</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//声明接口的引用</span><br>      Action a;<br>      <span class="hljs-comment">//可以指向它任意一个实现类对象</span><br>      a = <span class="hljs-keyword">new</span> Student();<br>      a = <span class="hljs-keyword">new</span> Teacher();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修饰符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static 关键字</title>
    <link href="/2021/06/14/CoreJava/6.%20static%20%E5%85%B3%E9%94%AE%E5%AD%97%20/"/>
    <url>/2021/06/14/CoreJava/6.%20static%20%E5%85%B3%E9%94%AE%E5%AD%97%20/</url>
    
    <content type="html"><![CDATA[<p>static修饰符可以修饰属性、方法、代码块。</p><span id="more"></span><h2 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a>1. 静态变量</h2><p>静态变量是属于类的，可以直接使用类名来访问，也可以使用对象访问，但推荐使用类名访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Demo.num = <span class="hljs-number">10</span>; <span class="hljs-comment">// 可以使用类名来访问</span><br>    Demo demo = <span class="hljs-keyword">new</span> Demo();<br>    demo.num = <span class="hljs-number">20</span>; <span class="hljs-comment">// 也可以对象来访问，但不推荐</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量、静态属性。局部变量不能被声明为静态变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Demo.num = <span class="hljs-number">10</span>;<br>    Demo demo1 = <span class="hljs-keyword">new</span> Demo();<br>    Demo demo2 = <span class="hljs-keyword">new</span> Demo();<br>    System.out.println(demo1.num);<span class="hljs-comment">//输出结果为 10</span><br>    System.out.println(demo2.num);<span class="hljs-comment">//输出结果为 10</span><br>    Demo.num = <span class="hljs-number">20</span>;<br>   System.out.println(demo1.num);<span class="hljs-comment">//输出结果为 20</span><br>    System.out.println(demo2.num);<span class="hljs-comment">//输出结果为 20</span><br>    demo1.num = <span class="hljs-number">30</span>;<br>    System.out.println(demo1.num);<span class="hljs-comment">//输出结果为 30</span><br>    System.out.println(demo2.num);<span class="hljs-comment">//输出结果为 30</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="1-1-静态变量的初始化"><a href="#1-1-静态变量的初始化" class="headerlink" title="1.1 静态变量的初始化"></a>1.1 静态变量的初始化</h3><ul><li>非静态变量：创建对象后，系统会自动给对象中的非静态变量做初始化赋默认值。也正是因为这个原因，非静态变量只有在创建对象后，使用对象才能访问。 </li><li>静态变量：类加载到内存中（方法区）的时候，系统就会给类中的静态变量做初始化赋默认值。所以，即使还没有创建对象，只要这个类加载到了内存，就可以直接使用类名来访问静态变量，因为这个时候静态变量已经完成了初始化赋默认值的操作。</li></ul><br/><h3 id="1-3-静态变量的存储位置"><a href="#1-3-静态变量的存储位置" class="headerlink" title="1.3 静态变量的存储位置"></a>1.3 静态变量的存储位置</h3><p>类中的静态变量跟随着类一起保存在内存中的方法区。当创建对象的时候，对象中只会保存类中定义的非静态变量的信息，而静态变量是不会进入到对象中的。即静态变量依赖于类，与对象无关。</p><img src="D:\Users\MaxSeal\Desktop\杰普实训\corejava\笔记\图片\static变量初始化.png" style="zoom: 67%;" /><ul><li>Demo类，被加载到内存的时候，静态变量 num 已经完成了默认的初始化赋值操作。</li><li>可以通过类名（Demo.num）来访问，它可以直接找到方法区中存储的静态变量 num 。</li><li>可以通过对象（demo.num）来访问，引用 demo 先找到堆区中的对象，再根据对象中存储的 Demo.class 信息，找到方法区中存储的静态变量 num 。</li><li>无论使用类名还是使用对象来访问静态变量 num，都是访问的同一个 num，但是官方推荐的是使用类名来访问更加合适。</li></ul><br/><h2 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h2><p>static 关键字用来声明独立于对象的静态方法，即可以使用 类名.方法名的方式进行调用。</p><p>静态方法不能使用类的非静态变量和方法，也不能使用 this 关键字。因为在类加载完成的时候，往往在内存中，还没有创建这个类的对象，没有对象（也就没有this）就不能访问类中的非静态属性和非静态方法。 </p><p>静态方法用来封装一些不需要依赖对象的功能。</p><p>静态方法也是可以被继承的，可以被子类调用，但不能被重写（但能被再次声明）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  Demo.test();<span class="hljs-comment">//推荐的方式：类名.方法名</span><br>  Demo demo = <span class="hljs-keyword">new</span> Demo();<br>  demo.test();<span class="hljs-comment">//可以调用，但是不推荐</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br><span class="hljs-keyword">public</span> String num;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.num = <span class="hljs-number">10</span>;    <span class="hljs-comment">//编译报错，静态方法中不能使用非静态变量</span><br>        <span class="hljs-keyword">this</span>.sayHello();  <span class="hljs-comment">//编译报错</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>思考题：能否在构造器里对静态变量进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>&#123;<br>  num = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 不会报错</span><br>  &#125;<br>&#125;  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  System.out.println(Demo.num); <span class="hljs-comment">//输出结果为 0</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看出，虽然在构造器中给 num 赋值为10，但是在访问 num 的时候，看到的结果却是 0。这是因为，构造器是在创建对象的时候调用的，而在上面的代码中，我们并没有创建对象，而是直接使用类名访问了这个 num 属性，那么构造器中的代码也就没有执行，所以最后看到的结果是 0。</p><p>类中的构造器，可以给非静态属性做初始化，但是不能给静态属性做初始化。因为我们可以绕过创建对象的步骤，直接使用类名访问这个静态属性。</p><br/><h2 id="3-静态代码块"><a href="#3-静态代码块" class="headerlink" title="3. 静态代码块"></a>3. 静态代码块</h2><p>静态代码块，也叫做静态初始化代码块，它的作用就是给类中的静态属性做初始化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>  <span class="hljs-keyword">static</span>&#123;<br>  num = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>System.out.println(Demo.num); <span class="hljs-comment">//输出结果为 10</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>静态代码块的执行时刻：由于静态代码块没有名字，我们并不能主动调用，它会在类加载的时候，自动执行。 所以静态代码块，可以更早的给类中的静态属性，进行初始化赋值操作。 并且，静态代码块只会自动被执行一次，因为  JVM 在一次运行中，对一个类只会加载一次！</p><br/><h2 id="4-匿名代码块"><a href="#4-匿名代码块" class="headerlink" title="4. 匿名代码块"></a>4. 匿名代码块</h2><p>和静态代码块类似的，还有一种非静态代码块，也叫做匿名代码块，它的作用是给非静态属性做初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num;<br>  <br>  &#123;<br>  num = <span class="hljs-number">10</span>;<br>  &#125;<br>  <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Demo demo = <span class="hljs-keyword">new</span> Demo();<br>    System.out.println(demo.num);<span class="hljs-comment">//输出结果为 10</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><p>类中的构造器，既能给非静态属性进行初始化，又能配合 new 关键字进行对象的创建，所以匿名代码块使用的场景较少，它能完成的工作，使用构造器也一样可以完成。</p><p>匿名代码块执行的时刻： 由于匿名代码块没有名字，我们并不能主动调用，它会在创建对象的时候，构造器执行之前，自动执行。 并且每次创建对象之前，匿名代码块都会被自动执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-comment">// 静态代码块</span><br>  <span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;静态代码块执行&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 匿名代码块</span><br>  &#123;<br>    System.out.println(<span class="hljs-string">&quot;匿名代码块执行&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;构造器执行&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  <span class="hljs-keyword">new</span> Demo();<br>  <span class="hljs-keyword">new</span> Demo();<br>&#125;<br><span class="hljs-comment">// 静态代码执行了一次，因为JVM只会加载Demo类一次，而匿名代码块会在每次创建对象的时候，先执行，然后再执行构造器。</span><br></code></pre></td></tr></table></figure><br/><h2 id="5-创建和初始化对象的过程"><a href="#5-创建和初始化对象的过程" class="headerlink" title="5. 创建和初始化对象的过程"></a>5. 创建和初始化对象的过程</h2><ol><li><p>加载父类和子类中的静态属性和静态方法</p></li><li><p>执行父类中的静态代码块。</p></li><li><p>执行子类中的静态代码块。</p></li><li><p>对父类中的非静态属性赋默认值。</p></li><li><p>父类中的非静态属性进行显式赋值。</p></li><li><p>调用父类的匿名代码块。</p></li><li><p>调用父类的构造器。</p></li><li><p>对子类中的非静态属性赋默认值。</p></li><li><p>子类中的非静态属性进行显式赋值。</p></li><li><p>调用子类的匿名代码块。</p></li><li><p>调用子类的构造器。</p></li></ol><br/><h2 id="6-静态导入"><a href="#6-静态导入" class="headerlink" title="6. 静态导入"></a>6. 静态导入</h2><p>在自己的类中，要使用另一个类中的静态属性和静态方法，那么可以进行静态导入，导入完成后， 可以直接使用这个类中的静态属性和静态方法，而不用在前面加上类名。只有JDK1.5及以上版本，才可以使用静态导入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.PI;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(PI);<br>      System.out.println(random());<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修饰符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类</title>
    <link href="/2021/06/08/CoreJava/3.%20%E7%B1%BB/"/>
    <url>/2021/06/08/CoreJava/3.%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>类是一个模板，它描述一类对象的行为和状态。</p><span id="more"></span><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><ul><li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li><li><strong>对象</strong>：对象是类的一个实例，有状态和行为。</li></ul><br/><h2 id="2-类中的变量类型"><a href="#2-类中的变量类型" class="headerlink" title="2.  类中的变量类型"></a>2.  类中的变量类型</h2><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，<strong>方法结束后，变量就会自动销毁</strong>。</li><li><strong>成员变量（属性、实例变量）</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量（静态变量）</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-comment">// 属性、实例变量</span><br>  String name;<br>  <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">// 类变量 （即加了 static 的属性）</span><br>  <span class="hljs-keyword">static</span> String schoolName;<br>  <br>  <span class="hljs-comment">// 方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(String book)</span></span>&#123;<br>    <span class="hljs-comment">// book 就是局部变量</span><br>    System.out.println(<span class="hljs-string">&quot;name:&quot;</span> + name + <span class="hljs-string">&quot;在学习&quot;</span> + book);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><p>方法定义在类中，属于类的成员，所以也可以叫做成员方法。</p><h3 id="3-1-方法定义的格式"><a href="#3-1-方法定义的格式" class="headerlink" title="3.1 方法定义的格式"></a>3.1 方法定义的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修饰符：这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li>返回值类型 ：方法可能会返回值。返回值类型是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，返回值类型是关键字 void。</li><li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li><li>参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li>方法体：方法体包含具体的语句，定义该方法的功能。</li></ul><br/><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h2><h3 id="4-1-构造方法的特点"><a href="#4-1-构造方法的特点" class="headerlink" title="4.1 构造方法的特点"></a>4.1 构造方法的特点</h3><ul><li><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p></li><li><p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p></li><li><p>不管你是否自定义构造方法，所有的类都有构造方法。因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同。</p></li><li><p>一旦定义了自己的构造方法，默认构造方法就会失效。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个简单的构造函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br> <br>  <span class="hljs-comment">// 以下是构造函数</span><br>  MyClass() &#123;<br>    x = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-2-构造方法的作用"><a href="#4-2-构造方法的作用" class="headerlink" title="4.2 构造方法的作用"></a>4.2 构造方法的作用</h3><ul><li>使用 new 关键字来创建对象的时候，后面跟的必须是类中存在的构造方法。</li><li>构造方法中的代码，在对象创建后会被调用，从而可以完成对象的初始化工作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">//构造方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//创建对象的时候使用构造方法</span><br>    <span class="hljs-comment">//并且传参到构造方法中，构造方法中可以使用这些参数给属性进行初始化</span><br>    Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-3-默认构造方法"><a href="#4-3-默认构造方法" class="headerlink" title="4.3 默认构造方法"></a>4.3 默认构造方法</h3><p>即使在类中没有定义构造方法，那么在编译之后，也会自动的生成一个无参构造方法，并且构造方法中不执行任何代码。这个无参构造方法就被称为默认的构造方法。 我们也可以主动在类中定义出这个无参的默认构造方法。一旦定义了自己的构造方法，默认构造方法就会失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">//这个构造方法即使没有写出来，编译后也会自动生成的</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="4-4-构造方法的重载"><a href="#4-4-构造方法的重载" class="headerlink" title="4.4 构造方法的重载"></a>4.4 构造方法的重载</h3><p>除了默认的无参构造方法之外，在类中还可以对构造方法进行重载，让构造方法可以接收一些参数，然后使用这些参数进行对象的初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">//无参构造方法</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">//有参数构造方法，接收参数，进行对象属性的初始化</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.age = age;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.age = age;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="4-5-构造器之间的调用"><a href="#4-5-构造器之间的调用" class="headerlink" title="4.5 构造器之间的调用"></a>4.5 构造器之间的调用</h3><p>使用 this 关键字，可以在构造器中，调用另一个构造器，并且必须写在第一行。不能存在死循环（递归调用）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-comment">//无参构造器</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//调用俩参的构造器</span><br>        <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);   <span class="hljs-comment">// this 必须作为第一行代码。</span><br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-comment">//调用俩参的构造器</span><br>        <span class="hljs-keyword">this</span>(name,<span class="hljs-number">0</span>)<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-comment">//调用俩参的构造器</span><br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>,age);<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="5-参数传递"><a href="#5-参数传递" class="headerlink" title="5. 参数传递"></a>5. 参数传递</h2><h3 id="5-1-参数类型"><a href="#5-1-参数类型" class="headerlink" title="5.1 参数类型"></a>5.1 参数类型</h3><p>java方法的参数，分为形参和实参。 </p><ul><li><p>形参：形式上的参数，作用是接收外部传过来的实际参数的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;...&#125;<br><span class="hljs-comment">// a 就是一个形参。</span><br></code></pre></td></tr></table></figure><br/></li><li><p>实参：调用方法时实际上传递的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      t.test(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// x 就是一个实参。</span><br>      t.test(x);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><br/><h3 id="5-2-值传递"><a href="#5-2-值传递" class="headerlink" title="5.2 值传递"></a>5.2 值传递</h3><p>方法的参数是基本类型，调用方法并传参，这时候进行的是值传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">//该方法中，改变参数当前的值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    a = <span class="hljs-number">10</span>;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    System.out.println(<span class="hljs-string">&quot;before: a = &quot;</span> + a);<span class="hljs-comment">//传参之前，变量a的值，结果为 1。</span><br>    changeNum(a);<br>    System.out.println(<span class="hljs-string">&quot;after: a = &quot;</span> + a);<span class="hljs-comment">//传参之后，变量a 的值，结果仍然为 1。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>值传递，实参把自己存储的值（基本类型都是简单的数字）赋值给形参，之后形参如何操作，对实参一点影响没有。并且形参在方法调用结束后自动销毁。</p><br/><h3 id="5-3-引用传递"><a href="#5-3-引用传递" class="headerlink" title="5.3 引用传递"></a>5.3 引用传递</h3><p>方法的参数是引用类型，调用方法并传参，这时候进行的是引用传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  String name;<br>  String age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">// 该方法中，改变引用 s 所指向对象的 name 属性值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeName</span><span class="hljs-params">(Student s)</span></span>&#123;<br>  s.name = <span class="hljs-string">&quot;tom&quot;</span>;<br>  &#125;<span class="hljs-function">Z</span><br><span class="hljs-function">  </span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    s.name = <span class="hljs-string">&quot;seal&quot;</span><br>    System.out.println(<span class="hljs-string">&quot;before: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之前，引用 s 所指向对象的 name 属性值，结果为 seal。</span><br>    changeName(s);<br>    System.out.println(<span class="hljs-string">&quot;after: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之后，引用 s 所指向对象的 name 属性值，结果为 tom。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">// 该方法中，改变引用s所指向对象的 name 属性值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeName</span><span class="hljs-params">(Student s)</span></span>&#123;<br>  s = <span class="hljs-keyword">new</span> Student();<br>    s.name = tom;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    s.name = <span class="hljs-string">&quot;seal&quot;</span><br>    System.out.println(<span class="hljs-string">&quot;before: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之前，引用s所指向对象的name属性值，结果为 seal。</span><br>    changeName(s);<br>    System.out.println(<span class="hljs-string">&quot;after: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之后，引用s所指向对象的name属性值，结果为 seal。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于引用传递，是实参将自己存储的对象地址，赋值给了形参，这时候俩个引用（实参和形参）指 向了同一个对象，那么任何一个引用（实参或形参）操作对象，例如属性赋值，那么另一个引用 （形参或实参）都可以看到这个对象中属性的变量，因为俩个引用指向同一个对象。</p><br/><h2 id="6-this-关键字"><a href="#6-this-关键字" class="headerlink" title="6. this 关键字"></a>6. this 关键字</h2><p>在类中的非静态方法中，可以使用 this 关键，来表示当前类将来的一个对象。</p><h3 id="6-1-使用场景"><a href="#6-1-使用场景" class="headerlink" title="6.1 使用场景"></a>6.1 使用场景</h3><ul><li>区别成员变量和局部变量</li><li>调用类中的其他方法 </li><li>调用类中的其他构造方法</li></ul><br/><h3 id="6-2-区别成员变量和局部变量"><a href="#6-2-区别成员变量和局部变量" class="headerlink" title="6.2 区别成员变量和局部变量"></a>6.2 区别成员变量和局部变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-comment">// = 号左边的 this.name，表示类中的属性 name</span><br>    <span class="hljs-comment">// = 号右边的 name，表示当前方法的参数 name（就近原则）</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="6-3-调用类中的其它方法"><a href="#6-3-调用类中的其它方法" class="headerlink" title="6.3 调用类中的其它方法"></a>6.3 调用类中的其它方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//表示调用当前类中的 setName 方法</span><br>    <span class="hljs-comment">// 默认情况下，setName(&quot;tom&quot;) 和 this.setName(&quot;tom&quot;) 的效果是一样的，所以这里也可以省去 this.</span><br>      <span class="hljs-keyword">this</span>.setName(<span class="hljs-string">&quot;tom&quot;</span>);   <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="6-4-调用类中的其他构造方法"><a href="#6-4-调用类中的其他构造方法" class="headerlink" title="6.4 调用类中的其他构造方法"></a>6.4 调用类中的其他构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//调用一个参数的构造方法,参数的类型是 String</span><br>    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>this 的这种调用构造方法的用法，只能在类中的一个构造方法，调用另一个构造方法。并且不能在普通的方法中调用类的构造方法。 并且要求，this 调用构造方法的代码，是当前构造方法中的第一句代码，否则编译报错。</p><br/><h3 id="6-5-思考题"><a href="#6-5-思考题" class="headerlink" title="6.5 思考题"></a>6.5 思考题</h3><p>如果这时候创建俩个对象，那么this又代表哪一个对象呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.show(); <span class="hljs-comment">//问题：这个 this 代表的是 stu1 还是 stu2</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Student stu1 = <span class="hljs-keyword">new</span> Student();<br>        stu1.sayHello();<br>        Student stu2 = <span class="hljs-keyword">new</span> Student();<br>        stu2.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实每一个对象中，都有自己的 this，和其他对象中的互不影响。</p><p>方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this 就代表谁。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2021/06/08/CoreJava/4.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/06/08/CoreJava/4.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象思想，是一种程序设计思想，使用这种思想进行编程的语言，就是面向对象编程语言。</p><span id="more"></span><h2 id="1-面向对象-OOP"><a href="#1-面向对象-OOP" class="headerlink" title="1. 面向对象 OOP"></a>1. 面向对象 OOP</h2><ul><li>OOP（object oriented programming），面向对象编程把构成问题的各种事物，抽象成各个对象，这些对象具有解决问题的行为（方法），同时对象还可以具有解决很多类似问题的行为（方法），而不只是能解决一个问题。</li><li>POP（procedure oriented Programming），面向过程编程分析出，解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，然后依次调用就可以了。</li><li>FP（functional programming)，函数式编程类似于面向过程的程序设计方式，具有很高的抽象程度。JDK8中的一些特性，可以支持使用函数式编程。</li></ul><p>面向对象的特点：封装、继承和多态。     </p><p>面向对象思想，是一种程序设计思想，使用这种思想进行编程的语言，就是面向对象编程语言。面向对象中的对象，泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，定义为程序中的一种数据类型。 面向对象的思想，主要强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p><br/><h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h2><p>封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。</p><p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全。</p><br/><h3 id="2-1-封装的优点"><a href="#2-1-封装的优点" class="headerlink" title="2.1 封装的优点"></a>2.1 封装的优点</h3><ul><li>提高代码的安全性，重要信息可以私有化，不对外暴露。</li><li>提高代码的复用性，常用的代码或者功能封装到方法中，可以在其他地方反复调用。</li><li>封装代码的实现细节，便于修改内部代码，提高可维护性。</li><li>简化外部的调用，便于调用者使用。</li></ul><br/><h3 id="2-2-例子"><a href="#2-2-例子" class="headerlink" title="2.2  例子"></a>2.2  例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-comment">//使用 private 关键字来修饰属性，不允许外部直接访问该属性。</span><br>    <span class="hljs-keyword">private</span> String name;<br>  <br>    <span class="hljs-comment">//提供公共的 setName 方法，可以让外部调用该方法给 name 属性赋值。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>  <br>    <span class="hljs-comment">//提供公共的 getName 方法，可以让外部调用该方法获取 name 属性的值。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h2><p>继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象具有父类的域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><br/><h3 id="3-1-继承的类型"><a href="#3-1-继承的类型" class="headerlink" title="3.1 继承的类型"></a>3.1 继承的类型</h3><p>![](D:\Users\MaxSeal\Desktop\杰普实训\corejava\笔记\图片\7. 对象和类\继承的类型.png)</p><h3 id="3-2-继承的特性"><a href="#3-2-继承的特性" class="headerlink" title="3.2 继承的特性"></a>3.2 继承的特性</h3><ul><li>子类继承了父类的非 private 的属性和方法，但没有继承父类的构造器。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法（重写）。</li><li>Java 的继承是单继承，但是可以多重继承，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li><li>所有类都直接或间接地继承了 Object 类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义Person类，作为父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">// 父类的构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;hello~ I am &quot;</span>+name);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义Student类，作为子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <br> <span class="hljs-comment">//这个是子类中单独定义的方法，和父类无关</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span></span>&#123;<br>        name = <span class="hljs-string">&quot;jack&quot;</span>;  <span class="hljs-comment">//访问从父类中继承过来的方法</span><br>        sayHello();     <span class="hljs-comment">//调用从父类中继承过来的方法</span><br>        age = <span class="hljs-number">20</span>;       <span class="hljs-comment">//编译报错，age是父类中的私有属性，子类中不能访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="4-super-关键字"><a href="#4-super-关键字" class="headerlink" title="4. super 关键字"></a>4. super 关键字</h2><p>子类继承父类，创建子类对象的时候，会先默认调用父类的构造器。因为子类继承父类，会继承父类的属性和方法，那么就需要先调用父类的构造器对父类中的属性进行初始化，初始化完成后再给子类使用。</p><p>在子类中，使用 super 关键字一般做以下事情： 访问父类中的属性、调用父类中的方法、调用父类中的构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义Person类，作为父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Person类中的构造器被调用&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义Student类，作为子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Student类中的构造器被调用&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><span class="hljs-keyword">new</span> Student();<br>&#125;<br><span class="hljs-comment">// main 方法执行会输出以下语句：</span><br><span class="hljs-comment">// Person类中的构造器被调用</span><br><span class="hljs-comment">// Student类中的构造器被调用</span><br></code></pre></td></tr></table></figure><br/><h3 id="4-1-访问父类中的属性"><a href="#4-1-访问父类中的属性" class="headerlink" title="4.1 访问父类中的属性"></a>4.1 访问父类中的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>String name = <span class="hljs-string">&quot;zs&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-comment">//注意，这里是故意和父类中的属性重名</span><br>    String name = <span class="hljs-string">&quot;lisi&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//直接使用 name，表示 Student 中的 name 属性（就近原则）</span><br>      System.out.println(name);<br>      <span class="hljs-comment">//也可以使用 this 和 super 来区分访问的是哪个 name</span><br>      System.out.println(<span class="hljs-keyword">this</span>.name);  <span class="hljs-comment">//Student 中的 name</span><br>      System.out.println(<span class="hljs-keyword">super</span>.name); <span class="hljs-comment">//父类 Person 中的 name</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="4-2-调用父类中的方法"><a href="#4-2-调用父类中的方法" class="headerlink" title="4.2 调用父类中的方法"></a>4.2 调用父类中的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;person run..&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-comment">//注意，这里是故意和父类中的方法重名</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;student run..&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//直接使用 name，表示 Student 中的 run 方法（就近原则）</span><br>        run();<br>        <span class="hljs-comment">//也可以使用 this 和 super 来区分调用的是哪个 run 方法</span><br>        <span class="hljs-keyword">this</span>.run();<br>        <span class="hljs-keyword">super</span>.run();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><br/><h3 id="4-3-调用父类中的构造器"><a href="#4-3-调用父类中的构造器" class="headerlink" title="4.3 调用父类中的构造器"></a>4.3 调用父类中的构造器</h3><h4 id="4-3-1-子类构造器中隐式调用父类无参构造器"><a href="#4-3-1-子类构造器中隐式调用父类无参构造器" class="headerlink" title="4.3.1 子类构造器中隐式调用父类无参构造器"></a>4.3.1 子类构造器中隐式调用父类无参构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//这里会隐式调用（自动调用）父类的无参构造器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="4-3-2-子类构造器中显式调用父类无参构造器"><a href="#4-3-2-子类构造器中显式调用父类无参构造器" class="headerlink" title="4.3.2 子类构造器中显式调用父类无参构造器"></a>4.3.2 子类构造器中显式调用父类无参构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//也可以使用 super 关键字，显示调用父类的构造器（有参的无参的都可以调用）</span><br>      <span class="hljs-keyword">super</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h4 id="4-3-3-子类构造器中显式调用父类有参构造器"><a href="#4-3-3-子类构造器中显式调用父类有参构造器" class="headerlink" title="4.3.3 子类构造器中显式调用父类有参构造器"></a>4.3.3 子类构造器中显式调用父类有参构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//也可以使用super关键字，显示调用父类的构造器（有参的无参的都可以调用）</span><br>    <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><p>在构造器中，可以使用 this 调用类中其他构造器，也可以使用 super 调用父类中的构造器。 但是 this 和 super 这俩种调用构造器的代码，不能同时出现，否则会报错。 这是因为 this 调用构造器的语句和 super 调用构造器的语句，都要求自己是第一句代码，但是构造器中的第一句代码只能有一个，所以它们俩个不能同时出现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-comment">//编译报错，在使用 this 和 super 调用构造器功能的时候，它们俩个不能同时出现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h2 id="5-重写"><a href="#5-重写" class="headerlink" title="5. 重写"></a>5. 重写</h2><p>方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法，就称为重写。</p><p>重写规则：</p><ul><li>参数列表与被重写方法的参数列表必须完全相同。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。</li><li>如果不能继承一个类，则不能重写该类的方法。</li><li>父类的方法只能被它的子类重写。</li><li>构造方法不能被重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li></ul><p>子类继承父类，继承了父类中的方法，但是父类中的方法并不一定能满足子类中的功能需要，所以子类中需要把方法进行重写。</p><br/><h2 id="6-多态"><a href="#6-多态" class="headerlink" title="6. 多态"></a>6. 多态</h2><p>多态是同一个行为具有多个不同表现形式或形态的能力。相同类型的不同对象，调用同一个方法，最终执行结果是不同的。</p><h3 id="6-1-多态的优点"><a href="#6-1-多态的优点" class="headerlink" title="6.1 多态的优点"></a>6.1 多态的优点</h3><ul><li><p>消除类型之间的耦合关系</p></li><li><p>可替换性</p></li><li><p>可扩充性</p></li><li><p>接口性</p></li><li><p>灵活性</p></li><li><p>简化性</p><br/></li></ul><h3 id="6-2-多态存在的三个前提"><a href="#6-2-多态存在的三个前提" class="headerlink" title="6.2 多态存在的三个前提"></a>6.2 多态存在的三个前提</h3><ul><li><p>子类继承父类 </p></li><li><p>子类重写父类中的方法 </p></li><li><p>父类的引用指向子类对象</p><p>注意，类实现接口，这是一种特殊形式的继承，多态也可以体现在类和接口的关系中。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 人</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;你好！&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 学生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;hello！我是一名酷酷的学生&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 老师类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;hi！我是一名酷酷的老师&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//声明父类的引用</span><br>  Person person;<br>  <br>  <span class="hljs-comment">//根据随机数的情况，让父类引用person指向不同的子类对象（Student对象或者Teacher对象）</span><br>  <span class="hljs-keyword">int</span> random = (<span class="hljs-keyword">int</span>) (Math.random()*<span class="hljs-number">10</span>);<br>  <br>  <span class="hljs-keyword">if</span>(random%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>  person = <span class="hljs-keyword">new</span> Student();  <span class="hljs-comment">// 一个父类型的引用，可以指向它的任何一个子类对象</span><br>  <span class="hljs-keyword">else</span><br>  person = <span class="hljs-keyword">new</span> Teacher();<br>  <br>  <span class="hljs-comment">//使用person引用，调用子类对象中重写的方法</span><br><span class="hljs-comment">//关键点在于，在调用sayHello方法的时候，引用person指向的对象是谁</span><br>person.sayHello();<br>  <br>  <span class="hljs-comment">// 同一类型（Person）的引用，指向不同的子类对象（Student 或者 Teacher），调用同一个方法（sayHello），最后是不一样的表现形式（执行结果不同）！</span><br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="6-3-多态的实现方式"><a href="#6-3-多态的实现方式" class="headerlink" title="6.3 多态的实现方式"></a>6.3 多态的实现方式</h3><ul><li><p>重写</p></li><li><p>接口</p></li><li><p>抽象类</p></li></ul><br/><h2 id="7-重载"><a href="#7-重载" class="headerlink" title="7. 重载"></a>7. 重载</h2><p>方法重载是一个类中定义了多个同名的方法，而他们的参数的数量不同或数量相同而类型和次序不同，则称为方法的重载。</p><h3 id="7-1-重载规则"><a href="#7-1-重载规则" class="headerlink" title="7.1 重载规则"></a>7.1 重载规则</h3><ul><li>被重载的方法必须改变参数列表（参数个数、类型和次序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <br><span class="hljs-comment">//参数的个数不同</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s1, String s2)</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">//参数的类型不同</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">double</span> salary)</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">//参数的顺序不同</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, String s)</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">//方法的参数可以相同，也可以不同</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 可变参数和数组，编译会报错，可变参数和数组其实是一样的。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span>... i)</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span>[] a)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br/><h3 id="7-2-涉及到隐式类型转换的重载"><a href="#7-2-涉及到隐式类型转换的重载" class="headerlink" title="7.2 涉及到隐式类型转换的重载"></a>7.2 涉及到隐式类型转换的重载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;  <br><span class="hljs-comment">//方法重载</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">long</span> b)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">long</span> b, <span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Test t = <span class="hljs-keyword">new</span> Test();<br>        t.test(<span class="hljs-number">1</span>, <span class="hljs-number">1L</span>);  <span class="hljs-comment">//调用到第一个方法</span><br>        t.test(<span class="hljs-number">1L</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//调用到第二个方法</span><br>        t.test(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">//问题：这个会调用到哪一个test方法？</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 注意，这时候， t.test(1,1) 代码是会编译报错的，因为类中定义的俩个方法都匹配。</span><br><span class="hljs-comment">// 注意，当参数无法完全精确匹配到方法的时候，参数会尝试做自动转换，然后再去尝试匹配方法。</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-comment">//重载方法1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>    <span class="hljs-comment">//重载方法2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">short</span> a)</span></span>&#123;&#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Test t = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-keyword">byte</span> a = <span class="hljs-number">1</span>;<br>        t.test(a);  <br>      <span class="hljs-comment">// 这里会调用第二个方法，也就是 short 类型参数的 test 方法。</span><br>        <span class="hljs-comment">// 虽然byte类型数据，可以自动转换为 short，也可以转换为 int，但是 short 离 byte 更近。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-重写与重载的区别"><a href="#8-重写与重载的区别" class="headerlink" title="8. 重写与重载的区别"></a>8. 重写与重载的区别</h2><p>方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。</p><table><thead><tr><th align="left">区别点</th><th align="left">重载</th><th align="left">重写</th></tr></thead><tbody><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可以修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可以修改</td><td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问</td><td align="left">可以修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 中的命名规则</title>
    <link href="/2021/06/07/CoreJava/2.%20java%20%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>/2021/06/07/CoreJava/2.%20java%20%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>项目名、包名、类名、变量名、常量名和方法名的命名规范。</p><span id="more"></span><p>创建一个项目之后，子类中的东西命名规范如下：</p><ul><li><strong>项目名</strong>全部小写，多个单词中间用<code>-</code>连接</li><li><strong>包名</strong>全部小写</li><li><strong>类名</strong>首字母大写，其余组成词首字母依次大写（大驼峰命名）</li><li><strong>变量名</strong>、<strong>方法名</strong>首字母小写，其余组成词的首字母都要大写（小驼峰命名）</li><li><strong>常量名</strong>全部大写，多个单词中间用<code>_</code>连接</li></ul><p>所有命名规则必须遵循Java本身的规则：</p><ul><li>名称只能由字母、数字、下划线、$符号组成</li><li>不能以数字开头</li><li>名称不能使用 Java 中的关键字</li><li>坚决不允许出现中文及拼音命名</li></ul><table><thead><tr><th>类型</th><th>约束</th><th>举例</th></tr></thead><tbody><tr><td>项目名</td><td>全部小写，多个单词用中划线【**-**】分隔</td><td>spring-cloud</td></tr><tr><td>包名</td><td>全部小写</td><td>com.company</td></tr><tr><td>类名</td><td>单词首字母大写，其余组成词首字母依次大写（大驼峰命名）</td><td>PaintFigure</td></tr><tr><td>变量名</td><td>首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写</td><td>password、userName</td></tr><tr><td>常量名</td><td>全部大写，多个单词，用【**_**】分隔</td><td>EXAM_TIME</td></tr><tr><td>方法名</td><td>首字母小写，其余组成词的首字母都要大写（小驼峰命名）</td><td>createExam</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命名规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包装类</title>
    <link href="/2021/06/06/CoreJava/10.%20Number%E7%B1%BB%E5%92%8CObject%E7%B1%BB/"/>
    <url>/2021/06/06/CoreJava/10.%20Number%E7%B1%BB%E5%92%8CObject%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>Number 类是 java.lang 包下的一个抽象类，提供了将包装类型拆箱成基本类型的方法，所有基本类型（数据类型）的包装类型都继承了该抽象类，并且是 final 声明不可继承改变。</p><span id="more"></span><h4 id="1-Number-类"><a href="#1-Number-类" class="headerlink" title="1. Number 类"></a>1. Number 类</h4><p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p><img src="https://i.loli.net/2021/06/06/GXh94qejMatDkO7.png" alt="number类.png" style="zoom:50%;" /><h5 id="1-1-装箱-amp-拆箱"><a href="#1-1-装箱-amp-拆箱" class="headerlink" title="1.1 装箱 &amp; 拆箱"></a>1.1 装箱 &amp; 拆箱</h5><p>这种由编译器特别支持的包装称为装箱，所以当基本数据类型被当作对象使用的时候，编译器会把它们装箱为包装类。</p><p>相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Integer x = <span class="hljs-number">5</span>;            <span class="hljs-comment">// 当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。</span><br>      x =  x + <span class="hljs-number">10</span>;              <span class="hljs-comment">// 然后，为了使x能进行加运算，所以要对x进行拆箱。</span><br>      System.out.println(x); <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-常用的方法"><a href="#1-2-常用的方法" class="headerlink" title="1.2 常用的方法"></a>1.2 常用的方法</h5><ul><li><p>xxxValue()<br>将 Number 对象转换为xxx数据类型的值并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Number n = <span class="hljs-number">1</span>;<br>n.doubleValue();     <span class="hljs-comment">// 转化为 double 类型。</span><br>n.byteValue();<span class="hljs-comment">// 转化为 byte 类型。</span><br>n.floatValue();<span class="hljs-comment">// 转化为 float 类型。</span><br>n.longValue();<span class="hljs-comment">// 转化为 long 类型。</span><br>n.shortValue();<span class="hljs-comment">// 转化为 short 类型。</span><br>n.intValue();<span class="hljs-comment">// 转化为 int 类型。</span><br></code></pre></td></tr></table></figure></li><li><p>valueOf()</p><p>用于返回给定参数的原生 Number 对象值，参数可以是基本数据类型，String等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x =Integer.valueOf(<span class="hljs-number">9</span>);<br>Double c = Double.valueOf(<span class="hljs-number">5.0</span>);<br>Float a = Float.valueOf(<span class="hljs-string">&quot;80&quot;</span>);              <br>Integer b = Integer.valueOf(<span class="hljs-string">&quot;444&quot;</span>,<span class="hljs-number">16</span>);   <span class="hljs-comment">// 使用 16 进制</span><br><br>System.out.println(x);<br>System.out.println(c);<br>System.out.println(a);<br>System.out.println(b);<br></code></pre></td></tr></table></figure></li><li><p>compareTo()</p><p>用于将 Number 对象与方法的参数进行比较。参数可以是 Byte, Double, Integer, Float, Long 或 Short 类型。</p><p>该方法<strong>用于两个相同数据类型的比较</strong>，两个不同类型的数据不能用此方法来比较。</p><ul><li>如果指定的数与参数相等返回 0。</li><li>如果指定的数小于参数返回 -1。</li><li>如果指定的数大于参数返回 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>System.out.println(x.compareTo(<span class="hljs-number">3</span>));    <span class="hljs-comment">// 结果为 1</span><br>System.out.println(x.compareTo(<span class="hljs-number">5</span>));    <span class="hljs-comment">// 结果为 0</span><br>System.out.println(x.compareTo(<span class="hljs-number">8</span>));    <span class="hljs-comment">// 结果为 -1</span><br></code></pre></td></tr></table></figure></li><li><p>equals()</p><p>判断 Number 对象是否与参数相等。</p><p>如 Number 对象不为 Null，且与方法的<strong>参数类型与数值都相等</strong>返回 True，否则返回 False。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>Double y = <span class="hljs-number">5.0</span>;<br>Long z = <span class="hljs-number">5</span>;<br>Short a = <span class="hljs-number">5</span>;<br>Float b = <span class="hljs-number">5.0</span>;<br>Byte c = <span class="hljs-number">5</span>; <br><br>System.out.println(x.equals(y));  <span class="hljs-comment">// false</span><br>System.out.println(x.equals(z));  <span class="hljs-comment">// false</span><br>System.out.println(x.equals(a));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p>toString(）</p><p>返回以一个字符串表示的 Number 对象值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>System.out.println(x.toString());<br>System.out.println(Integer.toString(<span class="hljs-number">12</span>));<br>System.out.println(Integer.toString(<span class="hljs-number">12</span>, <span class="hljs-number">16</span>)); <span class="hljs-comment">// 用 16 进制 </span><br></code></pre></td></tr></table></figure></li><li><p>parseXXX() </p><p>用于将字符串参数作为有符号的十进制（默认）XXX类型进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x =Integer.parseInt(<span class="hljs-string">&quot;9&quot;</span>);<br><span class="hljs-keyword">double</span> c = Double.parseDouble(<span class="hljs-string">&quot;5&quot;</span>);<br><span class="hljs-keyword">int</span> b = Integer.parseInt(<span class="hljs-string">&quot;444&quot;</span>,<span class="hljs-number">16</span>);   <span class="hljs-comment">// 用 16 进制 </span><br><br>System.out.println(x);<br>System.out.println(c);<br>System.out.println(b);<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Object-类"><a href="#2-Object-类" class="headerlink" title="2. Object 类"></a>2. Object 类</h4><p>Object 类是所有类的父类型，类中定义的方法，java 中所有对象都可以调用。</p><h5 id="2-1-toString"><a href="#2-1-toString" class="headerlink" title="2.1 toString()"></a>2.1 toString()</h5><ul><li>返回对象的字符串表示形式。</li><li>默认返回格式：<strong>对象的 class 名称 + @ + hashCode 的十六进制字符串</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Object obj1 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj1.toString());<br>      <span class="hljs-comment">// java.lang.Object@d716361</span><br><br>        Object obj2 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj2.toString());<br>      <span class="hljs-comment">//java.lang.Object@6ff3c5b5</span><br> <br>        Object obj3 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj3.toString());<br>      <span class="hljs-comment">//java.lang.Object@3764951d</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-getClass"><a href="#2-2-getClass" class="headerlink" title="2.2 getClass()"></a>2.2 getClass()</h5><p>getClass() 方法用于获取对象的运行时对象的类类型。返回值是 Class&lt;?&gt;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> <br>    Object obj1 = <span class="hljs-keyword">new</span> Object();<br>    System.out.println(<span class="hljs-string">&quot;obj1 的类为: &quot;</span> + obj1.getClass());<br> <span class="hljs-comment">// obj1 的类为: class java.lang.Object</span><br>      <br>    String obj2 = <span class="hljs-keyword">new</span> String();<br>    System.out.println(<span class="hljs-string">&quot;obj2 的类为: &quot;</span> + obj2.getClass());<br>    <span class="hljs-comment">// obj2 的类为: class java.lang.String</span><br> <br>    ArrayList&lt;Integer&gt; obj3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    System.out.println(<span class="hljs-string">&quot;obj3 的类为: &quot;</span> + obj3.getClass());<br>    <span class="hljs-comment">// obj3 的类为: class java.util.ArrayList</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-hashCode"><a href="#2-3-hashCode" class="headerlink" title="2.3 hashCode()"></a>2.3 hashCode()</h5><p>该方法返回一个 int 值，该 int 值是 JVM 根据对象在内存的中的特征（地址值），通过hash算法计算出的一 个结果。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Hash，一般翻译做“散列”，也可以音译为“哈希”，就是把任意长度的数据输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。 一个任意长度的输入转为一个固定长度的输出，是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以<strong>不可能从散列值来确定唯一的输入值</strong>。</p><p>我们可以认为，Object 中的 hashCode 方法默认返回的是对象的内存地址，但是实际上可能并不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Object obj1 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj1.hashCode()); <br> <br>        Object obj2 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj2.hashCode());<br> <br>        Object obj3 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj3.hashCode()); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于俩个对象的 hashCode 值： </p><ul><li>相等的俩个对象，hashCode 值一定相等。 </li><li>hashCode 值相同，俩个对象有可能相等，也可能不同等。 </li><li>hashCode 值不同，俩个对象一定不同。</li></ul><h5 id="2-4-equals"><a href="#2-4-equals" class="headerlink" title="2.4 equals()"></a>2.4 equals()</h5><p>用于比较两个对象是否相等。</p><p>Object 中的 equals 方法，是直接使用的 == 号进行的比较，比较俩个对象的地址值是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>equal 方法可以被重写，如 String 类重写了 equals() 方法，用于比较两个字符串是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        String obj1 = <span class="hljs-keyword">new</span> String();<br>        String obj2 = <span class="hljs-keyword">new</span> String();<br> <br>        <span class="hljs-comment">// 判断 obj1 与 obj2 是否相等</span><br>        <span class="hljs-comment">// 初始化的两个对象都为 null，所以是相等，返回 true</span><br>        System.out.println(obj1.equals(obj2)); <span class="hljs-comment">// true</span><br> <br>        <span class="hljs-comment">// 给对象赋值</span><br>        obj1 = <span class="hljs-string">&quot;Baidu&quot;</span>;<br>        obj2 = <span class="hljs-string">&quot;Google&quot;</span>;<br> <br>        <span class="hljs-comment">// 判断 obj1 与 obj2 是否相等</span><br>        <span class="hljs-comment">// 两个值不同，内存地址也不同，所以不相等，返回 false</span><br>        System.out.println(obj1.equals(obj2)); <span class="hljs-comment">// false</span><br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对equals方法重写，一般需要注意以下几点： </p><ol><li>自反性：对任意引用 obj，obj.equals(obj) 的返回值一定为 true. </li><li>对称性：对于任何引用 o1、o2，当且仅当 o1.equals(o2) 返回值为 true 时，o2.equals(o1) 的返回值一 定为 true; </li><li>传递性：如果 o1.equals(o2) 为 true, o2.equals(o3) 为 true,则 o1.equals(o3) 也一定为 true </li><li>一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变 </li><li>非空性：任何非空的引用 obj，obj.equals(null) 的返回值一定为false</li></ol>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>包装类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修饰符</title>
    <link href="/2021/06/06/CoreJava/5.%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2021/06/06/CoreJava/5.%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>Java 语言提供了很多修饰符，主要分为以下两类： 访问修饰符和非访问修饰符。修饰符用来定义类、方法或者变量，通常放在语句的最前端。</p><span id="more"></span><h2 id="1-访问控制修饰符"><a href="#1-访问控制修饰符" class="headerlink" title="1. 访问控制修饰符"></a>1. 访问控制修饰符</h2><p>Java中，可以使用访问控制符来<strong>保护对类、变量、方法和构造方法的访问</strong>。</p><ul><li><p><strong>default（默认访问修饰符）：</strong></p><p>使用 default 的变量和方法，<strong>对同一个包内的类是可见的</strong>。</p><p>接口里的变量都隐式声明为 <strong>public static final</strong>，而接口里的方法默认情况下访问权限为 <strong>public</strong>。</p><p>使用对象：类、接口、变量、方法。</p></li><li><p><strong>public（公有访问修饰符）：</strong></p><p>被声明为 public 的类、方法、构造方法和接口<strong>能够被任何其他类访问</strong>。</p><p>使用对象：类、接口、变量、方法。</p></li><li><p><strong>private（私有访问修饰符）：</strong></p><p>被声明为 private 的方法、变量和构造方法<strong>只能被所属类访问</strong>。</p><p>使用对象：变量、方法，不能修饰类（外部类）。</p></li><li><p><strong>protected（受保护的访问修饰符）：</strong></p><p>使用对象：变量、方法，不能修饰类（外部类）。</p><ul><li>子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected 方法。 </li></ul></li></ul><br/><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(同一包)</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y/N</td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left">Y</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><br/><h2 id="2-非访问控制修饰符"><a href="#2-非访问控制修饰符" class="headerlink" title="2. 非访问控制修饰符"></a>2. 非访问控制修饰符</h2><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><ul><li><p><strong>static：</strong></p><ul><li><p>static 变量：</p><p>static 关键字用来声明独立于对象的静态变量，<strong>无论一个类实例化多少对象，它的静态变量只有一份拷贝</strong>。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p>static 方法：</p><p>static 关键字用来声明独立于对象的静态方法，即可以使用 类名.方法名 的方式进行调用。<strong>静态方法不能使用类的非静态变量</strong>。静态方法从参数列表得到数据，然后计算这些数据。</p></li></ul><br/></li><li><p><strong>final：</strong></p><ul><li><p>final 变量：</p><p>final 表示“最后的、最终的含义”，变量<strong>一旦赋值后，不能被重新赋值</strong>。被 final 修饰的实例变量<strong>必须显式指定初始值</strong>。final 修饰符通常和 static 修饰符一起使用来创建类常量。</p></li><li><p>final 方法：</p><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是<strong>防止该方法的内容被修改</strong>。</p></li></ul></li></ul>  <br/><ul><li><p><strong>abstract：</strong></p><ul><li><p>abstract 类：</p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了<strong>将来对该类进行扩充</strong>。</p><p>一个类不能同时被 abstract 和 final 修饰。</p><p><strong>如果一个类包含抽象方法，那么该类一定要声明为抽象类</strong>，否则将出现编译错误。</p><p><strong>抽象类可以包含抽象方法和非抽象方法</strong>。</p></li><li><p>abstract 方法：</p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p><strong>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</strong></p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p><strong>抽象方法的声明以分号结尾。</strong></p></li></ul></li></ul>  <br/><ul><li><p><strong>synchronized：</strong></p><ul><li>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</li></ul></li></ul>  <br/><ul><li><p><strong>transient：</strong></p><ul><li><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p></li><li><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p></li></ul></li></ul>  <br/><ul><li><p><strong>volatile：</strong></p><ul><li>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</li><li>一个 volatile 对象引用可能是 null。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>修饰符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日期处理</title>
    <link href="/2021/06/06/CoreJava/12.%20%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <url>/2021/06/06/CoreJava/12.%20%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>一些常见的日期处理方式。</p><span id="more"></span><h4 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a><strong>关键类</strong></h4><ul><li>Instant：瞬时实例。</li><li>LocalDate：本地日期，不包含具体时间。例如：2014-01-14 可以用来记录生日、纪念日、加盟日等。</li><li>LocalTime：本地时间，不包含日期。</li><li>LocalDateTime：组合了日期和时间，但不包含时差和时区信息。</li><li>ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。</li></ul><p>新API还引入了 ZoneOffSet 和 ZoneId 类，使得解决时区问题更为简便。解析、格式化时间的 DateTimeFormatter 类也全部重新设计。</p><h4 id="1-获取当前日期"><a href="#1-获取当前日期" class="headerlink" title="1. 获取当前日期"></a>1. 获取当前日期</h4><p>LocalDate 用于表示当天日期。只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCurrentDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate today = LocalDate.now();  <span class="hljs-comment">// 获取当前时间</span><br>  System.out.println(date);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-获取年月日信息"><a href="#2-获取年月日信息" class="headerlink" title="2. 获取年月日信息"></a>2. 获取年月日信息</h4><p>LocalDate 提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getDetailDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate today = LocalDate.now();   <span class="hljs-comment">// 获取当前日期</span><br>  <span class="hljs-keyword">int</span> year = today.getYear();<span class="hljs-comment">// 获取年份</span><br>  <span class="hljs-keyword">int</span> month = today.getMonthValue();  <span class="hljs-comment">// 获取月份</span><br>  <span class="hljs-keyword">int</span> day = today.getDayOfMonth();   <span class="hljs-comment">// 获取日</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-获得特定日期"><a href="#3-获得特定日期" class="headerlink" title="3. 获得特定日期"></a>3. 获得特定日期</h4><p>通过 LocalDate.of() 创建任意日期，该方法需要传入年、月、日做参数，返回对应的 LocalDate实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">void</span> <span class="hljs-title">handleSpecialDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate dateOfBirth = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 创建特定日期</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-计算某时间段前-后的日期"><a href="#4-计算某时间段前-后的日期" class="headerlink" title="4. 计算某时间段前/后的日期"></a>4. 计算某时间段前/后的日期</h4><p>LocalDate日期不包含时间信息，它的 plus() 方法用来增加天、周、月、十年、世纪，ChronoUnit类声明了这些时间单位。minus() 方法同上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plusDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate currentDate = LocalDate.now();<br>    System.out.println(<span class="hljs-string">&quot;今天的日期是:&quot;</span> + currentDate);<br><br>    LocalDate afterDayDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.DAYS);<br>    System.out.println(<span class="hljs-string">&quot;一天以后的日期是:&quot;</span> + afterDayDate);<br><br>    LocalDate afterWeekDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.WEEKS);<br>    System.out.println(<span class="hljs-string">&quot;一个星期后的日期是:&quot;</span> + afterWeekDate);<br><br>    LocalDate afterMonthDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.MONTHS);<br>    System.out.println(<span class="hljs-string">&quot;一个月以后的日期是：&quot;</span> + afterMonthDate);<br><br>    LocalDate afterDecadeDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.DECADES);<br>    System.out.println(<span class="hljs-string">&quot;十年以后的日期是：&quot;</span> + afterDecadeDate);<br><br>    LocalDate afterCenturyDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.CENTURIES);<br>    System.out.println(<span class="hljs-string">&quot;一个世纪以后的日期是：&quot;</span> + afterCenturyDate);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-判断日期是早于还是晚于另一个日期"><a href="#5-判断日期是早于还是晚于另一个日期" class="headerlink" title="5. 判断日期是早于还是晚于另一个日期"></a>5. 判断日期是早于还是晚于另一个日期</h4><p>LocalDate 类有两类方法 isBefore() 和 isAfter() 用于比较日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compareDate</span><span class="hljs-params">()</span></span>&#123;<br>       LocalDate currentDate = LocalDate.now();<br>       LocalDate anotherDate = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span> ,<span class="hljs-number">1</span>);<br><br>       <span class="hljs-comment">// isBefore()</span><br>       <span class="hljs-keyword">if</span>(currentDate.isBefore(anotherDate))&#123;<br>           System.out.println(currentDate + <span class="hljs-string">&quot;更早&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-comment">// isAfter()</span><br>       <span class="hljs-keyword">if</span>(currentDate.isAfter(anotherDate))&#123;<br>           System.out.println(currentDate + <span class="hljs-string">&quot;更晚&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="6-判断两个日期是否相等"><a href="#6-判断两个日期是否相等" class="headerlink" title="6. 判断两个日期是否相等"></a>6. 判断两个日期是否相等</h4><p>LocalDate 重载了 equal 方法。如果比较的是日期是字符型，需要先解析成日期对象再做判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">equalDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate currentDate = LocalDate.now();<br>    LocalDate anotherDate = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(currentDate.equals(anotherDate))&#123;<br>        System.out.println(<span class="hljs-string">&quot;两个日期是相等的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-判断闰年"><a href="#7-判断闰年" class="headerlink" title="7. 判断闰年"></a>7. 判断闰年</h4><p>LocalDate类有一个很实用的方法 isLeapYear() 判断该实例是否是一个闰年。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">judgeLeapYear</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate today = LocalDate.now();<br>    <span class="hljs-keyword">if</span>(today.isLeapYear())&#123;<br>        System.out.println(<span class="hljs-string">&quot;是闰年&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不是闰年&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-计算两个日期之间的天数和月数"><a href="#8-计算两个日期之间的天数和月数" class="headerlink" title="8. 计算两个日期之间的天数和月数"></a>8. 计算两个日期之间的天数和月数</h4><p>有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java 8中可以用java.time.Period类来做计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculateDate</span><span class="hljs-params">()</span></span>&#123;<br>        LocalDate date1 = LocalDate.of(<span class="hljs-number">2021</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>);<br>        LocalDate date2 = LocalDate.of(<span class="hljs-number">2020</span>, <span class="hljs-number">2</span>, <span class="hljs-number">21</span>);<br>        LocalDate java8Release = LocalDate.of(<span class="hljs-number">2018</span>, Month.MAY, <span class="hljs-number">14</span>);<br><br>        Period periodBetweenD1AndD2 = Period.between(date1,date2);   <span class="hljs-comment">// 格式是 xxxY-xxxM-xxxD</span><br>        System.out.println(periodBetweenD1AndD2);<br><br>        <span class="hljs-keyword">int</span> periodYear = periodBetweenD1AndD2.getYears();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodYear + <span class="hljs-string">&quot;年&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> periodMonth = periodBetweenD1AndD2.getMonths();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodMonth + <span class="hljs-string">&quot;个月&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> periodDay = periodBetweenD1AndD2.getDays();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodDay + <span class="hljs-string">&quot;天&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="9-在现有的时间上增加小时"><a href="#9-在现有的时间上增加小时" class="headerlink" title="9. 在现有的时间上增加小时"></a>9. 在现有的时间上增加小时</h4><p>Java 8 提供了更好的 plusHours() 方法替换 add() ，并且是兼容的。注意，这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plusHours</span><span class="hljs-params">()</span></span>&#123;<br>    LocalTime time = LocalTime.now();<br>    LocalTime newTime = time.plusHours(<span class="hljs-number">2</span>); <span class="hljs-comment">// 增加两小时</span><br>    System.out.println(<span class="hljs-string">&quot;两个小时后的时间是 : &quot;</span> +  newTime);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-处理时区-amp-时差"><a href="#10-处理时区-amp-时差" class="headerlink" title="10. 处理时区&amp;时差"></a>10. 处理时区&amp;时差</h4><h5 id="10-1-ZoneId-amp-ZoneDateTime"><a href="#10-1-ZoneId-amp-ZoneDateTime" class="headerlink" title="10.1. ZoneId &amp; ZoneDateTime"></a>10.1. ZoneId &amp; ZoneDateTime</h5><ul><li>Zoneld 来处理特定时区</li><li>ZoneDateTime 类来表示某时区下的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getZoneTime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//设置时区</span><br>    ZoneId america = ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>);<br><br>    LocalDateTime localtDateAndTime = LocalDateTime.now();<br><br>  <br>    ZonedDateTime dateAndTimeInNewYork  = ZonedDateTime.of(localtDateAndTime, america );<br>  <br>    System.out.println(<span class="hljs-string">&quot;现在的日期和时间在特定的时区 : &quot;</span> + dateAndTimeInNewYork);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="10-2-ZoneOffset"><a href="#10-2-ZoneOffset" class="headerlink" title="10.2. ZoneOffset"></a>10.2. ZoneOffset</h5><p>ZoneOffset 类用来表示时区，举例来说印度与 GMT 或 UTC 标准时区相差 +05:30，可以通过 ZoneOffset.of() 静态方法来 获取对应的时区。一旦得到了时差就可以通过传入 LocalDateTime 和 ZoneOffset 来创建一个 OffSetDateTime 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ZoneOffset</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDateTime datetime = LocalDateTime.of(<span class="hljs-number">2018</span>, Month.FEBRUARY, <span class="hljs-number">14</span>, <span class="hljs-number">19</span>, <span class="hljs-number">30</span>);<br>    ZoneOffset offset = ZoneOffset.of(<span class="hljs-string">&quot;+05:30&quot;</span>);<br>    OffsetDateTime date = OffsetDateTime.of(datetime, offset);<br>    System.out.println(<span class="hljs-string">&quot;Date and Time with timezone offset in Java : &quot;</span> + date);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-时间戳"><a href="#11-时间戳" class="headerlink" title="11. 时间戳"></a>11. 时间戳</h4><h5 id="11-1-Clock"><a href="#11-1-Clock" class="headerlink" title="11.1. Clock"></a>11.1. Clock</h5><p>Clock 时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis() 和 TimeZone.getDefault() 的地方都可用Clock替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clock</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 根据系统时间返回当前时间并设置为UTC。</span><br>    Clock clock = Clock.systemUTC();<br>    System.out.println(<span class="hljs-string">&quot;Clock : &quot;</span> + clock);<br><br>    <span class="hljs-comment">// 根据系统时钟区域返回时间</span><br>    Clock defaultClock = Clock.systemDefaultZone();<br>    System.out.println(<span class="hljs-string">&quot;Clock : &quot;</span> + clock);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="11-2-Instant"><a href="#11-2-Instant" class="headerlink" title="11.2. Instant"></a>11.2. Instant</h5><p>Instant类有一个静态工厂方法now()会返回当前的时间戳，如下所示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTimestamp</span><span class="hljs-params">()</span></span>&#123;<br>    Instant timestamp = Instant.now();<br>    System.out.println(timestamp);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-格式转换"><a href="#12-格式转换" class="headerlink" title="12. 格式转换"></a>12. 格式转换</h4><h5 id="12-1-DateTimeFormatter"><a href="#12-1-DateTimeFormatter" class="headerlink" title="12.1. DateTimeFormatter"></a>12.1. DateTimeFormatter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime rightNow=LocalDateTime.now();<br>String date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);<br>System.out.println(date);<br><br>DateTimeFormatter formatter=DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(formatter.format(rightNow));<br></code></pre></td></tr></table></figure><h4 id="13-固定日期"><a href="#13-固定日期" class="headerlink" title="13. 固定日期"></a>13. 固定日期</h4><p>YearMonth 用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到当月共有多少天，YearMonth 实例的 lengthOfMonth() 方法可以返回当月的天数，在判断 2 月有 28 天还是 29 天时非常有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkCardExpiry</span><span class="hljs-params">()</span></span>&#123;<br>      YearMonth currentYearMonth = YearMonth.now();<br>      System.out.printf(<span class="hljs-string">&quot;%s: 当月有 %d 天%n&quot;</span>, currentYearMonth, currentYearMonth.lengthOfMonth());<br><br>      YearMonth creditCardExpiry = YearMonth.of(<span class="hljs-number">2028</span>, Month.FEBRUARY);<br>      System.out.printf(<span class="hljs-string">&quot;你的信用卡将在 %s 过期&quot;</span>, creditCardExpiry);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="14-每年都会发生的周期性事件"><a href="#14-每年都会发生的周期性事件" class="headerlink" title="14. 每年都会发生的周期性事件"></a>14. 每年都会发生的周期性事件</h4><p>MonthDay 这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cycleDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate today = LocalDate.now();<br>    LocalDate dateOfBirth = LocalDate.of(<span class="hljs-number">2018</span>, <span class="hljs-number">01</span>, <span class="hljs-number">21</span>);<br><br>    MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());<br>    MonthDay currentMonthDay = MonthDay.from(today);<br><br>    <span class="hljs-keyword">if</span>(currentMonthDay.equals(birthday))&#123;<br>       System.out.println(<span class="hljs-string">&quot;Many Many happy returns of the day !!&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Sorry, today is not your birthday&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日期处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
