<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Number 类 &amp; Math 类</title>
    <link href="/2021/06/06/Number%20&amp;%20Math/"/>
    <url>/2021/06/06/Number%20&amp;%20Math/</url>
    
    <content type="html"><![CDATA[<p>Number 类是 java.lang 包下的一个抽象类，提供了将包装类型拆箱成基本类型的方法，所有基本类型（数据类型）的包装类型都继承了该抽象类，并且是 final 声明不可继承改变。</p><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法</p><span id="more"></span><h4 id="1-Number-类"><a href="#1-Number-类" class="headerlink" title="1. Number 类"></a>1. Number 类</h4><p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p><img src="https://i.loli.net/2021/06/06/GXh94qejMatDkO7.png" alt="number类.png" style="zoom:50%;" /><h5 id="1-1-装箱-amp-拆箱"><a href="#1-1-装箱-amp-拆箱" class="headerlink" title="1.1 装箱 &amp; 拆箱"></a>1.1 装箱 &amp; 拆箱</h5><p>这种由编译器特别支持的包装称为装箱，所以当基本数据类型被当作对象使用的时候，编译器会把它们装箱为包装类。</p><p>相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Integer x = <span class="hljs-number">5</span>;            <span class="hljs-comment">// 当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。</span><br>      x =  x + <span class="hljs-number">10</span>;              <span class="hljs-comment">// 然后，为了使x能进行加运算，所以要对x进行拆箱。</span><br>      System.out.println(x); <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-常用的方法"><a href="#1-2-常用的方法" class="headerlink" title="1.2 常用的方法"></a>1.2 常用的方法</h5><ul><li><p>xxxValue()<br>将 Number 对象转换为xxx数据类型的值并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Number n = <span class="hljs-number">1</span>;<br>n.doubleValue();     <span class="hljs-comment">// 转化为 double 类型。</span><br>n.byteValue();<span class="hljs-comment">// 转化为 byte 类型。</span><br>n.floatValue();<span class="hljs-comment">// 转化为 float 类型。</span><br>n.longValue();<span class="hljs-comment">// 转化为 long 类型。</span><br>n.shortValue();<span class="hljs-comment">// 转化为 short 类型。</span><br>n.intValue();<span class="hljs-comment">// 转化为 int 类型。</span><br></code></pre></td></tr></table></figure></li><li><p>valueOf()</p><p>用于返回给定参数的原生 Number 对象值，参数可以是基本数据类型，String等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x =Integer.valueOf(<span class="hljs-number">9</span>);<br>Double c = Double.valueOf(<span class="hljs-number">5.0</span>);<br>Float a = Float.valueOf(<span class="hljs-string">&quot;80&quot;</span>);              <br>Integer b = Integer.valueOf(<span class="hljs-string">&quot;444&quot;</span>,<span class="hljs-number">16</span>);   <span class="hljs-comment">// 使用 16 进制</span><br><br>System.out.println(x);<br>System.out.println(c);<br>System.out.println(a);<br>System.out.println(b);<br></code></pre></td></tr></table></figure></li><li><p>compareTo()</p><p>用于将 Number 对象与方法的参数进行比较。参数可以是 Byte, Double, Integer, Float, Long 或 Short 类型。</p><p>该方法==<strong>用于两个相同数据类型的比较</strong>==，两个不同类型的数据不能用此方法来比较。</p><ul><li>如果指定的数与参数相等返回 0。</li><li>如果指定的数小于参数返回 -1。</li><li>如果指定的数大于参数返回 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>System.out.println(x.compareTo(<span class="hljs-number">3</span>));    <span class="hljs-comment">// 结果为 1</span><br>System.out.println(x.compareTo(<span class="hljs-number">5</span>));    <span class="hljs-comment">// 结果为 0</span><br>System.out.println(x.compareTo(<span class="hljs-number">8</span>));    <span class="hljs-comment">// 结果为 -1</span><br></code></pre></td></tr></table></figure></li><li><p>equals()</p><p>判断 Number 对象是否与参数相等。</p><p>如 Number 对象不为 Null，且与方法的==<strong>参数类型与数值都相等</strong>==返回 True，否则返回 False。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>Double y = <span class="hljs-number">5.0</span>;<br>Long z = <span class="hljs-number">5</span>;<br>Short a = <span class="hljs-number">5</span>;<br>Float b = <span class="hljs-number">5.0</span>;<br>Byte c = <span class="hljs-number">5</span>; <br><br>System.out.println(x.equals(y));  <span class="hljs-comment">// false</span><br>System.out.println(x.equals(z));  <span class="hljs-comment">// false</span><br>System.out.println(x.equals(a));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p>toString(）</p><p>返回以一个字符串表示的 Number 对象值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>System.out.println(x.toString());<br>System.out.println(Integer.toString(<span class="hljs-number">12</span>));<br>System.out.println(Integer.toString(<span class="hljs-number">12</span>, <span class="hljs-number">16</span>)); <span class="hljs-comment">// 用 16 进制 </span><br></code></pre></td></tr></table></figure></li><li><p>parseXXX() </p><p>用于将字符串参数作为有符号的十进制（默认）XXX类型进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x =Integer.parseInt(<span class="hljs-string">&quot;9&quot;</span>);<br><span class="hljs-keyword">double</span> c = Double.parseDouble(<span class="hljs-string">&quot;5&quot;</span>);<br><span class="hljs-keyword">int</span> b = Integer.parseInt(<span class="hljs-string">&quot;444&quot;</span>,<span class="hljs-number">16</span>);   <span class="hljs-comment">// 用 16 进制 </span><br><br>System.out.println(x);<br>System.out.println(c);<br>System.out.println(b);<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Math-类"><a href="#2-Math-类" class="headerlink" title="2. Math 类"></a>2. Math 类</h4><p>Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p><h5 id="1-1-常用方法"><a href="#1-1-常用方法" class="headerlink" title="1.1 常用方法"></a>1.1 常用方法</h5><ul><li><p>abs() </p><p>返回参数的绝对值。参数可以是 int, float, long, double, short, byte类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = -<span class="hljs-number">80</span>;<br><span class="hljs-keyword">float</span> b = -<span class="hljs-number">90.0f</span>;<br><span class="hljs-keyword">double</span> c = -<span class="hljs-number">100</span>;<br><br>System.out.println(Math.abs(a));  <span class="hljs-comment">// 结果为 80</span><br>System.out.println(Math.abs(b));  <span class="hljs-comment">// 结果为 90.0</span><br>System.out.println(Math.abs(c));  <span class="hljs-comment">// 结果为 100.0</span><br></code></pre></td></tr></table></figure></li><li><p>ceil() </p><p>返回大于等于( &gt;= )给定参数的的最小整数，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.ceil(d));  <span class="hljs-comment">// 结果为 4.0</span><br>System.out.println(Math.ceil(f));  <span class="hljs-comment">// 结果为 -2.0</span><br></code></pre></td></tr></table></figure></li><li><p>floor()</p><p>返回大于等于( &lt;= )给定参数的的最小整数，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.floor(d));  <span class="hljs-comment">// 结果为 3.0</span><br>System.out.println(Math.floor(f));  <span class="hljs-comment">// 结果为 -3.0</span><br></code></pre></td></tr></table></figure></li><li><p>rint() </p><p>返回最接近参数的整数值，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.rint(d));  <span class="hljs-comment">// 结果为 3.0</span><br>System.out.println(Math.rint(f));  <span class="hljs-comment">// 结果为 -2.0</span><br></code></pre></td></tr></table></figure></li><li><p>round() </p><p>返回一个最接近的 int、long 型值，四舍五入。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> a = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">double</span> b = <span class="hljs-number">3.5</span>;<br><span class="hljs-keyword">float</span> c = <span class="hljs-number">4.1f</span>;<br><span class="hljs-keyword">float</span> d = <span class="hljs-number">4.6f</span>;<br><br>System.out.println(Math.round(a)); <span class="hljs-comment">// 结果为 3</span><br>System.out.println(Math.round(b)); <span class="hljs-comment">// 结果为 4</span><br>System.out.println(Math.round(c)); <span class="hljs-comment">// 结果为 4</span><br>System.out.println(Math.round(d)); <span class="hljs-comment">// 结果为 5</span><br></code></pre></td></tr></table></figure></li><li><p>max() &amp; min()</p><p>max() 方法用于返回两个参数中的最大值。</p><p>min() 方法用于返回两个参数中的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Math.max(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>));  <span class="hljs-comment">// 结果为 13   </span><br>System.out.println(Math.min(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>));  <span class="hljs-comment">// 结果为 24</span><br></code></pre></td></tr></table></figure></li><li><p>次方运算</p><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">exp()</td><td align="center">返回自然数底数e的参数次方。</td></tr><tr><td align="center">log()</td><td align="center">返回参数的自然数底数的对数值。</td></tr><tr><td align="center">sqrt()</td><td align="center">返回参数的算术平方根。</td></tr><tr><td align="center">pow()</td><td align="center">返回第一个参数的第二个参数次方。</td></tr></tbody></table></li><li><p>三角函数</p><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">sin()</td><td align="center">返回指定 double 类型参数的正弦值。</td></tr><tr><td align="center">cos()</td><td align="center">返回指定 double 类型参数的余弦值。</td></tr><tr><td align="center">tan()</td><td align="center">返回指定 double 类型参数的正切值。</td></tr><tr><td align="center">asin()</td><td align="center">返回指定 double 类型参数的反正弦值。</td></tr><tr><td align="center">acos()</td><td align="center">返回指定 double 类型参数的反余弦值。</td></tr><tr><td align="center">atan()</td><td align="center">返回指定 double 类型参数的反正切值。</td></tr><tr><td align="center">atan2()</td><td align="center">用于将矩形坐标 (x, y) 转换成极坐标 (r, theta)，返回所得角 theta。</td></tr><tr><td align="center">toDegrees()</td><td align="center">将参数转化为角度。</td></tr><tr><td align="center">toRadians()</td><td align="center">将角度转换为弧度。</td></tr><tr><td align="center">random()</td><td align="center">返回一个随机数，随机数范围为 0.0 =&lt; Math.random &lt; 1.0。</td></tr></tbody></table></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/06/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2021/06/06/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-访问控制修饰符"><a href="#1-访问控制修饰符" class="headerlink" title="1. 访问控制修饰符"></a>1. 访问控制修饰符</h4><p>Java中，可以使用访问控制符来<strong>保护对类、变量、方法和构造方法的访问</strong>。</p><ul><li><p><strong>default（默认访问修饰符）：</strong></p><p>使用 default 的变量和方法，==<strong>对同一个包内的类是可见的</strong>==。</p><p>接口里的变量都隐式声明为 <strong>public static final</strong>，而接口里的方法默认情况下访问权限为 <strong>public</strong>。</p><p>使用对象：类、接口、变量、方法。</p></li><li><p><strong>public（公有访问修饰符）：</strong></p><p>被声明为 public 的类、方法、构造方法和接口==<strong>能够被任何其他类访问</strong>==。</p><p>使用对象：类、接口、变量、方法。</p></li><li><p><strong>private（私有访问修饰符）：</strong></p><p>被声明为 private 的方法、变量和构造方法==<strong>只能被所属类访问</strong>==。</p><p>使用对象：变量、方法，不能修饰类（外部类）。</p></li><li><p><strong>protected（受保护的访问修饰符）：</strong></p><ul><li>子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected 方法。 </li></ul><p>使用对象：变量、方法，不能修饰类（外部类）。</p></li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(同一包)</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y/N</td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left">Y</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><h4 id="2-非访问控制修饰符"><a href="#2-非访问控制修饰符" class="headerlink" title="2. 非访问控制修饰符"></a>2. 非访问控制修饰符</h4><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><ul><li><p><strong>static：</strong></p><ul><li><p>static 变量：</p><p>static 关键字用来声明独立于对象的静态变量，==<strong>无论一个类实例化多少对象，它的静态变量只有一份拷贝</strong>==。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p>static 方法：</p><p>static 关键字用来声明独立于对象的静态方法，即可以使用 类名.方法名 的方式进行调用。==<strong>静态方法不能使用类的非静态变量</strong>==。静态方法从参数列表得到数据，然后计算这些数据。</p></li></ul></li><li><p><strong>final：</strong></p><ul><li><p>final 变量：</p><p>final 表示“最后的、最终的含义”，变量==<strong>一旦赋值后，不能被重新赋值</strong>==。被 final 修饰的实例变量==<strong>必须显式指定初始值</strong>==。final 修饰符通常和 static 修饰符一起使用来创建类常量。</p></li><li><p>final 方法：</p><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是==<strong>防止该方法的内容被修改</strong>==。</p></li></ul></li><li><p><strong>abstract：</strong></p><ul><li><p>abstract 类：</p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了==<strong>将来对该类进行扩充</strong>==。</p><p>一个类不能同时被 abstract 和 final 修饰。</p><p>==<strong>如果一个类包含抽象方法，那么该类一定要声明为抽象类</strong>==，否则将出现编译错误。</p><p>==<strong>抽象类可以包含抽象方法和非抽象方法</strong>==。</p></li><li><p>abstract 方法：</p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p>==<strong>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</strong>==</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p>==<strong>抽象方法的声明以分号结尾。</strong>==</p></li></ul></li><li><p><strong>synchronized：</strong></p><ul><li>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</li></ul></li><li><p><strong>transient：</strong></p><ul><li><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p></li><li><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p></li></ul></li><li><p><strong>volatile：</strong></p><ul><li>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</li><li>一个 volatile 对象引用可能是 null。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/06/%E7%B1%BB/"/>
    <url>/2021/06/06/%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h4><ul><li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li><li><strong>对象</strong>：对象是类的一个实例，有状态和行为。</li></ul><h4 id="2-类中的变量类型"><a href="#2-类中的变量类型" class="headerlink" title="2.  类中的变量类型"></a>2.  类中的变量类型</h4><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，==<strong>方法结束后，变量就会自动销毁</strong>==。</li><li><strong>成员变量（属性、实例变量）</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量（静态变量）</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-comment">// 属性、实例变量</span><br>  String name;<br>  <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">// 类变量 （即加了 static 的属性）</span><br>  <span class="hljs-keyword">static</span> String schoolName;<br>  <br>  <span class="hljs-comment">// 方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(String book)</span></span>&#123;<br>    <span class="hljs-comment">// book 就是局部变量</span><br>    System.out.println(<span class="hljs-string">&quot;name:&quot;</span> + name + <span class="hljs-string">&quot;在学习&quot;</span> + book);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h4><p>方法定义在类中，属于类的成员，所以也可以叫做成员方法。</p><h5 id="3-1-方法定义的格式"><a href="#3-1-方法定义的格式" class="headerlink" title="3.1 方法定义的格式"></a>3.1 方法定义的格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li><li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li></ul><h5 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h5><p>当一个对象被创建时候，构造方法用来初始化该对象。==<strong>构造方法和它所在类的名字相同，但构造方法没有返回值。</strong>==</p><p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p><p>不管你是否自定义构造方法，==<strong>所有的类都有构造方法</strong>==，因为 ==<strong>Java 自动提供了一个默认构造方法</strong>==，默认构造方法的访问修饰符和类的访问修饰符相同。</p><p>==<strong>一旦你定义了自己的构造方法，默认构造方法就会失效。</strong>==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个简单的构造函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br> <br>  <span class="hljs-comment">// 以下是构造函数</span><br>  MyClass() &#123;<br>    x = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-参数传递"><a href="#4-参数传递" class="headerlink" title="4. 参数传递"></a>4. 参数传递</h4><h5 id="4-1-参数类型"><a href="#4-1-参数类型" class="headerlink" title="4.1 参数类型"></a>4.1 参数类型</h5><p>java方法的参数，分为形参和实参。 </p><ul><li><p>形参：形式上的参数，作用是接收外部传过来的实际参数的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;...&#125;<br><span class="hljs-comment">// a 就是一个形参。</span><br></code></pre></td></tr></table></figure></li><li><p>实参：调用方法时实际上传递的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      t.test(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// x 就是一个实参。</span><br>      t.test(x);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="4-2-值传递"><a href="#4-2-值传递" class="headerlink" title="4.2 值传递"></a>4.2 值传递</h5><p>==<strong>方法的参数是基本类型</strong>==，调用方法并传参，这时候进行的是值传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">//该方法中，改变参数当前的值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    a = <span class="hljs-number">10</span>;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    System.out.println(<span class="hljs-string">&quot;before: a = &quot;</span> + a);<span class="hljs-comment">//传参之前，变量a的值，结果为 1。</span><br>    changeNum(a);<br>    System.out.println(<span class="hljs-string">&quot;after: a = &quot;</span> + a);<span class="hljs-comment">//传参之后，变量a的值，结果仍然为 1。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>值传递，实参把自己存储的值（基本类型都是简单的数字）赋值给形参，之后形参如何操作，对实参一点影响没有。</strong></p><h5 id="4-3-引用传递"><a href="#4-3-引用传递" class="headerlink" title="4.3 引用传递"></a>4.3 引用传递</h5><p>==<strong>方法的参数是引用类型</strong>==，调用方法并传参，这时候进行的是引用传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  String name;<br>  String age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">// 该方法中，改变引用s所指向对象的name属性值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeName</span><span class="hljs-params">(Student s)</span></span>&#123;<br>  s.name = <span class="hljs-string">&quot;tom&quot;</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    s.name = <span class="hljs-string">&quot;seal&quot;</span><br>    System.out.println(<span class="hljs-string">&quot;before: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之前，引用s所指向对象的name属性值，结果为 seal。</span><br>    changeName(s);<br>    System.out.println(<span class="hljs-string">&quot;after: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之后，引用s所指向对象的name属性值，结果为 tom。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">// 该方法中，改变引用s所指向对象的name属性值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeName</span><span class="hljs-params">(Student s)</span></span>&#123;<br>  s = <span class="hljs-keyword">new</span> Student();<br>    s.name = tom;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    s.name = <span class="hljs-string">&quot;seal&quot;</span><br>    System.out.println(<span class="hljs-string">&quot;before: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之前，引用s所指向对象的name属性值，结果为 seal。</span><br>    changeName(s);<br>    System.out.println(<span class="hljs-string">&quot;after: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之后，引用s所指向对象的name属性值，结果为 seal。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于引用传递，是实参将自己存储的对象地址，赋值给了形参，这时候俩个引用（实参和形参）指 向了同一个对象，那么任何一个引用（实参或形参）操作对象，例如属性赋值，那么另一个引用 （形参或实参）都可以看到这个对象中属性的变量，因为俩个引用指向同一个对象。</p><h4 id="5-this-关键字"><a href="#5-this-关键字" class="headerlink" title="5. this 关键字"></a>5. this 关键字</h4><p>在类中的非静态方法中，可以使用this关键，来表示当前类将来的一个对象。</p><h5 id="5-1-使用场景"><a href="#5-1-使用场景" class="headerlink" title="5.1 使用场景"></a>5.1 使用场景</h5><ul><li>区别成员变量和局部变量</li><li>调用类中的其他方法 </li><li>调用类中的其他构造器</li></ul><h5 id="5-2-区别成员变量和局部变量"><a href="#5-2-区别成员变量和局部变量" class="headerlink" title="5.2 区别成员变量和局部变量"></a>5.2 区别成员变量和局部变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-comment">//=号左边的this.name，表示类中的属性name</span><br>    <span class="hljs-comment">//=号右边的name，表示当前方法的参数name（就近原则）</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-3-调用类中的其它方法"><a href="#5-3-调用类中的其它方法" class="headerlink" title="5.3 调用类中的其它方法"></a>5.3 调用类中的其它方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//表示调用当前类中的setName方法</span><br>    <span class="hljs-comment">// 默认情况下，setName(&quot;tom&quot;) 和 this.setName(&quot;tom&quot;) 的效果是一样的，所以这里也可以省去 this.</span><br>      <span class="hljs-keyword">this</span>.setName(<span class="hljs-string">&quot;tom&quot;</span>);   <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-4-调用类中的其他构造器"><a href="#5-4-调用类中的其他构造器" class="headerlink" title="5.4 调用类中的其他构造器"></a>5.4 调用类中的其他构造器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//调用一个参数的构造器,参数的类型是String</span><br>    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>this 的这种调用构造器的用法，==<strong>只能在类中的一个构造器，调用另一个构造器</strong>==。并且不能在普通的方法中调用类的构造器。 并且要求，==<strong>this调用构造器的代码，是当前构造器中的第一句代码</strong>==，否则编译报错。</p><h5 id="5-5-思考题"><a href="#5-5-思考题" class="headerlink" title="5.5 思考题"></a>5.5 思考题</h5><p>如果这时候创建俩个对象，那么this又代表哪一个对象呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.show(); <span class="hljs-comment">//问题：这个this代表的是stu1还是stu2</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Student stu1 = <span class="hljs-keyword">new</span> Student();<br>        stu1.sayHello();<br>        Student stu2 = <span class="hljs-keyword">new</span> Student();<br>        stu2.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="D:\Users\MaxSeal\Desktop\杰普实训\corejava\上课笔记\图片\this思考题.png" style="zoom:80%;" /><p>其实每一个对象中，都有自己的this，和其他对象中的互不影响。</p><p>==<strong>方法被哪个对象调用，方法中的this就代表那个对象。</strong>==即谁在调用，this就代表谁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/06/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h4><ul><li><p>OOP（object oriented programming），面向对象编程把构成问题的各种事物，抽象成各个对象，这些对象具有解决问题的行为（方法），同时对象还可以具有解决很多类似问题的行为（方法），而不只是能解决一个问题。</p></li><li><p>POP（procedure oriented Programming），面向过程编程分析出，解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，然后依次调用就可以了。</p></li><li><p>FP（functional programming)，函数式编程类似于面向过程的程序设计方式，具有很高的抽象程度。JDK8中的一些特性，可以支持使用函数式编程。</p><p>面向对象的特点：**==封装==、==继承==<strong>和</strong>==多态==**。     </p></li></ul><p>​       面向对象思想，是一种程序设计思想，使用这种思想进行编程的语言，就是面向对象编程语言。面向对象中的对象，泛指现实中一切事物，每种事物都具备自己的**==属性==和==行为==<strong>。面向对象思想就是在计算机程序设计过程中，参照现实中事物，</strong>==将事物的属性特征、行为特征抽象出来，定义为程序中的一种数据类型==<strong>。 面向对象的思想，主要强调的是</strong>==通过调用对象的行为来实现功能==**，而不是自己一步一步的去操作实现。</p><h4 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h4><p>​       封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装可以被认为是一个保护屏障，**==防止该类的代码和数据被外部类定义的代码随机访问==**。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于==<strong>我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段</strong>==。适当的封装可以==<strong>让程式码更容易理解与维护，也加强了程式码的安全</strong>==。</p><h5 id="2-1-封装的优点："><a href="#2-1-封装的优点：" class="headerlink" title="2.1 封装的优点："></a>2.1 封装的优点：</h5><ul><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量可以自由修改。</p></li><li><p>隐藏信息，实现细节。</p></li></ul><h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h4><p>​        继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承就是==<strong>子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法</strong>==，或==<strong>子类从父类继承方法，使得子类具有父类相同的行为</strong>==。</p><h5 id="3-1-继承的类型"><a href="#3-1-继承的类型" class="headerlink" title="3.1 继承的类型"></a>3.1 继承的类型</h5><p>![](D:\Users\MaxSeal\Desktop\杰普实训\corejava\上课笔记\图片\7. 对象和类\继承的类型.png)</p><h5 id="3-2-继承的特性"><a href="#3-2-继承的特性" class="headerlink" title="3.2 继承的特性"></a>3.2 继承的特性</h5><ul><li>子类拥有父类非 private 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li>Java 的继承是单继承，但是可以多重继承，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul><h4 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h4><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><h5 id="4-1-多态的优点"><a href="#4-1-多态的优点" class="headerlink" title="4.1 多态的优点"></a>4.1 多态的优点</h5><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><h5 id="4-2-多态存在的三个必要条件"><a href="#4-2-多态存在的三个必要条件" class="headerlink" title="4.2 多态存在的三个必要条件"></a>4.2 多态存在的三个必要条件</h5><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Circle.draw()&quot;</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Square.draw()&quot;</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Triangle.draw()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-多态的实现方式"><a href="#4-3-多态的实现方式" class="headerlink" title="4.3 多态的实现方式"></a>4.3 多态的实现方式</h5><ul><li><p>重写</p></li><li><p>接口</p></li><li><p>抽象类</p></li></ul><h4 id="5-重写"><a href="#5-重写" class="headerlink" title="5. 重写"></a>5. 重写</h4><p>方法重写是在==子类存在方法与父类的方法的名字相同==，而且==参数的个数与类型一样==，==返回值也一样==的方法，就称为重写。</p><p><strong>重写规则：</strong></p><ul><li>参数列表与被重写方法的<strong>参数列表必须完全相同</strong>。</li><li>返回类型与被重写方法的<strong>返回类型可以不相同，但是必须是父类返回值的派生类</strong>。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。</li><li>如果不能继承一个类，则不能重写该类的方法。</li><li>父类的方法只能被它的子类重写。</li><li>构造方法不能被重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li></ul><h4 id="6-重载"><a href="#6-重载" class="headerlink" title="6. 重载"></a>6. 重载</h4><p>方法重载是一个类中定义了==多个方法名相同==，而他们的==参数的数量不同==或==数量相同而类型和次序不同==，则称为方法的重载。</p><p><strong>重载规则：</strong></p><ul><li><p>被重载的方法==必须改变参数列表==(参数个数或类型不一样)；</p></li><li><p>被重载的方法==可以改变返回类型==；</p></li><li><p>被重载的方法==可以改变访问修饰符==；</p></li><li><p>被重载的方法==可以声明新的或更广的检查异常==；</p></li><li><p>方法能够在同一个类中或者在一个子类中被重载。</p></li><li><p><strong>无法以返回值类型作为重载函数的区分标准</strong>。</p></li></ul><h4 id="7-重写与重载的区别"><a href="#7-重写与重载的区别" class="headerlink" title="7. 重写与重载的区别"></a>7. 重写与重载的区别</h4><p><strong>方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。</strong></p><table><thead><tr><th align="left">区别点</th><th align="left">重载</th><th align="left">重写</th></tr></thead><tbody><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可以修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可以修改</td><td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问</td><td align="left">可以修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/06/06/%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <url>/2021/06/06/%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a><strong>关键类</strong></h4><ul><li>Instant：瞬时实例。</li><li>LocalDate：本地日期，不包含具体时间。例如：2014-01-14 可以用来记录生日、纪念日、加盟日等。</li><li>LocalTime：本地时间，不包含日期。</li><li>LocalDateTime：组合了日期和时间，但不包含时差和时区信息。</li><li>ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。</li></ul><p>新API还引入了 ZoneOffSet 和 ZoneId 类，使得解决时区问题更为简便。解析、格式化时间的 DateTimeFormatter 类也全部重新设计。</p><h4 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h4><h5 id="1-获取当前日期"><a href="#1-获取当前日期" class="headerlink" title="1. 获取当前日期"></a>1. 获取当前日期</h5><p>LocalDate 用于表示当天日期。只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCurrentDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate today = LocalDate.now();  <span class="hljs-comment">// 获取当前时间</span><br>  System.out.println(date);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-获取年月日信息"><a href="#2-获取年月日信息" class="headerlink" title="2. 获取年月日信息"></a>2. 获取年月日信息</h5><p>LocalDate 提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getDetailDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate today = LocalDate.now();   <span class="hljs-comment">// 获取当前日期</span><br>  <span class="hljs-keyword">int</span> year = today.getYear();<span class="hljs-comment">// 获取年份</span><br>  <span class="hljs-keyword">int</span> month = today.getMonthValue();  <span class="hljs-comment">// 获取月份</span><br>  <span class="hljs-keyword">int</span> day = today.getDayOfMonth();   <span class="hljs-comment">// 获取日</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-获得特定日期"><a href="#3-获得特定日期" class="headerlink" title="3. 获得特定日期"></a>3. 获得特定日期</h5><p>通过 LocalDate.of() 创建任意日期，该方法需要传入年、月、日做参数，返回对应的 LocalDate实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">void</span> <span class="hljs-title">handleSpecialDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate dateOfBirth = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 创建特定日期</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-计算某时间段前-后的日期"><a href="#4-计算某时间段前-后的日期" class="headerlink" title="4. 计算某时间段前/后的日期"></a>4. 计算某时间段前/后的日期</h5><p>LocalDate日期不包含时间信息，它的 plus() 方法用来增加天、周、月、十年、世纪，ChronoUnit类声明了这些时间单位。minus() 方法同上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plusDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate currentDate = LocalDate.now();<br>    System.out.println(<span class="hljs-string">&quot;今天的日期是:&quot;</span> + currentDate);<br><br>    LocalDate afterDayDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.DAYS);<br>    System.out.println(<span class="hljs-string">&quot;一天以后的日期是:&quot;</span> + afterDayDate);<br><br>    LocalDate afterWeekDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.WEEKS);<br>    System.out.println(<span class="hljs-string">&quot;一个星期后的日期是:&quot;</span> + afterWeekDate);<br><br>    LocalDate afterMonthDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.MONTHS);<br>    System.out.println(<span class="hljs-string">&quot;一个月以后的日期是：&quot;</span> + afterMonthDate);<br><br>    LocalDate afterDecadeDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.DECADES);<br>    System.out.println(<span class="hljs-string">&quot;十年以后的日期是：&quot;</span> + afterDecadeDate);<br><br>    LocalDate afterCenturyDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.CENTURIES);<br>    System.out.println(<span class="hljs-string">&quot;一个世纪以后的日期是：&quot;</span> + afterCenturyDate);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-判断日期是早于还是晚于另一个日期"><a href="#5-判断日期是早于还是晚于另一个日期" class="headerlink" title="5. 判断日期是早于还是晚于另一个日期"></a>5. 判断日期是早于还是晚于另一个日期</h5><p>LocalDate 类有两类方法 isBefore() 和 isAfter() 用于比较日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compareDate</span><span class="hljs-params">()</span></span>&#123;<br>       LocalDate currentDate = LocalDate.now();<br>       LocalDate anotherDate = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span> ,<span class="hljs-number">1</span>);<br><br>       <span class="hljs-comment">// isBefore()</span><br>       <span class="hljs-keyword">if</span>(currentDate.isBefore(anotherDate))&#123;<br>           System.out.println(currentDate + <span class="hljs-string">&quot;更早&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-comment">// isAfter()</span><br>       <span class="hljs-keyword">if</span>(currentDate.isAfter(anotherDate))&#123;<br>           System.out.println(currentDate + <span class="hljs-string">&quot;更晚&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="6-判断两个日期是否相等"><a href="#6-判断两个日期是否相等" class="headerlink" title="6. 判断两个日期是否相等"></a>6. 判断两个日期是否相等</h5><p>LocalDate 重载了 equal 方法。如果比较的是日期是字符型，需要先解析成日期对象再做判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">equalDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate currentDate = LocalDate.now();<br>    LocalDate anotherDate = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(currentDate.equals(anotherDate))&#123;<br>        System.out.println(<span class="hljs-string">&quot;两个日期是相等的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-判断闰年"><a href="#7-判断闰年" class="headerlink" title="7. 判断闰年"></a>7. 判断闰年</h5><p>LocalDate类有一个很实用的方法 isLeapYear() 判断该实例是否是一个闰年。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">judgeLeapYear</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate today = LocalDate.now();<br>    <span class="hljs-keyword">if</span>(today.isLeapYear())&#123;<br>        System.out.println(<span class="hljs-string">&quot;是闰年&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不是闰年&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h4><h5 id="1-计算两个日期之间的天数和月数"><a href="#1-计算两个日期之间的天数和月数" class="headerlink" title="1. 计算两个日期之间的天数和月数"></a>1. 计算两个日期之间的天数和月数</h5><p>有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java 8中可以用java.time.Period类来做计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculateDate</span><span class="hljs-params">()</span></span>&#123;<br>        LocalDate date1 = LocalDate.of(<span class="hljs-number">2021</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>);<br>        LocalDate date2 = LocalDate.of(<span class="hljs-number">2020</span>, <span class="hljs-number">2</span>, <span class="hljs-number">21</span>);<br>        LocalDate java8Release = LocalDate.of(<span class="hljs-number">2018</span>, Month.MAY, <span class="hljs-number">14</span>);<br><br>        Period periodBetweenD1AndD2 = Period.between(date1,date2);   <span class="hljs-comment">// 格式是 xxxY-xxxM-xxxD</span><br>        System.out.println(periodBetweenD1AndD2);<br><br>        <span class="hljs-keyword">int</span> periodYear = periodBetweenD1AndD2.getYears();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodYear + <span class="hljs-string">&quot;年&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> periodMonth = periodBetweenD1AndD2.getMonths();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodMonth + <span class="hljs-string">&quot;个月&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> periodDay = periodBetweenD1AndD2.getDays();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodDay + <span class="hljs-string">&quot;天&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h4><h5 id="1-在现有的时间上增加小时"><a href="#1-在现有的时间上增加小时" class="headerlink" title="1. 在现有的时间上增加小时"></a>1. 在现有的时间上增加小时</h5><p>Java 8 提供了更好的 plusHours() 方法替换 add() ，并且是兼容的。注意，这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plusHours</span><span class="hljs-params">()</span></span>&#123;<br>    LocalTime time = LocalTime.now();<br>    LocalTime newTime = time.plusHours(<span class="hljs-number">2</span>); <span class="hljs-comment">// 增加两小时</span><br>    System.out.println(<span class="hljs-string">&quot;两个小时后的时间是 : &quot;</span> +  newTime);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理时区-amp-时差"><a href="#处理时区-amp-时差" class="headerlink" title="处理时区&amp;时差"></a>处理时区&amp;时差</h4><h5 id="1-ZoneId-amp-ZoneDateTime"><a href="#1-ZoneId-amp-ZoneDateTime" class="headerlink" title="1. ZoneId &amp; ZoneDateTime"></a>1. ZoneId &amp; ZoneDateTime</h5><ul><li>Zoneld 来处理特定时区</li><li>ZoneDateTime 类来表示某时区下的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getZoneTime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//设置时区</span><br>    ZoneId america = ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>);<br><br>    LocalDateTime localtDateAndTime = LocalDateTime.now();<br><br>  <br>    ZonedDateTime dateAndTimeInNewYork  = ZonedDateTime.of(localtDateAndTime, america );<br>  <br>    System.out.println(<span class="hljs-string">&quot;现在的日期和时间在特定的时区 : &quot;</span> + dateAndTimeInNewYork);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-ZoneOffset"><a href="#2-ZoneOffset" class="headerlink" title="2. ZoneOffset"></a>2. ZoneOffset</h5><p>ZoneOffset 类用来表示时区，举例来说印度与 GMT 或 UTC 标准时区相差 +05:30，可以通过 ZoneOffset.of() 静态方法来 获取对应的时区。一旦得到了时差就可以通过传入 LocalDateTime 和 ZoneOffset 来创建一个 OffSetDateTime 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ZoneOffset</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDateTime datetime = LocalDateTime.of(<span class="hljs-number">2018</span>, Month.FEBRUARY, <span class="hljs-number">14</span>, <span class="hljs-number">19</span>, <span class="hljs-number">30</span>);<br>    ZoneOffset offset = ZoneOffset.of(<span class="hljs-string">&quot;+05:30&quot;</span>);<br>    OffsetDateTime date = OffsetDateTime.of(datetime, offset);<br>    System.out.println(<span class="hljs-string">&quot;Date and Time with timezone offset in Java : &quot;</span> + date);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><h5 id="1-Clock"><a href="#1-Clock" class="headerlink" title="1. Clock"></a>1. Clock</h5><p>Clock 时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis() 和 TimeZone.getDefault() 的地方都可用Clock替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clock</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 根据系统时间返回当前时间并设置为UTC。</span><br>    Clock clock = Clock.systemUTC();<br>    System.out.println(<span class="hljs-string">&quot;Clock : &quot;</span> + clock);<br><br>    <span class="hljs-comment">// 根据系统时钟区域返回时间</span><br>    Clock defaultClock = Clock.systemDefaultZone();<br>    System.out.println(<span class="hljs-string">&quot;Clock : &quot;</span> + clock);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-Instant"><a href="#2-Instant" class="headerlink" title="2. Instant"></a>2. Instant</h5><p>Instant类有一个静态工厂方法now()会返回当前的时间戳，如下所示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTimestamp</span><span class="hljs-params">()</span></span>&#123;<br>    Instant timestamp = Instant.now();<br>    System.out.println(timestamp);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h4><h5 id="1-DateTimeFormatter"><a href="#1-DateTimeFormatter" class="headerlink" title="1. DateTimeFormatter"></a>1. DateTimeFormatter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime rightNow=LocalDateTime.now();<br>String date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);<br>System.out.println(date);<br><br>DateTimeFormatter formatter=DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(formatter.format(rightNow));<br></code></pre></td></tr></table></figure><h4 id="YearMonth"><a href="#YearMonth" class="headerlink" title="YearMonth"></a>YearMonth</h4><p>YearMonth 用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到当月共有多少天，YearMonth 实例的 lengthOfMonth() 方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkCardExpiry</span><span class="hljs-params">()</span></span>&#123;<br>      YearMonth currentYearMonth = YearMonth.now();<br>      System.out.printf(<span class="hljs-string">&quot;%s: 当月有 %d 天%n&quot;</span>, currentYearMonth, currentYearMonth.lengthOfMonth());<br><br>      YearMonth creditCardExpiry = YearMonth.of(<span class="hljs-number">2028</span>, Month.FEBRUARY);<br>      System.out.printf(<span class="hljs-string">&quot;你的信用卡将在 %s 过期&quot;</span>, creditCardExpiry);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MonthDay"><a href="#MonthDay" class="headerlink" title="MonthDay"></a>MonthDay</h4><p>MonthDay 这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cycleDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate today = LocalDate.now();<br>    LocalDate dateOfBirth = LocalDate.of(<span class="hljs-number">2018</span>, <span class="hljs-number">01</span>, <span class="hljs-number">21</span>);<br><br>    MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());<br>    MonthDay currentMonthDay = MonthDay.from(today);<br><br>    <span class="hljs-keyword">if</span>(currentMonthDay.equals(birthday))&#123;<br>       System.out.println(<span class="hljs-string">&quot;Many Many happy returns of the day !!&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Sorry, today is not your birthday&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
