<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2021/06/18/20.%20%E8%8C%83%E5%9E%8B/"/>
    <url>/2021/06/18/20.%20%E8%8C%83%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>泛型，即“参数化类型”。顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><span id="more"></span><h2 id="1-泛型的定义"><a href="#1-泛型的定义" class="headerlink" title="1. 泛型的定义"></a>1. 泛型的定义</h2><p>泛型，即“参数化类型”。顾名思义，就是<strong>将类型由原来的具体的类型参数化</strong>，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    T x;<br>    T y;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>T 是泛型参数，表示一种数据类型，具体是什么类型，需要将来使用Point的时候进行传参来确定。</li><li>如果将来 Point 在使用的时候，没有给泛型参数 T 传值，那么 T 默认就表示为 Object 类型。</li><li>T 是泛型参数的名字，也就是相当于形参，名字随便起，但是一般用一个有意义的大写字母。</li><li>给泛型参照传的值，只能是引用类型，不能是基本类型： Point(int) 编译报错。</li></ul><h2 id="2-泛型的类型"><a href="#2-泛型的类型" class="headerlink" title="2. 泛型的类型"></a>2. 泛型的类型</h2><h3 id="2-1-泛型的种类"><a href="#2-1-泛型的种类" class="headerlink" title="2.1 泛型的种类"></a>2.1 泛型的种类</h3><p>java中的泛型分三种使用情况： 泛型类，泛型接口和泛型方法。</p><ul><li>泛型类，如果泛型参数定义在类上面，那么这个类就是一个泛型类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>Point&lt;String&gt; p = <span class="hljs-keyword">new</span> Point&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>泛型接口，如果泛型参数定义在接口上面，那么这个接口就是一个泛型接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  <span class="hljs-comment">//创建匿名内部类</span><br>  Action&lt;String&gt; a = <span class="hljs-keyword">new</span> Action&lt;&gt;()&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>泛型方法，如果泛型参数定义在方法上面，那么这个方法就是一个泛型方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>&#123;<br>  <span class="hljs-comment">//..</span><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Test t = <span class="hljs-keyword">new</span> Test();<br>    String str = t.test(<span class="hljs-string">&quot;hello&quot;</span>);<br>    Integer i = t.test(<span class="hljs-number">1</span>);<br>    Double d = t.test(<span class="hljs-number">10.5D</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>如果方法参数中有泛型 T，而方法的返回类型前没有泛型 T，该类型就不是泛型方法，而是泛型类。</p></li><li><p>泛型方法常用在工具类中（即该方法只是一种工具），与类的实例对象无关。</p></li><li><p>当泛型方法中的泛型 T 与类中的泛型 T 同名时会产生警报，因为编译器不确定你要使用哪个持有对象。</p></li></ul><h3 id="2-2-思考题1"><a href="#2-2-思考题1" class="headerlink" title="2.2 思考题1"></a>2.2 思考题1</h3><p>在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。<strong>那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> T data;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Box</span><span class="hljs-params">()</span> </span>&#123;&#125; <br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Box</span><span class="hljs-params">(T data)</span> </span>&#123;         <br>    <span class="hljs-keyword">this</span>.data = data;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Box&lt;String&gt; name = <span class="hljs-keyword">new</span> Box&lt;String&gt;(<span class="hljs-string">&quot;corn&quot;</span>);<br>        Box&lt;Integer&gt; age = <span class="hljs-keyword">new</span> Box&lt;Integer&gt;(<span class="hljs-number">712</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;name class:&quot;</span> + name.getClass());      <span class="hljs-comment">// Box</span><br>        System.out.println(<span class="hljs-string">&quot;age class:&quot;</span> + age.getClass());        <span class="hljs-comment">// Box</span><br>        System.out.println(name.getClass() == age.getClass());    <span class="hljs-comment">// true</span><br><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>在使用泛型类时，虽然传入了不同的泛型实参，但<strong>并没有真正意义上生成不同的类型</strong>，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box）。</p><h3 id="2-3-思考题2"><a href="#2-3-思考题2" class="headerlink" title="2.3 思考题2"></a>2.3 思考题2</h3><p> Integer 是 Object 的子类型，那么  ArrayList<Integer> 和 ArrayList<Object> 之间是否有子父类的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译通过，父类型的引用，指向子类对象。</span><br>Object o = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//编译通过，Object[] 类型兼容所有的【引用】类型数组。</span><br>Object[] arr = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//编译失败，类型不兼容，int[] 是基本类型数组。</span><br>Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//编译失败，错误信息：ArrayList&lt;Integer&gt;无法转为ArrayList&lt;Object&gt;</span><br><span class="hljs-comment">//在编译期间，ArrayList&lt;Integer&gt; 和 ArrayList&lt;Object&gt;是俩个不同的类型，并且没有子父类型的关系</span><br>ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>虽然 Integer 是 Object 的子类型，但是 ArrayList<Integer> 和 ArrayList<Object> 之间没有子父类型的关系，它们就是俩个不同的类型。因此，两边的 &lt;&gt; 里的类型要一致。</p><h3 id="2-4-类型擦除"><a href="#2-4-类型擦除" class="headerlink" title="2.4 类型擦除"></a>2.4 类型擦除</h3><p>泛型类型仅存在于编译期间，编译后的字节码和运行时不包含泛型信息，所有的泛型类型映射到同一份字节码。 </p><p>由于泛型是 JDK1.5 才加入到 Java 语言特性的，Java 让编译器擦除掉关于泛型类型的信息，这样使得 Java 可以向后兼容之前没有使用泛型的类库和代码，因为在字节码（class）层面是没有泛型概念的。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译报错</span><br><span class="hljs-comment">//因为在编译后，泛型信息会被擦除, 那么一个类会就存在了俩个一样的方法 public void run(List list)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(List&lt;String&gt; list)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(List&lt;Integer&gt; list)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//编译报错</span><br>    <span class="hljs-comment">//ArrayList&lt;Integer&gt; 和 ArrayList&lt;Long&gt; 在编译期间是不同的类型</span><br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Long&gt;();<br>  <br>    <span class="hljs-comment">//但是编译完成后，它们对应的是同一份 class 文件：ArrayList.class</span><br>    ArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    ArrayList&lt;Long&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;Long&gt;();<br>    System.out.println(list1.getClass() == list2.getClass()); <span class="hljs-comment">//true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>泛型信息被擦除后，所有的泛型类型都会统一变为原始类型：Object 。</li><li>Java 的泛型只存在于编译时期，泛型使编译器可以在编译期间对类型进行检查以提高类型安全，减少运行时由于对象类型不匹配引发的异常。</li></ul><h2 id="3-通配符"><a href="#3-通配符" class="headerlink" title="3. 通配符"></a>3. 通配符</h2><h3 id="3-1-通配符使用"><a href="#3-1-通配符使用" class="headerlink" title="3.1 通配符使用"></a>3.1 通配符使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(Collection&lt;Integer&gt; c)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(Collection&lt;String&gt; c)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">(Collection&lt;Object&gt; c)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>test1 方法【只能】接收泛型是 Integer 类型的集合对象 </li><li>test2 方法【只能】接收泛型是 String 类型的集合对象</li><li>test3 方法【只能】接收泛型是 Object 类型的集合对象 </li></ul><p>原因：由于泛型的类型之间没有多态。</p><p>可以使用通配符（?）来表示泛型的父类型：这时候 test 方法中的参数类型，使用了泛型，并且使用问号来表示这个泛型的类型，这个问号就是通配符，可以匹配所有的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Test t = <span class="hljs-keyword">new</span> Test();<br>    t.test(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());<br>    t.test(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());<br>    t.test(<span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;());<br>    t.test(<span class="hljs-keyword">new</span> ArrayList&lt;任意类型&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-通配符带来的问题"><a href="#3-2-通配符带来的问题" class="headerlink" title="3.2 通配符带来的问题"></a>3.2 通配符带来的问题</h3><p>使用通配符（?）的集合，不能再往其中添加数据，但是可以添加 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;?&gt; c;<br>c = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br><span class="hljs-comment">//编译报错</span><br><span class="hljs-comment">//因为变量c所声明的类型是Collection，同时泛型类型是通配符（?）</span><br><span class="hljs-comment">//那么编译器也不知道这个?将来会是什么类型，因为这个?只是一个通配符</span><br><span class="hljs-comment">//所以，编译器不允许使用变量c来向集合中添加新数据。</span><br>c.add(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-comment">//编译通过</span><br><span class="hljs-comment">//但是有一个值是可以添加到集合中的，null</span><br><span class="hljs-comment">//集合中一定存的是引用类型，null是所有引用类型共同的一个值，所以一定可以添加进去。</span><br>c.add(<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>虽然不能添加数据，但可以遍历数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello4&quot;</span>);<br>    Collection&lt;?&gt; c = list;<br><br>    <span class="hljs-keyword">for</span>(Object obj : c)&#123;<br>    System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-泛型的边界"><a href="#4-泛型的边界" class="headerlink" title="4. 泛型的边界"></a>4. 泛型的边界</h2><h3 id="4-1-泛型的上限"><a href="#4-1-泛型的上限" class="headerlink" title="4.1 泛型的上限"></a>4.1 泛型的上限</h3><p>使用 extends 可以定义泛型的上限，这个就表示将来泛型所接收的类型最大是什么类型。</p><p>泛型简单的用 extends 统一的表示了原有的 extends 和 implements 的概念，但仍要遵循应用的体系，即<strong>只能继承一个类，但可以实现多个接口</strong>。所以某个类型需要用 extends 限定，且有多种类型的时候，只能存在一个是类，并且类写在第一位，接口列在后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T extends SomeClass &amp; interface1 &amp; interface2 &amp; interface3&gt;<br></code></pre></td></tr></table></figure><p>例如：list 就可以接收泛型是 Number 或者 Number 子类型的 List 集合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;? extends Number&gt; list;<br>  <br>    <span class="hljs-comment">//list可以指向泛型是Number或者Number【子】类型的集合对象</span><br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Double&gt;();<br>  <br>    <span class="hljs-comment">//编译报错，因为String不是Number类型，也不是Number的子类型</span><br>    <span class="hljs-comment">//list = new ArrayList&lt;String&gt;();</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-extends-的使用场景"><a href="#4-2-extends-的使用场景" class="headerlink" title="4.2 extends 的使用场景"></a>4.2 extends 的使用场景</h3><ul><li><p>在声明泛型类或者泛型接口的时候可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> T x;<br>    <span class="hljs-keyword">private</span> T y;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>在声明泛型方法的时候可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T extends Action&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>在声明变量的时候可以使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;? extends Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Long&gt;();<br>    t.test(list);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-泛型的下限"><a href="#4-3-泛型的下限" class="headerlink" title="4.3  泛型的下限"></a>4.3  泛型的下限</h3><p>使用 super 可以定义泛型的下限，这个就表示将来泛型所接收的类型最小是什么类型。</p><p>例如：list 就可以接收泛型是 Number 或者 Number 父类型的 List 集合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;? <span class="hljs-keyword">super</span> Number&gt; list;<br>  <br>    <span class="hljs-comment">//list可以指向泛型是Number或者Number【父】类型的集合对象</span><br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Serializable&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>  <br>    <span class="hljs-comment">//编译报错，因为String不是Number类型，也不是Number的父类型</span><br>    <span class="hljs-comment">//list = new ArrayList&lt;String&gt;();</span><br>  <br>    <span class="hljs-comment">//编译报错，因为Integer不是Number类型，也不是Number的父类型</span><br>    <span class="hljs-comment">//list = new ArrayList&lt;Integer&gt;();</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-super-的使用场景"><a href="#4-4-super-的使用场景" class="headerlink" title="4.4  super 的使用场景"></a>4.4  super 的使用场景</h3><ul><li><p>在<strong>声明泛型类</strong>或者<strong>泛型接口</strong>的时候<strong>不能使用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译报错</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">super</span> <span class="hljs-title">Number</span>&gt;</span>&#123;<br>  <span class="hljs-keyword">private</span> T x;<br>  <span class="hljs-keyword">private</span> T y;<br>&#125;<br><br><span class="hljs-comment">//编译报错</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">super</span> <span class="hljs-title">Person</span>&gt;</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<strong>声明泛型方法</strong>的时候<strong>不能使用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译报错</span><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">super</span> Action&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>在<strong>声明变量</strong>的时候<strong>可以使用</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> Number&gt; list)</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;? <span class="hljs-keyword">super</span> Number&gt; list;<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br><br>    <span class="hljs-comment">//假设Student 继承了 Person</span><br>    List&lt;? <span class="hljs-keyword">super</span> Student&gt; list;<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Pesson&gt;();<br>    list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2021/06/18/19.%20%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/06/18/19.%20%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><h2 id="2-Class-类"><a href="#2-Class-类" class="headerlink" title="2. Class 类"></a>2. Class 类</h2><p>一个类有成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><ul><li>类本身也是一个对象，我们定义的所有类都是 Class 类的对象。（所有类的类）</li><li>类里面的属性都是 Field 类的对象。</li><li>类里面的方法都是 Method 类的对象。</li><li>类里面的构造器都是 Constructor 类的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注解</title>
    <link href="/2021/06/18/18.%20%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/06/18/18.%20%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>注解（Annotation），是 jdk1.5 引入的技术，用它可以对 java 中的某一个段程序进行说明或标注，并且这个注解的信息可以被其他程序使用特定的方式读取到，从而完成相应的操作。</p><span id="more"></span><h2 id="1-注解的定义"><a href="#1-注解的定义" class="headerlink" title="1. 注解的定义"></a>1. 注解的定义</h2><p>注解（Annotation），是 jdk1.5 引入的技术，用它可以对 java 中的某一个段程序进行说明或标注，并且这个注解的信息可以被其他程序使用特定的方式读取到，从而完成相应的操作。</p><p>例如 <code>@Override</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.toString();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解和注释的区别：</p><ul><li>注解是给其他程序看的，通过参数的设置，可以在编译后class文件中【保留】注解的信息，其他程序读取后，可以完成特定的操作。 </li><li>注释是给程序员看的，无论怎么设置，编译后 class文件中都是【没有】注释信息，方便程序员快速了解代码的作用或结构。</li></ul><h2 id="2-Java-的内置注解"><a href="#2-Java-的内置注解" class="headerlink" title="2. Java 的内置注解"></a>2. Java 的内置注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 <code>java.lang</code> 中，剩下 4 个在 <code>java.lang.annotation</code> 中。</p><p>作用在代码的注解是：</p><ul><li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。</li><li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。</li></ul><p>作用在其他注解的注解（元注解）：</p><ul><li><code>@Retention</code> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</li><li><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。</li><li><code>@Inherited</code> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p>从 Java 7 开始，额外添加了 3 个注解:</p><ul><li><code>@SafeVarargs</code> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><code>@FunctionalInterface</code> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li><code>@Repeatable</code> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h2 id="3-Annotation-接口"><a href="#3-Annotation-接口" class="headerlink" title="3. Annotation 接口"></a>3. Annotation 接口</h2><h3 id="3-1-Annotation-接口的结构"><a href="#3-1-Annotation-接口的结构" class="headerlink" title="3.1 Annotation 接口的结构"></a>3.1 Annotation 接口的结构</h3><img src="https://i.loli.net/2021/06/18/qgfIcj7kQaedTn2.png" alt="Annotation结构.png" style="zoom: 50%;" /><ul><li><p>1 个 Annotation 和 1 个 RetentionPolicy 关联。</p><p>可以理解为：每1个 Annotation 对象，都会有唯一的 RetentionPolicy 属性。</p></li></ul><ul><li><p>1 个 Annotation 和 1~n 个 ElementType 关联。</p><p>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</p></li><li><p>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</p></li></ul><h3 id="3-2-Annotation-组成部分"><a href="#3-2-Annotation-组成部分" class="headerlink" title="3.2 Annotation 组成部分"></a>3.2 Annotation 组成部分</h3><p>java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：</p><ul><li>Annotation 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Annotation</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;<br><br>    Class&lt;? extends Annotation&gt; annotationType();  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>枚举类型 ElementType</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ElementType</span> </span>&#123;<br>    TYPE,               <span class="hljs-comment">/* 类、接口（包括注释类型）或枚举声明  */</span><br><br>    FIELD,              <span class="hljs-comment">/* 字段声明（包括枚举常量）  */</span><br><br>    METHOD,             <span class="hljs-comment">/* 方法声明  */</span><br><br>    PARAMETER,          <span class="hljs-comment">/* 参数声明  */</span><br><br>    CONSTRUCTOR,        <span class="hljs-comment">/* 构造方法声明  */</span><br><br>    LOCAL_VARIABLE,     <span class="hljs-comment">/* 局部变量声明  */</span><br><br>    ANNOTATION_TYPE,    <span class="hljs-comment">/* 注释类型声明  */</span><br><br>    PACKAGE             <span class="hljs-comment">/* 包声明  */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>枚举类型 RetentionPolicy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang.annotation;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RetentionPolicy</span> </span>&#123;<br>    SOURCE,            <span class="hljs-comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该注解信息了  */</span><br><br>    CLASS,             <span class="hljs-comment">/* 编译器将注解存储于类对应的.class文件中。默认行为  */</span><br><br>    RUNTIME            <span class="hljs-comment">/* 编译器将注解存储于class文件中，并且可由JVM读入 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-自定义注解的写法"><a href="#4-自定义注解的写法" class="headerlink" title="4. 自定义注解的写法"></a>4. 自定义注解的写法</h2><p>日常开发中新建 Java 类，我们使用 class、interface 比较多，而注解和它们一样，也是一种类的类型，他是用的修饰符为 @interface。</p><p>使用 @interface 定义注解时，意味着它实现了 <code>java.lang.annotation.Annotation</code> 接口。它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名称 &#123;<br>  <span class="hljs-keyword">public</span> 属性类型 属性名();   <span class="hljs-comment">// 实际上是一个抽象方法，当时可以在括号里传值。</span><br><span class="hljs-comment">// public 属性类型 属性名() default 默认值;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>public 可以省去不写，默认就是 public。</p><h3 id="4-1-注解属性类型"><a href="#4-1-注解属性类型" class="headerlink" title="4.1 注解属性类型"></a>4.1 注解属性类型</h3><ul><li><p>基本数据类型</p></li><li><p>String 类型</p></li><li><p>枚举类型</p></li><li><p>注解类型</p></li><li><p>Class 类型</p></li><li><p>以上类型的一维数组类型</p></li></ul><h3 id="4-2-注解成员变量赋值"><a href="#4-2-注解成员变量赋值" class="headerlink" title="4.2 注解成员变量赋值"></a>4.2 注解成员变量赋值</h3><p>如果注解又多个属性，则可以在注解括号中用“，”号隔开分别给对应的属性赋值，如下例子，注解在父类中赋值属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;mao&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 18</span>;<br>&#125;<br><br><span class="hljs-meta">@MyTestAnnotation(name = &quot;father&quot;,age = 50)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-元注解"><a href="#5-元注解" class="headerlink" title="5. 元注解"></a>5. 元注解</h2><p>在我们进行自定义注解的时候，一般会使用到元注解，来设置自定义注解的基本特点。所以，<strong>元注解也就是对注解进行基本信息设置的注解</strong>。</p><p>元注解分别有：</p><ul><li><p><code>@Target</code>：用于描述注解的使用范围，例如用在类上面还是方法上面。</p></li><li><p><code>@Retention</code>：用于描述注解的保存策略，是保留到源代码中、字节码文件中、还是加载到内存中。</p></li><li><p><code>@Documented</code>：用于描述该注解将会被 javadoc 生产到 API 文档中 。</p></li><li><p><code>@Inherited</code>：用于表示某个被标注的类型是被继承的，如果一个使用了<code>@Inherited</code>修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该 class 的子类。</p></li><li><p><code>@Repeatable</code>（JDK1.8加入）：用于标识某注解可以在同一个声明上使用多次。</p></li></ul><h3 id="5-1-Target"><a href="#5-1-Target" class="headerlink" title="5.1 @Target"></a>5.1 @Target</h3><p>使用 <code>@Target</code> 元注解<strong>表示注解作用的范围</strong>。注解的使用范围，都定义在了一个枚举类  ElementType 中。</p><ul><li><code>@Target(ElementType.TYPE)</code> ：作用接口、类、枚举、注解。</li><li><code>@Target(ElementType.PACKAGE) </code>：作用于包。</li><li><code>@Target(ElementType.FIELD)</code> ：作用属性字段、枚举的常量。</li><li><code>@Target(ElementType.METHOD)</code> ：作用方法。</li><li><code>@Target(ElementType.PARAMETER) </code>：作用方法参数。</li><li><code>@Target(ElementType.CONSTRUCTOR) </code>：作用构造函数。</li><li><code>@Target(ElementType.LOCAL_VARIABLE)</code>：作用局部变量。</li><li><code>@Target(ElementType.ANNOTATION_TYPE)</code>：作用于注解。（@Retention注解中就使用该属性）</li><li><code>@Target(ElementType.TYPE_PARAMETER)</code> ：作用于类型泛型，即泛型方法、泛型类、泛型接口。（jdk1.8加入）</li><li><code>@Target(ElementType.TYPE_USE)</code>： 类型使用，可以用于标注任意类型除了 class 。（jdk1.8加入）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-Retention"><a href="#5-2-Retention" class="headerlink" title="5.2 @Retention"></a>5.2 @Retention</h3><p>使用 <code>@Retention</code> 元注解<strong>表示注解存在阶段</strong>。通过使用枚举类 RetentionPolicy 来表示注解保留时期。</p><ul><li><code>@Retention(RetentionPolicy.SOURCE)</code>：注解仅存在于源码中，在 class 字节码文件中不包含。</li><li><code>@Retention(RetentionPolicy.CLASS)</code>：默认的保留策略，注解会在 class 字节码文件中存在，但运行时无法获得。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>： 注解会 JVM 内存中存在，在运行时可以通过反射获取到。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用情形：</p><ul><li>如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解。</li><li>如果要在编译时进行一些预处理操作，比如生成一些辅助代码，就用 CLASS 注解。</li><li>如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，使用 SOURCE 注解。</li></ul><p>因为 RUNTIME 的生命周期最长，所以其他俩种情况能作用到的阶段，使用 RUNTIME 也一定能作用到。</p><h3 id="5-3-Inherited"><a href="#5-3-Inherited" class="headerlink" title="5.3 @Inherited"></a>5.3 @Inherited</h3><p>一个被 <code>@Inherited</code>注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**自定义注解*/</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyTestAnnotation &#123;<br>&#125;<br><br><span class="hljs-comment">/**父类标注自定义注解*/</span><br><span class="hljs-meta">@MyTestAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br><br><span class="hljs-comment">/**子类*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br><br><span class="hljs-comment">/**测试子类获取父类自定义注解*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><br>      <span class="hljs-comment">//获取 Son 的 class 对象</span><br>       Class&lt;Son&gt; sonClass = Son.class;<br>      <span class="hljs-comment">// 获取Son类上的注解 MyTestAnnotation 可以执行成功</span><br>      MyTestAnnotation annotation = sonClass.getAnnotation(MyTestAnnotation.class);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-Documented"><a href="#5-4-Documented" class="headerlink" title="5.4 @Documented"></a>5.4 @Documented</h3><p>它的作用是能够将注解中的元素包含到 Javadoc 中去。</p><h3 id="5-5-Repeatable"><a href="#5-5-Repeatable" class="headerlink" title="5.5 @Repeatable"></a>5.5 @Repeatable</h3><p>被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**一个人喜欢玩游戏，他喜欢玩英雄联盟，绝地求生，极品飞车，尘埃4等，则我们需要定义一个人的注解，他属性代表喜欢玩游戏集合，一个游戏注解，游戏属性代表游戏名称*/</span><br><br><span class="hljs-comment">/**玩家注解*/</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> People &#123;<br>    Game[] value() ;<br>&#125;<br><br><span class="hljs-comment">/**游戏注解*/</span><br><span class="hljs-meta">@Repeatable(People.class)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Game &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">/**玩游戏类*/</span><br><span class="hljs-meta">@Game(value = &quot;LOL&quot;)</span><br><span class="hljs-meta">@Game(value = &quot;PUBG&quot;)</span><br><span class="hljs-meta">@Game(value = &quot;NFS&quot;)</span><br><span class="hljs-meta">@Game(value = &quot;Dirt4&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayGame</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-注解的作用"><a href="#6-注解的作用" class="headerlink" title="6. 注解的作用"></a>6. 注解的作用</h2><h3 id="6-1-编译检查"><a href="#6-1-编译检查" class="headerlink" title="6.1 编译检查"></a>6.1 编译检查</h3><p> 注解具有“让编译器进行编译检查的作用”。</p><p>例如：@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。</p><h3 id="6-2-在反射中使用注解"><a href="#6-2-在反射中使用注解" class="headerlink" title="6.2 在反射中使用注解"></a>6.2 在反射中使用注解</h3><p>在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。</p><p>这也意味着，我们可以在反射中解析并使用 Annotation。</p><h3 id="6-3-根据-Annotation-生成帮助文档"><a href="#6-3-根据-Annotation-生成帮助文档" class="headerlink" title="6.3 根据 Annotation 生成帮助文档"></a>6.3 根据 Annotation 生成帮助文档</h3><p>通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。</p><h3 id="6-4-能够帮忙查看查看代码"><a href="#6-4-能够帮忙查看查看代码" class="headerlink" title="6.4 能够帮忙查看查看代码"></a>6.4 能够帮忙查看查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p><p>另外，我们也可以通过自定义 Annotation 来实现一些功能。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举</title>
    <link href="/2021/06/18/17.%20%E6%9E%9A%E4%B8%BE/"/>
    <url>/2021/06/18/17.%20%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<p>枚举，是 JDK1.5 引入的新特性，可以通过关键字 enum 来定义枚举类。</p><span id="more"></span><h2 id="1-枚举的定义"><a href="#1-枚举的定义" class="headerlink" title="1. 枚举的定义"></a>1. 枚举的定义</h2><ul><li>枚举，是 JDK1.5 引入的新特性，可以通过关键字 enum 来定义枚举类。 </li><li>枚举类是一种特殊的类，它和普通类一样可以使用构造器、定义成员变量和方法，也能实现一个或多个接口。 但是<strong>枚举类不能继承其他类。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123;<br>BLACK, WHITE<br>&#125;<br></code></pre></td></tr></table></figure><p><code>public enum Color</code> ，表示这是一个枚举类型，名字叫 Color 。</p><p><code>BLACK, WHITE</code> 表示这个枚举类型有俩个固定的对象，一个叫 BLACK，另一个叫 WHITE。</p><p>使用 javap 命令对Color.class文件进行反向解析：</p><img src="https://i.loli.net/2021/06/18/tkOny1p3wcAbBlZ.png" alt="反编译枚举类.png" style="zoom: 67%;" /><ul><li><p>枚举类是一个 final 修饰的类，枚举类型都会默认继承<code>java.lang.Enum</code> 类，而不是 Object 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">E</span>&gt;&gt;</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>枚举中所定义的对象，其实就是类里面的 <code>public static final </code>修饰的常量，并且这些常量会在静态代码块中做初始化。 </p></li><li><p>枚举类型中还一个默认的私有构造器，说明我们在外面并不能自己去创建枚举类型的对象。</p></li><li><p>枚举类型中还有默认添加进来的方法 </p><ul><li><p><code>values() </code>：可以返回这个枚举类型的所有对象，返回类型是数组。</p></li><li><p><code>valueOf(String str)</code> ：通过一个字符串可以返回枚举对象，这个字符串参数就是枚举对象的名字 。</p></li></ul></li><li><p>枚举类型会从父类中继承过来一些方法（具体可以查看其固定的父类型）</p><ul><li><p><code>String name()</code>：返回这个枚举对象的名字 。</p></li><li><p><code>int ordinal()</code>：返回这个枚举对象的编号，默认从0开始。</p></li></ul></li></ul><h2 id="2-意义"><a href="#2-意义" class="headerlink" title="2. 意义"></a>2. 意义</h2><p>java中的类，从语法形式上来说，可以创建出一个类的无数个对象。 </p><p>例如，学生类 Student，我们可以创建出10个、20个等不同数量的学生对象，并且从意义讲确实也没有问题，因为实际情况中确实会存在很多不同的学生。 </p><p>但是这其实还存在另一种情况：一个类的对象，从意义上来说，对象个数是固定的。 </p><p>例如， Gender 这个类，表示人的性别，从语法上来说，可以创建出无数个性别对象，但是从实际意义 上看，我们只需要俩个对象就可以了，一个表示男、一个表示女。 </p><p>那么，在这个时候，我们就需要去对 Gender 类的对象创建作出限制，不让用户创建很Gender类型的对象，因为如果创建了很多对象，那么会占用内存空间，同时这么多对象也没什么实际意义，最终还是只能表示俩种情况，男和女。 </p><p>解决这个问题的方式是，可以将 Gender 定义为一个枚举类型（enum），我们就可以在枚举类型中，提前将这个类型的对象个数和对象名字都固定下来，并且之后的使用中不会改变，也不会再创建其他对象。</p><h2 id="3-获取枚举对象"><a href="#3-获取枚举对象" class="headerlink" title="3. 获取枚举对象"></a>3. 获取枚举对象</h2><p>以 Gender 这个枚举类型为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span></span>&#123;<br>MALE,FEMALE<br>&#125;<br></code></pre></td></tr></table></figure><p>方式1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//使用类名直接访问类中定义的俩对象</span><br>  <br>    <span class="hljs-comment">//最常用的一种方式</span><br>    Gender g = Gender.MALE;<br>    g = Gender.FEMALE;<br>  <br>    <span class="hljs-comment">//可以调用从父类型Enum以及Object中继承过来的方法</span><br>    System.out.println(g.name());<br>    System.out.println(g.ordinal());<br>    System.out.println(g.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><span class="hljs-comment">//通过字符串参数的改变，可以获取到Gender中的指定的一个对象</span><br>    String name = <span class="hljs-string">&quot;MALE&quot;</span>;<br>    Gender g = Gender.valueOf(name);<br>    System.out.println(g.name());<br>    System.out.println(g.ordinal());<br>    System.out.println(g.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>方法3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//通过字符串确定是哪一个枚举类型</span><br>    Class c = Class.forName(<span class="hljs-string">&quot;com.briup.demo.Genger&quot;</span>);<br>  <br>    <span class="hljs-comment">//通过字符串确定是哪一个名字的枚举对象</span><br>    String name = <span class="hljs-string">&quot;FEMALE&quot;</span>;<br>  <br>    <span class="hljs-comment">//可以通过改变字符串，获取到java中任何一个枚举类型中的任意一个枚举对象</span><br>    Enum g = Enum.valueOf(c,name);<br>    System.out.println(g.name());<br>    System.out.println(g.ordinal());<br>    System.out.println(g.toString());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-枚举中定义属性和方法"><a href="#4-枚举中定义属性和方法" class="headerlink" title="4. 枚举中定义属性和方法"></a>4. 枚举中定义属性和方法</h2><p>在枚举类型中，除了可以指定对象的个数和名称之外，还可以定义属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span></span>&#123;<br>  MALE,FEMALE;<br>  <span class="hljs-keyword">private</span> String name;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;Gender test...&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String name)</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;hello &quot;</span>+name);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  Gender g = Gender.MALE;<br>  g.test();<br>  g.setName(<span class="hljs-string">&quot;我是男生&quot;</span>);<br>  System.out.println(g.getName());<br>  Gender.print(<span class="hljs-string">&quot;jack&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类型中的第一行代码，要求一定是指定枚举对象的个数和名字，同时最后面加分号。</p><p>在这行代码下， 才可以定义枚举类型的属性和方法。</p><h2 id="5-枚举中定义构造器"><a href="#5-枚举中定义构造器" class="headerlink" title="5. 枚举中定义构造器"></a>5. 枚举中定义构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span></span>&#123;<br>  MALE,FEMALE;<br>  <span class="hljs-keyword">private</span> String name;<br>  <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Gender</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Gender</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Gender&#123;name=&quot;</span>+name+<span class="hljs-string">&quot;&#125;&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举中的构造器，只能使用 private 修饰，或者不写修饰符，那么默认也是 private，同时还可以构造器重载。</p><p>调用构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//该代码，可以对Gender.class进行类加载</span><br>    Class.forName(<span class="hljs-string">&quot;com.briup.demo.Gender&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>有参构造器被调用<br>有参构造器被调用<br></code></pre></td></tr></table></figure><h2 id="6-枚举中定义抽象方法"><a href="#6-枚举中定义抽象方法" class="headerlink" title="6.  枚举中定义抽象方法"></a>6.  枚举中定义抽象方法</h2><p>枚举类中定义抽象方法，必须将抽象方法进行实现。因为枚举类型是 final 修饰的类，不可能有子类型来实现这个抽象方法，所以就必须是自己的对象去实现这个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span></span>&#123;<br>    MALE()&#123;<br>    <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男生测试&quot;</span>);<br>        &#125;<br>     &#125;,FEMALE()&#123;<br>          <span class="hljs-meta">@Override</span><br>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;女生测试&quot;</span>);<br>          &#125;<br>      &#125;;<br>  <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法和匿名内部类的写法很相似， <code>MALE()&#123;...&#125;,</code> <code>FEMALE()&#123;...&#125;;</code></p><h2 id="7-枚举类实现接口"><a href="#7-枚举类实现接口" class="headerlink" title="7. 枚举类实现接口"></a>7. 枚举类实现接口</h2><p>枚举类型已经有默认的父类型<code>java.lang.Enum</code>，我们就不能让它在继承其他父类了，但是我们可 以让枚举类型实现指定的接口。</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>MALE,FEMALE;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;枚举中统一实现接口中的抽象方法&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Gender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>    MALE()&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;男生对象中，单独实现接口中的抽象方法&quot;</span>);<br>&#125;<br>&#125;,FEMALE()&#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;女生对象中，单独实现接口中的抽象方法&quot;</span>);<br>      &#125;<br>&#125;;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-枚举使用总结"><a href="#8-枚举使用总结" class="headerlink" title="8. 枚举使用总结"></a>8. 枚举使用总结</h2><p>对于枚举类型的使用，大多数情况下，我们在枚举中列出它的的每一个对象即可，偶尔会添加几个自定 义的属性和方法，并不会写的那么复杂，否则就没什么意义了。 </p><p>在项目中，只要一个类型的对象个数和名称能固定下来的，就可以考虑使用枚举类型来表示。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2021/06/15/16.%20%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2021/06/15/16.%20%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>集合是 JavaAPI 中提供的一种容器工具，可以用来存储多个数据。 </p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>集合是 JavaAPI 中提供的一种容器工具，可以用来存储多个数据。 </p><h3 id="1-1-集合和数组之间的区别"><a href="#1-1-集合和数组之间的区别" class="headerlink" title="1.1 集合和数组之间的区别"></a>1.1 集合和数组之间的区别</h3><ul><li><p>数组的长度是固定的，集合的长度是可变的。</p></li><li><p>数组中存储的是同一类型的元素，集合中存储的数据可以是不同类型的。</p></li><li><p>数组中可以存放基本类型数据或者对象，集合中只能存放对象。 </p></li><li><p>数组是由 JVM 中现有的 类型+[] 组合而成的，除了一个 length 属性，还有从 Object 中继承过来的方法之外，数组对象就调用不到其他属性和方法。 </p></li><li><p>集合是由 JavaAPI 中的 java.util 包里面所提供的接口和实现类组成的，这里面定义并实现了很多方法，可以使用集合对象直接调用这些方法，从而操作集合存放的数据。</p></li></ul><h3 id="1-2-集合框架中主要有三个要素组成"><a href="#1-2-集合框架中主要有三个要素组成" class="headerlink" title="1.2 集合框架中主要有三个要素组成"></a>1.2 集合框架中主要有三个要素组成</h3><ol><li><p>接口：整个集合框架的上层结构，都是用接口进行组织的。 接口中定义了集合中必须要有的基本方法。 通过接口还把集合划分成了几种不同的类型，每一种集合都有自己对应的接口。 </p></li><li><p>实现类：对于上层使用接口划分好的集合种类，每种集合的接口都会有对应的实现类。 每一种接口的实现类很可能有多个，每个的实现方式也会各有不同。 </p></li><li><p>数据结构：每个实现类都实现了接口中所定义的最基本的方法，例如对数据的存储、检索、操作等方法。 但是不同的实现类，它们存储数据的方式不同，也就是使用的数据结构不同。</p></li></ol><h3 id="1-3-集合的分类"><a href="#1-3-集合的分类" class="headerlink" title="1.3 集合的分类"></a>1.3 集合的分类</h3><p>按照其存储结构可以分为两大类： <code>java.util.Collection</code> 和 <code>java.util.Map</code>。其他的集合接口，都是由这俩个接口派生出来的。</p><h2 id="2-Collection-接口"><a href="#2-Collection-接口" class="headerlink" title="2. Collection 接口"></a>2. Collection 接口</h2><h3 id="2-1-Collection-框架的结构图"><a href="#2-1-Collection-框架的结构图" class="headerlink" title="2.1 Collection 框架的结构图"></a>2.1 Collection 框架的结构图</h3><p>Collection 接口是单列集合类的父接口，这种集合可以将数据一个一个的存放到集合中。它有两个重要的子接口，分别是 <code>java.util.List</code> 和 <code>java.util.Set</code>。（下图展示的只是一部分，详情自信查看 API）</p><img src="https://i.loli.net/2021/06/15/pbLlatR7QhSjdIB.png" alt="Collecton结构.png" style="background-color: #fff;"  /><h3 id="2-2-Collection-集合的方法"><a href="#2-2-Collection-集合的方法" class="headerlink" title="2.2 Collection 集合的方法"></a>2.2 Collection 集合的方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>向集合中添加元素。</td></tr><tr><td><code>boolean addAll(Collection c)</code></td><td>把一个指定集合中的所有数据，添加到当前集合中。</td></tr><tr><td><code>boolean contains(Object o) </code></td><td>判断当前集合中是否包含给定的对象。</td></tr><tr><td><code>boolean containsAll(Collection c)</code></td><td>判断当前集合中是否包含给定的集合的所有元素。</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>把给定的对象，在当前集合中删除。</td></tr><tr><td><code>boolean removeAll(Collection c)</code></td><td>把给定的集合中的所有元素，在当前集合中删除。</td></tr><tr><td><code>void clear()</code></td><td>清空集合中所有的元素。</td></tr><tr><td><code>boolean retainAll(Collection c)</code></td><td>判断俩个集合中是否有相同的元素，如果有当前集合只保留相同元素，如果没有则清空。</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断当前集合是否为空。</td></tr><tr><td><code>Iterator iterator() </code></td><td>返回遍历这个集合的迭代器对象。</td></tr><tr><td><code>int size() </code></td><td>返回集合中元素的个数。</td></tr><tr><td><code>Object[] toArray()</code></td><td>把集合中的元素，存储到数组中。</td></tr><tr><td><code>T[] toArray(T[] a)</code></td><td>把集合中的元素，存储到数组中，并指定数组的类型。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// ArrayList 类是 Collection 集合的一个实现类。</span><br>    Collection c1 = <span class="hljs-keyword">new</span> ArrayList();<br>    c1.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>    c1.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>    c1.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>  <br>    <span class="hljs-comment">//默认调用集合的toString方法，输出集合中内容</span><br>    System.out.println(<span class="hljs-string">&quot;操作之前集合中元素:&quot;</span>+c1);<br>    System.out.println(<span class="hljs-string">&quot;集合中的元素个数：&quot;</span>+c1.size());<br>    System.out.println(<span class="hljs-string">&quot;集合中是否包含hello1：&quot;</span>+c1.contains(<span class="hljs-string">&quot;hello1&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;删除hello1：&quot;</span>+c1.remove(<span class="hljs-string">&quot;hello1&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;操作之后集合中元素:&quot;</span>+c1);<br>  <br>    Object[] objects = c1.toArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; objects.length; i++) &#123;<br>    System.out.println(objects[i]);<br>    &#125;<br>    c1.clear();<br>    System.out.println(<span class="hljs-string">&quot;集合中内容为：&quot;</span>+c1);<br>    System.out.println(c1.isEmpty());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Iterator-迭代器"><a href="#3-Iterator-迭代器" class="headerlink" title="3. Iterator 迭代器"></a>3. Iterator 迭代器</h2><p>为了能够方便的遍历集合中的每一个元素，API 中提供了一个迭代器接口： <code>java.util.Iterator</code>。使用该接口可以很方便的迭代出集合中的元素。<code>java.lang.Iterable</code> 接口中，定义了获取迭代器的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span> </span>&#123;<br><span class="hljs-function">Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>java.util.Collection</code> 接口继承了 <code>java.lang.Iterable</code> 接口，所以 Collection 接口及其子接口中，都有 <code>Iterator iterator()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterable</span> </span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>java.util.Iterator</code> 接口中，主要定义俩个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回当前迭代器中是否还有下一个对象</span><br>    <span class="hljs-function">Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//获取迭代器中的下一个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器方式获取集合中的每一个元素，是 Collection 集合及其子类型集合通用的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Collection c1 = <span class="hljs-keyword">new</span> ArrayList();<br>    c1.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>    c1.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>    c1.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>  <br><span class="hljs-comment">//获取c1集合的迭代器对象</span><br>Iterator iterator = c1.iterator();<br>  <br><span class="hljs-comment">//判断迭代器中，是否还有下一个元素</span><br>    <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>        <span class="hljs-comment">//如果有的话，就取出来</span><br>        Object obj = iterator.next();<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-List-集合"><a href="#4-List-集合" class="headerlink" title="4. List 集合"></a>4. List 集合</h2><p><code>java.util.List</code> 接口继承了 Collection 接口，是常用的一种集合类型。 </p><h3 id="4-1-List-集合的特点"><a href="#4-1-List-集合的特点" class="headerlink" title="4.1 List 集合的特点"></a>4.1 List 集合的特点</h3><ul><li>List 是一种有序的集合。 例如，向集合中存储的元素顺序是 8、2、5。那么集合中就是按照这个顺序进行存储的。</li><li>List 是一种带索引的集合，可以通过元素的下标索引，精确查找对应的元素数据。</li><li>List 是一种可以存放重复数据的集合可以把相同的数据，在 List 集合中多次保存。</li></ul><h3 id="4-2-List-接口中的方法"><a href="#4-2-List-接口中的方法" class="headerlink" title="4.2 List 接口中的方法"></a>4.2 List 接口中的方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>E get(int index)</code></td><td>返回集合中指定位置的元素。</td></tr><tr><td><code> int indexOf(Object o)</code></td><td>查找定元素在集合中的索引（从前往后查到的第一个元素）。</td></tr><tr><td><code>int lastIndexOf(Object o)</code></td><td>查收指定元素在集合中的索引（从后往前查到的第一个元素）。</td></tr><tr><td><code>void add(int index, E element)</code></td><td>将指定的元素，添加到该集合中的指定位置上。</td></tr><tr><td><code>boolean addAll(int index, Collection c)</code></td><td>从指定位置开始，把另一个集合的所有元素添加进来。</td></tr><tr><td><code>E set(int index, E element)</code></td><td>用指定元素替换集合中指定位置的元素,并返回被替代的旧元素。</td></tr><tr><td><code>E remove(int index)</code></td><td>移除列表中指定位置的元素, 并返回被移除的元素。</td></tr><tr><td><code>List subList(int fromIndex, int toIndex)</code></td><td>根据指定开始和结束位置，截取出集合中的一部分数据。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建List集合对象</span><br>    List list = <span class="hljs-keyword">new</span> ArrayList();<br>  <br>    <span class="hljs-comment">// 往尾部添加 指定元素</span><br>    list.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>    System.out.println(list);<br>  <br>    <span class="hljs-comment">// add(int index,String s) 往指定位置添加</span><br>    list.add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>    System.out.println(list);<br>  <br>    <span class="hljs-comment">// 删除索引位置为2的元素</span><br>    System.out.println(<span class="hljs-string">&quot;删除索引位置为2的元素&quot;</span>);<br>    System.out.println(list.remove(<span class="hljs-number">2</span>));<br>    System.out.println(list);<br>  <br>    <span class="hljs-comment">// 修改指定位置元素</span><br>    list.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;briup&quot;</span>);<br>    System.out.println(list);<br>  <br>    <span class="hljs-comment">// 遍历集合</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>    System.out.println(list.get(i));<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>  <br>    <span class="hljs-comment">// 使用foreach遍历</span><br>    <span class="hljs-keyword">for</span>(Object obj : list)&#123;<br>    System.out.println(obj);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br>  <br>    <span class="hljs-comment">// 使用迭代器进行遍历集合</span><br>    Iterator it = list.iterator();<br>    <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>        Object obj = it.next();<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-ArarryList"><a href="#4-3-ArarryList" class="headerlink" title="4.3 ArarryList"></a>4.3 ArarryList</h3><p><code>java.util.ArrayList</code> 是最常用的一种 List 类型集合。 </p><ul><li>ArrayList 类中使用数组来实现数据的存储， 所以它的特点是就是：<strong>增删慢，查找快。</strong> </li><li>在日常的开发中，查询数据也是用的最多的功能，所以 ArrayList 是最常用的集合。 但是，如果项目中对性能要求较高，并且在集合中大量的数据做增删操作，那么 ArrayList 就不太适合了。</li></ul><h3 id="4-4-Vector"><a href="#4-4-Vector" class="headerlink" title="4.4 Vector"></a>4.4 Vector</h3><p>Vector 内部也是<strong>采用了数组来存储数据</strong>。但是 Vector 中方法的定义，可以看到多大数方法都使用了 synchronized 关键字，来给当前方法加锁。所以 Vector 中的方法大多数都是<strong>线程安全</strong>的方法，在多线并发访问的环境中，可以使用 Vector 来保证集合中元据操作的安全。</p><h3 id="4-5-LinkedList"><a href="#4-5-LinkedList" class="headerlink" title="4.5 LinkedList"></a>4.5 LinkedList</h3><h4 id="4-5-1-特点"><a href="#4-5-1-特点" class="headerlink" title="4.5.1 特点"></a>4.5.1 特点</h4><ul><li><p><code>java.util.LinkedList</code> 存储数据采用的数据结构是链表，所以它的特点是：<strong>增删快，查找慢</strong>。这里描述的快和慢，需要在大量的数据操作下，才可以体现，<strong>如果数据量不大的话，集合每一种集合的操作几乎没有任何区别</strong>。</p></li><li><p><strong>线程不安全，但是效率高</strong>。</p></li></ul><h4 id="4-5-2-结构"><a href="#4-5-2-结构" class="headerlink" title="4.5.2 结构"></a>4.5.2 结构</h4><img src="https://i.loli.net/2021/06/15/U9xHFIu7nojDOba.png" style= "background-color : #fff;"><p>LinkedList 是一个双向链表。除了头节点（head）和尾节点（tail）之外，其他节点都含有俩个引用，一 个引用指向它的上一个节点，另一个引用指向它的的下一个节点。</p><h4 id="4-5-3-特有方法"><a href="#4-5-3-特有方法" class="headerlink" title="4.5.3 特有方法"></a>4.5.3 特有方法</h4><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>void addFirst(E e) </code></td><td>将指定元素插入此列表的开头。</td></tr><tr><td><code>void addLast(E e) </code></td><td>将指定元素添加到此列表的结尾。</td></tr><tr><td><code>E getFirst()</code></td><td>返回此列表的第一个元素。</td></tr><tr><td><code>E getLast() </code></td><td>返回此列表的最后一个元素。</td></tr><tr><td><code>E pop() </code></td><td>从此列表所表示的堆栈处弹出一个元素。</td></tr><tr><td><code>void push(E e) </code></td><td>将元素推入此列表所表示的堆栈。</td></tr><tr><td><code>E removeFirst() </code></td><td>移除并返回此列表的第一个元素。</td></tr><tr><td><code>E removeLast()</code></td><td>移除并返回此列表的最后一个元素。</td></tr></tbody></table><h4 id="4-5-4-队列"><a href="#4-5-4-队列" class="headerlink" title="4.5.4 队列"></a>4.5.4 队列</h4><p>LinkedList 类不仅实现了 List 接口，还实现了 Queue 接口以及子接口 Deque。</p><img src="https://i.loli.net/2021/06/15/3JUAS9pxuLWeHdf.png" ><p>Queue 是队列接口， Deque 是双端队列。 </p><p>JavaAPI 中提供了 <code>java.util.Stack</code> 来实现栈结构，但官方目前已不推荐使用，而是推荐使用 <code>java.util.Deque</code> 双端队列来实现队列与栈的各种需求。所以 LinkedList 同时具有队列和栈的操作方法，pop 和 push 都是栈结构的操作方法。所以， <strong>LinkedList 集合也可以作为栈和队列的数据结构来使用</strong>。</p><h2 id="5-Set-集合"><a href="#5-Set-集合" class="headerlink" title="5. Set 集合"></a>5. Set 集合</h2><p><code>java.util.Set</code> 接口继承了 Collection 接口，是常用的一种集合类型。 </p><h3 id="5-1-Set-集合的特点"><a href="#5-1-Set-集合的特点" class="headerlink" title="5.1 Set 集合的特点"></a>5.1 Set 集合的特点</h3><ul><li>Set 是一种无序的集合。</li><li>Set 是一种不带下标索引的集合。</li><li>Set 是一种不能存放重复数据的集合。</li><li>Set 接口中的方法，都继承自它的父接口，即 set 接口中没有特有的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        set.add(<span class="hljs-string">&quot;hello1&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello2&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello3&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello4&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello5&quot;</span>);<br>        set.add(<span class="hljs-string">&quot;hello5&quot;</span>); <br>  <span class="hljs-comment">// 不会编译报错，但是不会加到集合里，即集合中就只有一个 hello5。</span><br><br>        <span class="hljs-comment">// 使用 foreach 打印集合内的元素。</span><br>        <span class="hljs-keyword">for</span>(Object obj:set)&#123;<br>            System.out.println(obj);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----------------&quot;</span>);<br><br>        <span class="hljs-comment">// 使用迭代器打印集合内的元素。</span><br>        Iterator&lt;String&gt; it = set.iterator();<br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            Object obj = it.next();<br>            System.out.println(obj);<br>        &#125;<br><br>        <span class="hljs-comment">// 两次打印结果相同：hello1 hello4 hello5 hello2 hello3 </span><br>        <span class="hljs-comment">// set 的无序性体现在：集合内存放的顺序和添加的顺序不同。</span><br>      <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-HashSet"><a href="#5-2-HashSet" class="headerlink" title="5.2 HashSet"></a>5.2 HashSet</h3><p><code>java.util.HashSet</code> 类的实现，主要依靠的是 HashMap，而 HashMap 的实现主要是利用哈希表。</p><p>HashSet 为什么是无序的，它是怎么判断元素是否是重复的？</p><ul><li>HashSet 中存储元素是无序的，主要因为它是<strong>靠对象的哈希值来确定元素在集合中的存储位置</strong>。 </li><li>HashSet 中元素不可重复，主要是<strong>靠对象的 hashCode 和 equals 方法来判断对象是否重复</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  String name;<br>  <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br>  <br><span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set set = <span class="hljs-keyword">new</span> HashSet();<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>      System.out.println(obj);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果为：</span><br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，HashSet 并没有把 name 和 age 都相同的对象，当做相同的对象进行去重。原因是，<strong>HashSet 中判断对象是否重复是根据对象的 hashCode 值和 equals 的比较结果</strong>，而不是根据对象的 name 和 age 值是否相等！ </p><p>如果俩个对象的 hashCode 值相等，那么再使用 equals 判断是否俩对象是否相同， 如果俩个对象的 hashCode 值不同等，那么就不再使用 equals 进行判断了，因为 hashCode 不同的俩个对象一定是不同的俩个对象！</p><p>所以，想要将 Student 对象根据我们的要求进行去重，就要重写 Student 中的 hashCode 方法和 equals 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>        <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>        <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Student student = (Student) o;<br>        <span class="hljs-keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);<br>     &#125;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set set = <span class="hljs-keyword">new</span> HashSet();<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>  <br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出结果：</span><br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br></code></pre></td></tr></table></figure><p><code>java.util.Objects </code>是 JDK1.7 提供的一个对象的工具类，里面定义的一些静态方法，提供了操作对象的方法。</p><p>例如：<code>equals(Object a, Object b)</code> 可以判断俩个对象是否相等，当然也可以直接进行 equals 判断。</p><p>例如：<code>hash(Object... values)</code> 可以根据若干个参数计算出一个哈希值，当然也可以自己设置哈希值。</p><h3 id="5-3-TreeSet"><a href="#5-3-TreeSet" class="headerlink" title="5.3 TreeSet"></a>5.3 TreeSet</h3><p>TreeSet 是 Set 接口的子接口 SortedSet 的实现类。</p><p>TreeSet 可以将我们存进去的数据进行排序，排序的方式有俩种：</p><ul><li>自然排序 </li><li>比较器排序（也称客户化排序）</li></ul><h4 id="5-3-1-自然排序"><a href="#5-3-1-自然排序" class="headerlink" title="5.3.1 自然排序"></a>5.3.1 自然排序</h4><p>如果一个类，实现了 <code>java.lang.Comparable</code> 接口，那么这个类的俩个对象就是可以比较大小的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T o)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>compareTo 方法使用说明： <code>int result = o1.compareTo(o2);</code> </p><ul><li>result 的值大于0，说明 o1 比 o2 大。 </li><li>result 的值小于0，说明 o1 比 o2 小。 </li><li>result 的值等于0，说明 o1 与 o2 相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set set = <span class="hljs-keyword">new</span> TreeSet();<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">5</span>);<br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>    System.out.println(obj);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出结果：1 3 5 7</span><br></code></pre></td></tr></table></figure><p>Integer 类是实现了 Comparable 接口的，那么 Integer 类的俩个对象之间就可以调用 compareTo 方法比较大小了，当前对象比较出来大小，那么对象就可以按照从小到大的顺序进行排序。 所以，<strong>数据排序的前提，一定是可以比较出数据的大小</strong>。</p><p>给自定义类型进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set&lt;Student&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>  <br>  <span class="hljs-comment">// 这里的 Student 类和上面一样。</span><br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;mary&quot;</span>,<span class="hljs-number">23</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">21</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lucy&quot;</span>,<span class="hljs-number">22</span>));<br>  <br>    <span class="hljs-keyword">for</span>(Student student : set)&#123;<br>        System.out.println(student);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果报错：</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassCastException: com.briup.demo.Student<br>cannot be cast to java.lang.Comparable<br></code></pre></td></tr></table></figure><p>报错原因，<strong>TreeSet 中会把对象强制为 Comparable 类型</strong>，因为转成 Comparable 类型就可以调用 compareTo 方法进行俩个对象的比较大小了。但是这里的 Student 没有实现该接口，所以报错了。</p><p>Student 类实现 Comparable 接口，并在 compareTo 方法中，编写比较大小的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span></span>&#123;<br>    String name;<br>    <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>        <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>        <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student other)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age - other.age;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Set set = <span class="hljs-keyword">new</span> TreeSet();<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;mary&quot;</span>,<span class="hljs-number">23</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">21</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lucy&quot;</span>,<span class="hljs-number">22</span>));<br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;jack&#x27;</span>, age=<span class="hljs-number">21</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;lucy&#x27;</span>, age=<span class="hljs-number">22</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;mary&#x27;</span>, age=<span class="hljs-number">23</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，现在学生对象在 TreeSet 中，就可以按照我们定义的规则进行从小到大排序了。</p><h4 id="5-3-2-比较器排序"><a href="#5-3-2-比较器排序" class="headerlink" title="5.3.2 比较器排序"></a>5.3.2 比较器排序</h4><p><strong>比较器排序比自然排序优先级更高。</strong></p><p>假设现在 Student 类已经写好了，但是没有实现 Comparable 接口，同时我们又不愿意直接修改 Student 类的代码，那么在这种情况下，Student 对象在 TreeSet 中是否还能排序呢？</p><p><code> java.util.Comparator</code> 接口，是一个比较器接口，它的实现类可以对俩个对象作出大小的比较，即使对象没有实现 Comparable 接口，也可以进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T o1, T o2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比较器的使用规则： <code>int result = compare(o1, o2); </code></p><ul><li>result 的值大于 0，说明 o1 比 o2 大。</li><li>result 的值小于 0，说明 o1 比 o2 小 。</li><li>result 的值等于 0，说明 o1 与 o2 相等 。</li></ul><p>注意，这里和自然排序的规则是一样的，<strong>只关心正数、负数、零，不关心具体的值是多少。</strong></p><p>在TreeSet类重载的构造器中，有一个构造器可以接收比较器对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;<br><span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;&gt;(comparator));<br>&#125;<br></code></pre></td></tr></table></figure><p>给学生对象排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//使用 Comparator 接口，创建出匿名内部类对象，这个对象就是要用的比较器对象</span><br>Comparator c = <span class="hljs-keyword">new</span> Comparator() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>            Student s1 = (Student) o1;<br>            Student s2 = (Student) o2;<br>            <span class="hljs-keyword">return</span> s1.age &gt; s2.age? <span class="hljs-number">1</span> : (s1.age==s2.age? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>);<br>        &#125;<br>&#125;;<br>  <br>    <span class="hljs-comment">//创建TreeSet对象的时候，把比较器对象传入</span><br>    Set set = <span class="hljs-keyword">new</span> TreeSet(c);<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;mary&quot;</span>,<span class="hljs-number">23</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-number">21</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>));<br>    set.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;lucy&quot;</span>,<span class="hljs-number">22</span>));<br>  <br>    <span class="hljs-keyword">for</span>(Object obj : set)&#123;<br>        System.out.println(obj);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br>Student&#123;name=<span class="hljs-string">&#x27;tom&#x27;</span>, age=<span class="hljs-number">20</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;jack&#x27;</span>, age=<span class="hljs-number">21</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;lucy&#x27;</span>, age=<span class="hljs-number">22</span>&#125;<br>Student&#123;name=<span class="hljs-string">&#x27;mary&#x27;</span>, age=<span class="hljs-number">23</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Map"><a href="#6-Map" class="headerlink" title="6. Map"></a>6. Map</h2><h3 id="6-1-Map-集合的特点"><a href="#6-1-Map-集合的特点" class="headerlink" title="6.1 Map 集合的特点"></a>6.1 Map 集合的特点</h3><p>Map 类型集合中，每次需要存一对数据，key-value（键值对）。</p><ul><li><p> key 值必须是唯一的，value 值允许重复。</p></li><li><p>键（key）和值（value）一一映射，一个 key 对应一个 value 。</p></li><li><p>在 Map 中，通过 key 值，可以快速的找到对应的 value 值。</p></li><li><p>如果键值相同，后面加入的会覆盖前面的。</p></li></ul><h3 id="6-2-Map-接口中的方法"><a href="#6-2-Map-接口中的方法" class="headerlink" title="6.2 Map 接口中的方法"></a>6.2 Map 接口中的方法</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>V put(K key, V value)</code></td><td>把 key-value 存到当前 Map 集合中。</td></tr><tr><td><code>void putAll(Map m) </code></td><td>把指定 map 中的所有 key-value，存到当前 Map 集合中。</td></tr><tr><td><code>boolean containsKey(Object key) </code></td><td>当前 Map 集合中是否包含指定的 key 值。</td></tr><tr><td><code>boolean containsValue(Object value)</code></td><td>当前 Map 集合中是否包含指定的 value 值。</td></tr><tr><td><code>V get(Object key)</code></td><td>通过指定的 key 值，获取对应的 value 值。</td></tr><tr><td><code>V remove(Object key) </code></td><td>移除指定 key 及其对应的 value。</td></tr><tr><td><code>Set keySet() </code></td><td>返回 Map 集合中所有的 key 值 。</td></tr><tr><td><code>Collection&lt;V&gt; values()</code></td><td>返回 Map 集合中所有的 value 值。</td></tr><tr><td><code>Set&lt;Map.Entry&lt;k,V&gt;&gt; entrySet()</code></td><td>把 Map 集合中的的 key-value 封装成 Entry 类型对象，再存放到 set 集合中，并返回。</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断当前 Map 集合是否为空。</td></tr><tr><td><code>int size() </code></td><td>返回当前 Map 集合中的元素个数。</td></tr><tr><td><code>void clear() </code></td><td>清空当前 Map 集合中的所有数据。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map map = <span class="hljs-keyword">new</span> HashMap();<br>    map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>    map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;map是否为空：&quot;</span>+map.isEmpty());<br>    System.out.println(<span class="hljs-string">&quot;map中元素的个数：&quot;</span>+map.size());<br>    System.out.println(<span class="hljs-string">&quot;map中是否包含指定key值1：&quot;</span>+map.containsKey(<span class="hljs-number">1</span>));<br>    System.out.println(<span class="hljs-string">&quot;map中是否包含指定value值mary：&quot;</span>+map.containsValue(<span class="hljs-string">&quot;mary&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;map中获取指定key值1对应的value值：&quot;</span>+map.get(<span class="hljs-number">1</span>));<br>    System.out.println(<span class="hljs-string">&quot;map中获取指定key值5对应的value值：&quot;</span>+map.get(<span class="hljs-number">5</span>));<br>  <br><span class="hljs-comment">/* Map集合的这三种遍历方式 */</span><br>    System.out.println(<span class="hljs-string">&quot;--------获取map中所有的kay值--------&quot;</span>);<br>    Set keys = map.keySet();<br>    <span class="hljs-keyword">for</span>(Object key : keys)&#123;<br>        System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>    &#125;<br>  <br>    System.out.println(<span class="hljs-string">&quot;--------获取map中所有的value值--------&quot;</span>);<br>    Collection values = map.values();<br>    <span class="hljs-keyword">for</span>(Object value : values)&#123;<br>      System.out.println(value);<br>    &#125;<br>  <br>System.out.println(<span class="hljs-string">&quot;--------获取map中所有的key-value(键值对),封装成Entry类型对象--------&quot;</span>);<br>    Set entrySet = map.entrySet();<br>    <span class="hljs-keyword">for</span>(Object obj : entrySet)&#123;<br>    Map.Entry entry = (Map.Entry) obj;<br>      System.out.println(entry.getKey()+<span class="hljs-string">&quot; : &quot;</span>+entry.getValue());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-3-HashMap"><a href="#6-3-HashMap" class="headerlink" title="6.3 HashMap"></a>6.3 HashMap</h3><p>存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一性，需要重写键的 hashCode() 方法和 equals() 方法。（重要，最常用）</p><h3 id="6-4-HashTable"><a href="#6-4-HashTable" class="headerlink" title="6.4 HashTable"></a>6.4 HashTable</h3><p>和之前 List 集合中的 Vector 的功能类似，可以在多线程环境中，保证集合中的数据的操作安全。类中的方法大多数使用了 synchronized 修饰符进行加锁。（线程安全）</p><h3 id="6-5-TreeMap"><a href="#6-5-TreeMap" class="headerlink" title="6.5 TreeMap"></a>6.5 TreeMap</h3><p>该类是 Map 接口的子接口 SortedMap 下面的实现类，和 TreeSet 类似，它可以对 key 值进行排序，同时构造器也可以接收一个比较器对象作为参数。</p><h4 id="6-51-自然排序"><a href="#6-51-自然排序" class="headerlink" title="6.51 自然排序"></a>6.51 自然排序</h4><p>使用方式和 TreeSet 一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>  map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>  map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>  map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br><br>  Set&lt;Integer&gt; keys = map.keySet();<br><br>  <span class="hljs-keyword">for</span>(Integer key : keys)&#123;<br>    System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-52-比较器排序"><a href="#6-52-比较器排序" class="headerlink" title="6.52 比较器排序"></a>6.52 比较器排序</h4><p>使用方式和 TreeSet 一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Comparator&lt;Integer&gt; c = <span class="hljs-keyword">new</span> Comparator() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>&#123;<br>      Integer k1 = (Integer) o1;<br>      Integer k2 = (Integer) o2;<br>      <span class="hljs-keyword">return</span> k1.compareTo(k2);<br>    &#125;<br>  &#125;;<br><br>  TreeMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(c);<br>  map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>  map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>  map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>  Set&lt;Integer&gt; keys = map.keySet();<br>  <span class="hljs-keyword">for</span>(Integer key : keys)&#123;<br>    System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-6-LinkedHashMap"><a href="#6-6-LinkedHashMap" class="headerlink" title="6.6 LinkedHashMap"></a>6.6 LinkedHashMap</h3><p>该类是 HashMap 的子类，存储数据采用的哈希表结构 + 链表结构。通过链表结构可以保证元素的存取顺序一致。（存入顺序就是取出顺序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Map&lt;Integer,String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>  map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>  map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>  map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br><br>  Set&lt;Integer&gt; keys = map.keySet();<br>  <span class="hljs-keyword">for</span>(Integer key : keys)&#123;<br>    System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-number">4</span> : mary<br><span class="hljs-number">2</span> : jack<br><span class="hljs-number">1</span> : tom<br><span class="hljs-number">3</span> : lucy<br><br></code></pre></td></tr></table></figure><h3 id="6-7-Map-的遍历"><a href="#6-7-Map-的遍历" class="headerlink" title="6.7 Map 的遍历"></a>6.7 Map 的遍历</h3><h4 id="6-7-1-遍历-key-值"><a href="#6-7-1-遍历-key-值" class="headerlink" title="6.7.1 遍历 key 值"></a>6.7.1 遍历 key 值</h4><p>使用 Map 接口中的 <code>keySet()</code> 方法，返回 Map 集合中所有的 key 值的 Set 集合。拿到 Set 集合后，遍历 Set 集合拿到 Map 中每个key值，通过 key 值可以获取到对应的 value 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>    map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  <br>    Set&lt;Integer&gt; keys = map.keySet();<br>    <span class="hljs-keyword">for</span>(Integer key : keys)&#123;<br>        System.out.println(key+<span class="hljs-string">&quot; : &quot;</span>+map.get(key));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="6-7-2-遍历-Value-值"><a href="#6-7-2-遍历-Value-值" class="headerlink" title="6.7.2 遍历 Value 值"></a>6.7.2 遍历 Value 值</h4><p>使用 Map 接口中的 <code>values()</code> 方法，返回 Map 集合中所有的 value 值的集合。但是通过该方式拿不到 value 值对应的 key 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>    map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br>  <br>    Collection values = map.values();<br>    <span class="hljs-keyword">for</span>(Object value : values)&#123;<br>      System.out.println(value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="6-7-3-使用-entrySet-方法"><a href="#6-7-3-使用-entrySet-方法" class="headerlink" title="6.7.3 使用 entrySet 方法"></a>6.7.3 使用 entrySet 方法</h4><p>Map 接口中有定义了一个内部接口 Entry（类似于内部类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span>&#123;<br>  <span class="hljs-comment">// ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-function">K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个 Entry 类型的对象，可以代表 Map 集合中的一组 key-value（键值对），并且提供了获取 key 值和 value 值的方法。</p><p>Map 接口中的 entrySet() 方法，就是将 Map 集合中的每一组 key-value（键值对）都封装成一个 Entry 类型对象，并且把这些个 Entry 对象存放到Set集合中，并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;lucy&quot;</span>);<br>    map.put(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;mary&quot;</span>);<br><br>    Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();<br>    <span class="hljs-keyword">for</span>(Map.Entry entry : entrySet)&#123;<br>      System.out.println(entry.getKey()+<span class="hljs-string">&quot; : &quot;</span>+entry.getValue());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="7-Collections-集合工具类"><a href="#7-Collections-集合工具类" class="headerlink" title="7. Collections 集合工具类"></a>7. Collections 集合工具类</h2><p><code>java.util.Collections</code> 是一个工具类，专门用来操作集合对象的，里面都是静态方法，可以直接调用。</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>fill()</code></td><td>使用指定元素替换指定列表中的所有元素。</td></tr><tr><td><code>max()</code></td><td>根据元素的自然顺序，返回给定集合的最大元素。</td></tr><tr><td><code>min()</code></td><td>根据元素的自然顺序，返回给定集合的最小元素。</td></tr><tr><td><code>revserse()</code></td><td>反转集合中的元素。</td></tr><tr><td><code>sort()</code></td><td>根据元素的自然顺序，对指定列表按升序进行排序。</td></tr><tr><td><code>shuffle()</code></td><td>使用默认随机源对指定列表进行置换。</td></tr><tr><td><code>addAll()</code></td><td>往集合中添加一些元素。</td></tr><tr><td><code>synchronizedCollection</code></td><td>把非线程安全的 Collection 类型集合，转为线程安全的集合。</td></tr><tr><td><code>synchronizedList</code></td><td>把非线程安全的List类型集合，转为线程安全的集合。</td></tr><tr><td><code>synchronizedSet</code></td><td>把非线程安全的Set类型集合，转为线程安全的集合。</td></tr><tr><td><code>synchronizedMap</code></td><td>把非线程安全的Map类型集合，转为线程安全的集合。</td></tr></tbody></table><ul><li><p><code>fill()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Collections.fill(list, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>max() &amp; min()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">9</span>);<br>list.add(<span class="hljs-number">3</span>);<br>System.out.println(Collections.max(list));<br>System.out.println(Collections.min(list));<br></code></pre></td></tr></table></figure></li><li><p><code>reverse()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">9</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Collections.reverse(list);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>sort()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">9</span>);<br>list.add(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//如果需要，也可以在第二个参数位置传一个比较器对象</span><br><span class="hljs-comment">//Collections.sort(list,c);</span><br>Collections.sort(list);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>shuffle()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">9</span>);<br>list.add(<span class="hljs-number">3</span>);<br>Collections.shuffle(list);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>addAll()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">//注意，addAll的第二个参数，是可变参数</span><br>Collections.addAll(list,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>);<br><span class="hljs-keyword">for</span>(Integer o:list)&#123;<br>System.out.println(o);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String 类</title>
    <link href="/2021/06/14/13.%20String%20%E7%B1%BB/"/>
    <url>/2021/06/14/13.%20String%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>String 类代表字符串。Java 程序中的所有字符串字面值都作为此类的实例实现。</p><span id="more"></span><h2 id="1-String-特点"><a href="#1-String-特点" class="headerlink" title="1. String 特点"></a>1. String 特点</h2><ul><li><p>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p></li><li><p><strong>String 类的值是 final 类型的</strong>，一旦声明则不可以改变，所以<strong>只要一个值改变就会生成一个新的 String 类型对象</strong>，但是原来的字符串还是存在的，并且产生垃圾。</p></li><li><p>String 底层使用一个字符数组来维护的。</p></li><li><p>存储 String 数据也不一定从数组的第 0 个元素开始的，而是从 offset 所指的元素开始。</p></li></ul><h2 id="2-创建字符串对象两种方式"><a href="#2-创建字符串对象两种方式" class="headerlink" title="2. 创建字符串对象两种方式"></a>2. 创建字符串对象两种方式</h2><h3 id="2-1-直接赋值方式创建对象"><a href="#2-1-直接赋值方式创建对象" class="headerlink" title="2.1 直接赋值方式创建对象"></a>2.1 直接赋值方式创建对象</h3><p>直接赋值方式创建对象是在方法区的常量池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;hello&quot;</span>;   <span class="hljs-comment">//直接赋值的方式</span><br></code></pre></td></tr></table></figure><h3 id="2-2-通过构造方法创建字符串对象"><a href="#2-2-通过构造方法创建字符串对象" class="headerlink" title="2.2 通过构造方法创建字符串对象"></a>2.2 通过构造方法创建字符串对象</h3><p>通过构造方法创建字符串对象是在堆内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//实例化的方式</span><br></code></pre></td></tr></table></figure><h3 id="2-3-两种创建方法的比较"><a href="#2-3-两种创建方法的比较" class="headerlink" title="2.3  两种创建方法的比较"></a>2.3  两种创建方法的比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);<br>        String str3 = str2;  <span class="hljs-comment">//引用传递，str3 直接指向 st2 的堆内存地址</span><br>        String str4 = <span class="hljs-string">&quot;hello&quot;</span>;<br>       <br>         System.out.println(str1==str2);  <span class="hljs-comment">//false</span><br>         System.out.println(str1==str3);  <span class="hljs-comment">//false</span><br>         System.out.println(str3==str2);  <span class="hljs-comment">//true</span><br>         System.out.println(str1==str4);  <span class="hljs-comment">//true</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在字符串中，如果采用直接赋值的方式（String str=”Lance”）进行对象的实例化，则会将匿名对象 “Lance” 放入对象池，<strong>每当下一次对不同的对象进行直接赋值的时候会直接利用池中原有的匿名对象</strong>，这样，所有直接赋值的String对象，如果利用相同的 “Lance” ，则 String对象 == 返回 true；</p><ul><li><p>直接赋值<code>String str = &quot;hello&quot;</code>：只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p></li><li><p>构造方法<code>String str =  new String(&quot;hello&quot;);</code>会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过<code>public  String intern();</code>方法进行手工入池。<strong>在开发的过程中不会采用构造方法进行字符串的实例化。</strong></p></li></ul><h2 id="3-和-equals"><a href="#3-和-equals" class="headerlink" title="3. == 和 equals"></a>3. == 和 equals</h2><p>==：</p><ul><li>基本数据类型：比较的是基本数据类型的值是否相同</li><li>引用数据类型：比较的是引用数据类型的地址值是否相同</li></ul><p>equals:</p><ul><li>equals比较的是字符串内容。</li><li>在开发的过程中，equals()通过接受参数，可以避免空指向。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">&quot;hello&quot;</span>))&#123;  <span class="hljs-comment">//此时会出现空指向异常</span><br>  ...<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;hello&quot;</span>.equals(str))&#123;  <span class="hljs-comment">//此时equals会处理null值，可以避免空指向异常</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h2><h3 id="4-1-String-的判断功能"><a href="#4-1-String-的判断功能" class="headerlink" title="4.1 String 的判断功能"></a>4.1 String 的判断功能</h3><ul><li><code>boolean equals(Object obj)</code>：比较字符串的内容是否相同。</li><li><code>boolean equalsIgnoreCase(String str)</code>： 比较字符串的内容是否相同，忽略大小写。</li><li><code>boolean startsWith(String str)</code>： 判断字符串对象是否以指定的 str 开头。</li><li><code>boolean endsWith(String str)</code>： 判断字符串对象是否以指定的 str 结尾。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>           <span class="hljs-comment">// 创建字符串对象</span><br>        String s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot;hello&quot;</span>;<br>        String s3 = <span class="hljs-string">&quot;Hello&quot;</span>;<br> <br>        <span class="hljs-comment">// boolean equals(Object obj):比较字符串的内容是否相同</span><br>        System.out.println(s1.equals(s2));<br>        System.out.println(s1.equals(s3));<br>        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);<br> <br>        <span class="hljs-comment">// boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span><br>        System.out.println(s1.equalsIgnoreCase(s2));<br>        System.out.println(s1.equalsIgnoreCase(s3));<br>        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);<br> <br>        <span class="hljs-comment">// boolean startsWith(String str):判断字符串对象是否以指定的str开头</span><br>        System.out.println(s1.startsWith(<span class="hljs-string">&quot;he&quot;</span>));<br>        System.out.println(s1.startsWith(<span class="hljs-string">&quot;lo&quot;</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-String-的获取功能"><a href="#4-2-String-的获取功能" class="headerlink" title="4.2 String 的获取功能"></a>4.2 String 的获取功能</h3><ul><li> <code>int length()</code>：获取字符串的长度，其实也就是字符个数。</li><li> <code>char charAt(int index)</code>：获取指定索引处的字符。</li><li> <code>int indexOf(String str)</code>：获取 str 在字符串对象中第一次出现的索引。</li><li> <code>String substring(int start)</code>：从 start 开始截取字符串。</li><li> <code>String substring(int start,int end)</code>：从 start 开始，到 end 结束截取字符串。包括 start，不包括 end。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>          <span class="hljs-comment">// 创建字符串对象</span><br>        String s = <span class="hljs-string">&quot;helloworld&quot;</span>;<br> <br>        <span class="hljs-comment">// int length():获取字符串的长度，其实也就是字符个数</span><br>        System.out.println(s.length());<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br> <br>        <span class="hljs-comment">// char charAt(int index):获取指定索引处的字符</span><br>        System.out.println(s.charAt(<span class="hljs-number">0</span>));<br>        System.out.println(s.charAt(<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br> <br>        <span class="hljs-comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引</span><br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;l&quot;</span>));<br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;owo&quot;</span>));<br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;ak&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br> <br>        <span class="hljs-comment">// String substring(int start):从start开始截取字符串</span><br>        System.out.println(s.substring(<span class="hljs-number">0</span>));<br>        System.out.println(s.substring(<span class="hljs-number">5</span>));<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br> <br>        <span class="hljs-comment">// String substring(int start,int end):从start开始，到end结束截取字符串</span><br>        System.out.println(s.substring(<span class="hljs-number">0</span>, s.length()));<br>        System.out.println(s.substring(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>));<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-String的转换功能"><a href="#4-3-String的转换功能" class="headerlink" title="4.3 String的转换功能"></a>4.3 String的转换功能</h3><ul><li><code>char[] toCharArray()</code>：把字符串转换为字符数组。</li><li><code>String toLowerCase()</code>：把字符串转换为小写字符串。</li><li><code>String toUpperCase()</code>：把字符串转换为大写字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>         <span class="hljs-comment">// 创建字符串对象</span><br>        String s = <span class="hljs-string">&quot;abcde&quot;</span>;<br> <br>        <span class="hljs-comment">// char[] toCharArray():把字符串转换为字符数组</span><br>        <span class="hljs-keyword">char</span>[] chs = s.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; chs.length; x++) &#123;<br>            System.out.println(chs[x]);<br>        &#125;<br> <br>        System.out.println(<span class="hljs-string">&quot;-----------&quot;</span>);<br> <br>        <span class="hljs-comment">// String toLowerCase():把字符串转换为小写字符串</span><br>        System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>.toLowerCase());<br>        <span class="hljs-comment">// String toUpperCase():把字符串转换为大写字符串</span><br>        System.out.println(<span class="hljs-string">&quot;HelloWorld&quot;</span>.toUpperCase());<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-其他常用方法"><a href="#4-4-其他常用方法" class="headerlink" title="4.4 其他常用方法"></a>4.4 其他常用方法</h3><ul><li><code>String trim()</code>：去除字符串两端空格。</li><li><code>String[] split(String str)</code>：按照指定符号分割字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>          <span class="hljs-comment">// 创建字符串对象</span><br>        String s1 = <span class="hljs-string">&quot;helloworld&quot;</span>;<br>        String s2 = <span class="hljs-string">&quot; helloworld &quot;</span>;<br>        String s3 = <span class="hljs-string">&quot; hello world &quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s1 + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s1.trim() + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s2 + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s2.trim() + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s3 + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;---&quot;</span> + s3.trim() + <span class="hljs-string">&quot;---&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-------------------&quot;</span>);<br> <br>        <span class="hljs-comment">// String[] split(String str)</span><br>        <span class="hljs-comment">// 创建字符串对象</span><br>        String s4 = <span class="hljs-string">&quot;aa,bb,cc&quot;</span>;<br>        String[] strArray = s4.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; strArray.length; x++) &#123;<br>            System.out.println(strArray[x]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-String-的不可变性"><a href="#5-String-的不可变性" class="headerlink" title="5. String 的不可变性"></a>5. String 的不可变性</h2><p><strong>String 类的值是 final 类型的</strong>，一旦声明则不可以改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String a = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String b = <span class="hljs-string">&quot;abc&quot;</span>;<br>        String c = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>        System.out.println(a==b);  <span class="hljs-comment">//true</span><br>        System.out.println(a.equals(b));  <span class="hljs-comment">//true</span><br>        System.out.println(a==c);  <span class="hljs-comment">//false</span><br>        System.out.println(a.equals(c));  <span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-1-内存分析"><a href="#5-1-内存分析" class="headerlink" title="5.1 内存分析"></a>5.1 内存分析</h3><p><img src="https://i.loli.net/2021/06/14/3nJWdZQxhqO6cMi.png" alt="String.png"></p><p>因为String太过常用，JAVA类库的设计者在实现时做了个小小的变化，即采用了享元模式，每当生成一个新内容的字符串时，他们都被添加到一个共享池中，当第二次再次生成同样内容的字符串实例时，就共享此对象，而不是创建一个新对象，但是这样的做法<strong>仅仅适合于通过 = 符号进行的初始化</strong>。　　</p><h3 id="5-2-String不可变的好处"><a href="#5-2-String不可变的好处" class="headerlink" title="5.2 String不可变的好处"></a>5.2 String不可变的好处</h3><ul><li>可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。</li><li>我们的程序中大量使用了 String 字符串，有可能是出于安全性考虑。</li><li>当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。</li></ul><h2 id="6-字符串常量池"><a href="#6-字符串常量池" class="headerlink" title="6. 字符串常量池"></a>6. 字符串常量池</h2><h3 id="6-1-字符串常量池概述"><a href="#6-1-字符串常量池概述" class="headerlink" title="6.1 字符串常量池概述"></a>6.1 字符串常量池概述</h3><ul><li><p>常量池表（Constant_Pool table）</p><p>​    Class文件中存储所有常量（包括字符串）的table。</p><p>​    这是Class文件中的内容，还不是运行时的内容，不要理解它是个池子，其实就是Class文件中的字节码指令。</p></li><li><p>运行时常量池（Runtime Constant Pool）　</p><p>​    JVM内存中方法区的一部分，这是运行时的内容。这部分内容（绝大部分）是随着JVM运行时候，从常量池转化而来，每个Class    对应一个运行时常量池。上一句中说绝大部分是因为：除了 Class中常量池内容，还可能包括动态生成并加入这里的内容。</p></li><li><p>字符串常量池（String Pool）</p></li></ul><p>​            这部分也在方法区中，但与运行时常量池不是一个概念，字符串常量池是 JVM 实例全局共享的，全局只有一个。</p><p>​            JVM 规范要求进入这里的String实例叫“被驻留的 interned string ”，各个JVM可以有不同的实现，HotSpot 是设置了一个哈希表            StringTable 来引用堆中的字符串实例，被引用就是被驻留。</p><h3 id="6-2-亨元模式"><a href="#6-2-亨元模式" class="headerlink" title="6.2 亨元模式"></a>6.2 亨元模式</h3><p>其实字符串常量池这个问题涉及到一个设计模式，叫“享元模式”，顾名思义 ——共享元素模式。</p><p>一个系统中如果有多处用到了相同的一个元素，那么我们应该只存储一份此元素，而让所有地方都引用这一个元素。Java中String部分就是根据享元模式设计的，而那个存储元素的地方就叫做“字符串常量池 - String Pool”</p><h3 id="6-3-详细分析"><a href="#6-3-详细分析" class="headerlink" title="6.3 详细分析"></a>6.3 详细分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;abc&quot;</span>;  <span class="hljs-comment">// 在常量池中</span><br><br>String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// 在堆上</span><br></code></pre></td></tr></table></figure><ul><li><p>当直接赋值时，字符串 “abc” 会被存储在常量池中，只有1份，此时的赋值操作等于是创建 0 个或 1 个对象。如果常量池中已经存在了 “abc”，那么不会再创建对象，直接将引用赋值给 str1；如果常量池中没有 “abc”，那么创建一个对象，并将引用赋值给 str1。</p></li><li><p>通过<code>new String(“abc”);</code>的形式又是如何呢？答案是 1 个或 2 个。当 JVM 遇到上述代码时，会先检索常量池中是否存在 “abc”，如果不存在 “abc” 这个字符串，则会先在常量池中创建这个一个字符串。然后再执行 new 操作，会在堆内存中创建一个存储 “abc” 的 String 对象，对象的引用赋值给 str2。此过程创建了2个对象。当然，如果检索常量池时发现已经存在了对应的字符串，那么只会在堆内创建一个新的String对象，此过程只创建了1个对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>答案是2个？还真不一定。之所以单独列出这个问题是想提醒大家一点：没有直接的赋值操作（str=“abc”），并不代表常量池中没有“abc”这个字符串。也就是说衡量创建几个对象、常量池中是否有对应的字符串，不仅仅由你是否创建决定，还要看程序启动时其他类中是否包含该字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span>;<br></code></pre></td></tr></table></figure><p>上面的问题涉及到字符串常量重载“+”的问题，当一个字符串由多个字符串常量拼接成一个字符串时，它自己也肯定是字符串常量。字符串常量的“+”号连接Java虚拟机会在程序编译期将其优化为连接后的值。</p><p>就上面的示例而言，在编译时已经被合并成“abcdef”字符串，因此，<strong>只会创建1个对象</strong>。并没有创建临时字符串对象abc和def，这样减轻了垃圾收集器的压力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String str = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;def&quot;</span>);<br></code></pre></td></tr></table></figure><p>创建了4个，5个，还是6个对象？</p><p>4个对象的说法：常量池中分别有 “abc” 和 “def”，堆中对象 new String(“def”) 和 “abcdef”。</p><p>这种说法对吗？不完全对，如果说上述代码创建了几个字符串对象，那么可以说是正确的。但上述的代码 Java 虚拟机在编译的时候同样会优化，会创建一个 StringBuilder 来进行字符串的拼接，实际效果类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;def&quot;</span>);<br><span class="hljs-keyword">new</span> StringBuilder().append(<span class="hljs-string">&quot;abc&quot;</span>).append(s).toString();<br></code></pre></td></tr></table></figure><p>很显然，多出了一个 StringBuilder 对象，上面的准确回答应该是创建了4个字符串对象和1个 StringBuilder 对象。</p>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String 类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Math 类</title>
    <link href="/2021/06/14/11.%20Math%20%E7%B1%BB/"/>
    <url>/2021/06/14/11.%20Math%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><span id="more"></span><h3 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h3><p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p><h3 id="1-abs"><a href="#1-abs" class="headerlink" title="1. abs()"></a>1. abs()</h3><p>返回参数的绝对值。参数可以是 int, float, long, double, short, byte类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = -<span class="hljs-number">80</span>;<br><span class="hljs-keyword">float</span> b = -<span class="hljs-number">90.0f</span>;<br><span class="hljs-keyword">double</span> c = -<span class="hljs-number">100</span>;<br><br>System.out.println(Math.abs(a));  <span class="hljs-comment">// 结果为 80</span><br>System.out.println(Math.abs(b));  <span class="hljs-comment">// 结果为 90.0</span><br>System.out.println(Math.abs(c));  <span class="hljs-comment">// 结果为 100.0</span><br></code></pre></td></tr></table></figure><h3 id="2-ceil"><a href="#2-ceil" class="headerlink" title="2. ceil()"></a>2. ceil()</h3><p>返回大于等于( &gt;= )给定参数的的最小整数，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.ceil(d));  <span class="hljs-comment">// 结果为 4.0</span><br>System.out.println(Math.ceil(f));  <span class="hljs-comment">// 结果为 -2.0</span><br></code></pre></td></tr></table></figure><h3 id="3-floor"><a href="#3-floor" class="headerlink" title="3. floor()"></a>3. floor()</h3><p>返回大于等于( &lt;= )给定参数的的最小整数，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.floor(d));  <span class="hljs-comment">// 结果为 3.0</span><br>System.out.println(Math.floor(f));  <span class="hljs-comment">// 结果为 -3.0</span><br></code></pre></td></tr></table></figure><h3 id="4-rint"><a href="#4-rint" class="headerlink" title="4. rint()"></a>4. rint()</h3><p>返回最接近参数的整数值，类型为 double。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">float</span> f = -<span class="hljs-number">2.4f</span>;<br><br>System.out.println(Math.rint(d));  <span class="hljs-comment">// 结果为 3.0</span><br>System.out.println(Math.rint(f));  <span class="hljs-comment">// 结果为 -2.0</span><br></code></pre></td></tr></table></figure><h3 id="5-round"><a href="#5-round" class="headerlink" title="5. round()"></a>5. round()</h3><p>返回一个最接近的 int、long 型值，四舍五入。参数为 float 或 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">double</span> a = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-keyword">double</span> b = <span class="hljs-number">3.5</span>;<br><span class="hljs-keyword">float</span> c = <span class="hljs-number">4.1f</span>;<br><span class="hljs-keyword">float</span> d = <span class="hljs-number">4.6f</span>;<br><br>System.out.println(Math.round(a)); <span class="hljs-comment">// 结果为 3</span><br>System.out.println(Math.round(b)); <span class="hljs-comment">// 结果为 4</span><br>System.out.println(Math.round(c)); <span class="hljs-comment">// 结果为 4</span><br>System.out.println(Math.round(d)); <span class="hljs-comment">// 结果为 5</span><br></code></pre></td></tr></table></figure><h3 id="6-max-amp-min"><a href="#6-max-amp-min" class="headerlink" title="6. max() &amp; min()"></a>6. max() &amp; min()</h3><ul><li><p>max() 方法用于返回两个参数中的最大值。</p></li><li><p>min() 方法用于返回两个参数中的最小值。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Math.max(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>));  <span class="hljs-comment">// 结果为 13   </span><br>System.out.println(Math.min(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>));  <span class="hljs-comment">// 结果为 24</span><br></code></pre></td></tr></table></figure><h3 id="7-次方运算"><a href="#7-次方运算" class="headerlink" title="7. 次方运算"></a>7. 次方运算</h3><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">exp()</td><td align="center">返回自然数底数e的参数次方。</td></tr><tr><td align="center">log()</td><td align="center">返回参数的自然数底数的对数值。</td></tr><tr><td align="center">sqrt()</td><td align="center">返回参数的算术平方根。</td></tr><tr><td align="center">pow()</td><td align="center">返回第一个参数的第二个参数次方。</td></tr></tbody></table><h3 id="8-三角函数"><a href="#8-三角函数" class="headerlink" title="8. 三角函数"></a>8. 三角函数</h3><table><thead><tr><th align="center">方法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">sin()</td><td align="center">返回指定 double 类型参数的正弦值。</td></tr><tr><td align="center">cos()</td><td align="center">返回指定 double 类型参数的余弦值。</td></tr><tr><td align="center">tan()</td><td align="center">返回指定 double 类型参数的正切值。</td></tr><tr><td align="center">asin()</td><td align="center">返回指定 double 类型参数的反正弦值。</td></tr><tr><td align="center">acos()</td><td align="center">返回指定 double 类型参数的反余弦值。</td></tr><tr><td align="center">atan()</td><td align="center">返回指定 double 类型参数的反正切值。</td></tr><tr><td align="center">atan2()</td><td align="center">用于将矩形坐标 (x, y) 转换成极坐标 (r, theta)，返回所得角 theta。</td></tr><tr><td align="center">toDegrees()</td><td align="center">将参数转化为角度。</td></tr><tr><td align="center">toRadians()</td><td align="center">将角度转换为弧度。</td></tr><tr><td align="center">random()</td><td align="center">返回一个随机数，随机数范围为 0.0 =&lt; Math.random &lt; 1.0。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math 类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内部类</title>
    <link href="/2021/06/14/9.%20%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2021/06/14/9.%20%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>内部类，不是在一个 java 源文件中编写俩个平行的类，而是在一个类的内部再定义另外的一个类。</p><span id="more"></span><h4 id="1-内部类的分类"><a href="#1-内部类的分类" class="headerlink" title="1. 内部类的分类"></a>1. 内部类的分类</h4><ul><li>成员内部类 </li><li>静态内部类 </li><li>局部内部类</li><li>匿名内部类</li></ul><h4 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2. 成员内部类"></a>2. 成员内部类</h4><p>在类中，可以定义成员方法、成员变量，除此之外，还可以定义成员内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberOuterClass</span></span>&#123;<br>  <span class="hljs-comment">//外部类的属性</span><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">//外部类的方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">/* 成员内部类 声明开始 */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberInnerClass</span></span>&#123;<br>      <span class="hljs-keyword">private</span> String name;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>  &#125;<br>  <span class="hljs-comment">/* 成员内部类 声明结束 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>成员内部类中，不能编写静态的属性和方法。</strong></p><p>当前这个代码，<strong>编译成功后，会生成俩个class文件</strong>，一个对应外部类，一个对应内部类。 编译生成的俩个class文件的名字分别为： MemberOuterClass.class 和 MemberOuterClass$MemberInnerClass.class</p><h5 id="2-1-成员内部类和外部类的相互访问"><a href="#2-1-成员内部类和外部类的相互访问" class="headerlink" title="2.1 成员内部类和外部类的相互访问"></a>2.1 成员内部类和外部类的相互访问</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberOuterClass</span> </span>&#123;<br>    <span class="hljs-comment">//外部类的属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-comment">//外部类的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>    <span class="hljs-comment">/* 成员内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberInnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>      <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;<br>          <span class="hljs-comment">//访问当前run方法中的参数name</span><br>            System.out.println(name);<br>          <br>            <span class="hljs-comment">//访问内部类自己的属性name</span><br>            System.out.println(<span class="hljs-keyword">this</span>.name);<br>          <br>            <span class="hljs-comment">//访问外部类的非静态属性</span><br>            System.out.println(MemberOuterClass.<span class="hljs-keyword">this</span>.name);<br>          <br>            <span class="hljs-comment">//访问外部类的静态属性</span><br>            System.out.println(MemberOuterClass.age);<br>          <br>            <span class="hljs-comment">//访问外部类的非静态方法</span><br>            MemberOuterClass.<span class="hljs-keyword">this</span>.run();<br>          <br>            <span class="hljs-comment">//访问外部类的静态方法</span><br>            MemberOuterClass.go();<br>        &#125;<br>&#125;<br><span class="hljs-comment">/* 成员内部类 声明结束 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="2-2-外部类访问成员内部类的属性和方法"><a href="#2-2-外部类访问成员内部类的属性和方法" class="headerlink" title="2.2 外部类访问成员内部类的属性和方法"></a>2.2 外部类访问成员内部类的属性和方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberOuterClass</span> </span>&#123;<br>  <br><span class="hljs-comment">//外部类的方法，访问成员内部类的属性和方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//需要创建内部类对象，然后才可以访问</span><br>      MemberInnerClass t = <span class="hljs-keyword">new</span> MemberInnerClass();<br>      System.out.println(t.name);<br>      System.out.println(t.age);<br>      t.run(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">/* 成员内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemberInnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-comment">/* 成员内部类 声明结束 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-在其他类中使用这个内部类"><a href="#2-3-在其他类中使用这个内部类" class="headerlink" title="2.3 在其他类中使用这个内部类"></a>2.3 在其他类中使用这个内部类</h5><p> 如果这个成员内部类不是 private 修饰的，那么在其他类中就可以访问到这个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.maxseal.demo;<br><span class="hljs-keyword">import</span> com.maxseal.demo.MemberOuterClass.MemberInnerClass;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MemberOuterClass moc = <span class="hljs-keyword">new</span> MemberOuterClass();<br>        MemberInnerClass mic = moc.<span class="hljs-function">new <span class="hljs-title">MemberInnerClass</span><span class="hljs-params">()</span></span>;<br>        mic.run(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这个内部类需要import导入，并且是 <code>外部类.内部类</code> 的形式导入。</p></li><li><p>在创建对象的时候，需要先创建出外部类对象，然后使用外部类对象再创建内部类对象。形式为： <code>外部类对象.new 内部类对象()</code>;</p></li></ul><h5 id="2-4-思考题"><a href="#2-4-思考题" class="headerlink" title="2.4 思考题"></a>2.4 思考题</h5><ol><li><p>类的内部除了嵌套另一个类之外，是否还可以嵌套接口？</p><p>可以，不仅类中可以嵌套接口，接口的内部也可以嵌套其他接口。</p></li><li><p>思考，什么情况下会使用内部类？</p><p>在对事物进行抽象的时候，若一个事物内部还包含其他事物，就可以考虑使用内部类这种结构。</p><p>例如，汽车（Car）中包含发动机（Engine） ，这时， Engine 类就可以考虑（非必须）使用内部类来描述，定义在 Car 类中的成员位置。这样设计，既可以表示 Car 和 Engine 的紧密联系的程度，也可以在 Engine 类中很方便的使用到 Car 里面的属性和方法。</p></li></ol><h4 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h4><p>静态内部类和成员内部类是类似的，只是这个内部类，多了static关键字进行修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticOuterClass</span></span>&#123;<br>    <span class="hljs-comment">/* 静态内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span></span>&#123;<br>    &#125;<br>    <span class="hljs-comment">/* 静态内部类 声明结束 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>静态内部类中，可以编写静态的属性和方法，另外在四种内部类中，只有静态内部类可以编写静态属性和方法。</p></li><li><p>编译生成的俩个class文件的名字分别为：StaticOuterClass.class 和<br>StaticOuterClass$StaticInnerClass.class</p></li></ul><h5 id="3-1-静态内部类访问外部类的属性和方法"><a href="#3-1-静态内部类访问外部类的属性和方法" class="headerlink" title="3.1 静态内部类访问外部类的属性和方法"></a>3.1 静态内部类访问外部类的属性和方法</h5><p>在静态内部类中<strong>访问不了外部类中的非静态属性和方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticOuterClass</span> </span>&#123;<br>    <span class="hljs-comment">//外部类的属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-comment">//外部类的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-comment">/* 静态内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;<br>            <span class="hljs-comment">//访问当前run方法中的参数name</span><br>            System.out.println(name);<br><br>            <span class="hljs-comment">//访问内部类自己的属性name</span><br>            System.out.println(<span class="hljs-keyword">this</span>.name);<br><br>            <span class="hljs-comment">//访问内部类自己的静态属性age</span><br>            System.out.println(age);<br><br>            <span class="hljs-comment">//静态内部类中，无法访问外部类的非静态属性和方法</span><br>            <span class="hljs-comment">//访问外部类的静态属性和方法</span><br>            System.out.println(StaticOuterClass.age);<br>            StaticOuterClass.go();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 静态内部类 声明结束 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-2-外部类访问静态内部类的属性和方法"><a href="#3-2-外部类访问静态内部类的属性和方法" class="headerlink" title="3.2 外部类访问静态内部类的属性和方法"></a>3.2 外部类访问静态内部类的属性和方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticOuterClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//外部类中，访问静态类中的静态属性</span><br>      System.out.println(StaticInnerClass.age);<br>      <br>      <span class="hljs-comment">//外部类中，访问静态内部类中的非静态属性和方法</span><br>      StaticInnerClass sic = <span class="hljs-keyword">new</span> StaticInnerClass();<br>      System.out.println(sic.name);<br>      sic.run(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-comment">/* 静态内部类 声明开始 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>    &#125;<br><span class="hljs-comment">/* 静态内部类 声明结束 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-在其他类中使用这个内部类"><a href="#3-3-在其他类中使用这个内部类" class="headerlink" title="3.3 在其他类中使用这个内部类"></a>3.3 在其他类中使用这个内部类</h5><p>如果这个静态内部类不是 private 修饰的，那么在其他类中就可以访问到这个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.briup.sync.StaticOuterClass.StaticInnerClass;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      StaticInnerClass sic = <span class="hljs-keyword">new</span> StaticInnerClass();<br>      sic.run(<span class="hljs-string">&quot;tom&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这个内部类需要 import 导入，并且是 <code>外部类.内部类</code>的形式导入。 </li><li>在创建对象的时候，直接使用这个静态内部类的名字即可：<code> new 静态内部类对象();</code> ，不再 需要依赖外部类对象了。</li></ul><h4 id="4-局部内部类"><a href="#4-局部内部类" class="headerlink" title="4. 局部内部类"></a>4. 局部内部类</h4><p>局部内部类，是另一种形式的内部，在声明在外部类的方法中，<strong>相当于方法中的局部变量的位置</strong>，它的<strong>作用范围只是在当前方法中</strong>。 </p><p><strong>局部内部类是最不常用的一种内部类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalOuterClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-comment">/* 局部内部类 声明开始 */</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span></span>&#123;&#125;<br>        <span class="hljs-comment">/* 局部内部类 声明结束 */</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-1-局部内部类访问外部的属性和方法"><a href="#4-1-局部内部类访问外部的属性和方法" class="headerlink" title="4.1 局部内部类访问外部的属性和方法"></a>4.1 局部内部类访问外部的属性和方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalOuterClass</span> </span>&#123;<br>    <span class="hljs-comment">//外部类的属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-comment">//外部类的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-comment">/* 局部内部类 声明开始 */</span><br>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span></span>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String name)</span></span>&#123;<br>              <span class="hljs-comment">//访问当前test方法中的参数name</span><br>              System.out.println(name);<br>            <br>              <span class="hljs-comment">//访问内部类自己的属性name</span><br>              System.out.println(<span class="hljs-keyword">this</span>.name);<br>            <br>              <span class="hljs-comment">/*注意，sayHello方法的参数name，无法访问，因为实在没有办法表示了，换成其他</span><br><span class="hljs-comment">              名字后，就可以访问了，不要叫name就行*/</span><br>            <br>              <span class="hljs-comment">//访问外部类的非静态属性</span><br>              System.out.println(LocalOuterClass.<span class="hljs-keyword">this</span>.name);<br>            <br>              <span class="hljs-comment">//访问外部类的非静态方法</span><br>              LocalOuterClass.<span class="hljs-keyword">this</span>.run();<br>            <br>              <span class="hljs-comment">//访问外部类的静态属性和方法</span><br>              System.out.println(LocalOuterClass.age);<br>              LocalOuterClass.go();<br>&#125;<br>&#125;<br><span class="hljs-comment">/* 局部内部类 声明结束 */</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>局部内部类中，<strong>访问当前方法中的变量，这个变量必须是final修饰的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span></span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-comment">/* 局部内部类 声明开始 */</span><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span></span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>          System.out.println(name);<br>          System.out.println(num);<br>      &#125;<br>   &#125;<br>  <span class="hljs-comment">/* 局部内部类 声明结束 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-2-外部类访问局部内部类的属性和方法"><a href="#4-2-外部类访问局部内部类的属性和方法" class="headerlink" title="4.2 外部类访问局部内部类的属性和方法"></a>4.2 外部类访问局部内部类的属性和方法</h5><p>局部内部类，只能在当前声明的方法中进行使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-comment">/* 局部内部类 声明开始 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span></span>&#123;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      &#125;<br>&#125;<br><span class="hljs-comment">/* 局部内部类 声明结束 */</span><br>  <br>    <span class="hljs-comment">//创建局部内部类对象</span><br>    LocalInnerClass lic = <span class="hljs-keyword">new</span> LocalInnerClass();<br>  <br>    <span class="hljs-comment">//对象访问属性</span><br>    System.out.println(lic.num);<br>  <br>    <span class="hljs-comment">//对象调用方法</span><br>    lic.test();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-匿名内部类"><a href="#5-匿名内部类" class="headerlink" title="5. 匿名内部类"></a>5. 匿名内部类</h4><p>匿名内部类，是一种没有名字的内部类，它是内部类的一种简化写法。在之后的代码中，匿名内部类是使用最多的一种内部类。 </p><p>在普通的代码中，使用一个接口的步骤如下： </p><ul><li>声明一个类，去实现这个接口 </li><li>实现这个接口中的抽象方法（重写） </li><li>在其他代码中，创建这个类的对象 </li><li>调用类中实现（重写）后的方法 </li></ul><p>其实，在这个过程中，我们的目的就是把接口中的抽象方法给实现（重写）了，最后再调用到这个实现 后（重写）的方法。 那么，使用匿名内部类，就可以把这个过程给给简化了，让我们更加方便的调用到实现（重写）后的方法！</p><h5 id="5-1-匿名类的格式"><a href="#5-1-匿名类的格式" class="headerlink" title="5.1 匿名类的格式"></a>5.1 匿名类的格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">父类或者接口类型 变量名 = <span class="hljs-keyword">new</span> 父类或者接口()&#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;;<br><span class="hljs-comment">//调用实现（重写）后的方法</span><br>变量名.method();<br></code></pre></td></tr></table></figure><h5 id="5-2-匿名类的两种形式"><a href="#5-2-匿名类的两种形式" class="headerlink" title="5.2 匿名类的两种形式"></a>5.2 匿名类的两种形式</h5><ul><li>利用一个父类，进行声明并创建匿名内部类对象，这个匿名内部类默认就是这个父类的子类型。</li><li>利用一个接口，进行声明并创建匿名内部类对象，这个匿名内部类默认就是这个接口的实现类。</li></ul><p>注意事项：</p><ul><li>匿名内部类必须依托于一个父类型或者一个接口。</li><li>匿名内部类在声明的同时，就必须创建出对象，否则后面就没法创建了。</li><li>匿名内部类中无法定义构造器。</li></ul><h5 id="5-3-利用父类型来声明并创建匿名内部类对象"><a href="#5-3-利用父类型来声明并创建匿名内部类对象" class="headerlink" title="5.3 利用父类型来声明并创建匿名内部类对象"></a>5.3 利用父类型来声明并创建匿名内部类对象</h5><p>如果利用父类型声明这个匿名内部类，那么这个匿名内部类默认就是这个父类型的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal animal = <span class="hljs-keyword">new</span> Animal()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类中的默认实现&quot;</span>);<br>            &#125;<br>  &#125;;<br>animal.run();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-4-利用接口来声明并创建匿名内部类对象"><a href="#5-4-利用接口来声明并创建匿名内部类对象" class="headerlink" title="5.4 利用接口来声明并创建匿名内部类对象"></a>5.4 利用接口来声明并创建匿名内部类对象</h5><p>如果利用接口声明这个匿名内部类，那么这个匿名内部类默认就是这个接口的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Action a = <span class="hljs-keyword">new</span> Action()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名内部类中的默认实现&quot;</span>);<br>        &#125;<br>&#125;;<br>a.run();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-内部类的选择"><a href="#6-内部类的选择" class="headerlink" title="6. 内部类的选择"></a>6. 内部类的选择</h4><p>假设现在已经确定了要使用内部类，那么一般情况下，该如何选择？ </p><ol><li><p>考虑这个内部类，如果需要反复的进行多次使用（必须有名字） 在这个内部类中，</p><ul><li><p>如果需要定义静态的属性和方法，选择使用静态内部类。</p></li><li><p>如果需要访问外部类的非静态属性和方法，选择使用成员内部类 。</p></li></ul></li><li><p>考虑这个内部类，如果只需要使用一次（可以没有名字） 选择使用匿名内部类 。</p></li><li><p>局部内部类，几乎不会使用。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内部类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>final 关键字</title>
    <link href="/2021/06/14/7.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/06/14/7.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>final 修饰符可以修饰类、方法和变量。</p><span id="more"></span><h5 id="1-final-变量"><a href="#1-final-变量" class="headerlink" title="1. final 变量"></a>1. final 变量</h5><ul><li><p>final 表示“最后的、最终的含义”，变量<strong>一旦赋值后，不能被重新赋值</strong>。被 final 修饰的实例变量<strong>必须显式指定初始值</strong>。</p></li><li><p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p></li><li><p>final 修饰的变量不会被默认初始化。</p></li></ul><h5 id="1-1-final-修饰局部变量："><a href="#1-1-final-修饰局部变量：" class="headerlink" title="1.1 final 修饰局部变量："></a>1.1 final 修饰局部变量：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a)</span></span>&#123;<br>  <span class="hljs-comment">//编译报错,不能再次赋值,传参的时候已经赋过了</span><br>  a = <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br>  a = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">//编译报错,不能再次赋值</span><br>  a = <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h5 id="1-2-final-修饰非静态成员变量"><a href="#1-2-final-修饰非静态成员变量" class="headerlink" title="1.2 final 修饰非静态成员变量"></a>1.2 final 修饰非静态成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明的同时赋值 </li><li>匿名代码块中赋值 </li><li>构造器中赋值，此时还有额外要求：<strong>类中出现的所有构造器都要赋值</strong>，否则报错。</li></ul><h5 id="1-3-final-修饰静态成员变量"><a href="#1-3-final-修饰静态成员变量" class="headerlink" title="1.3 final 修饰静态成员变量"></a>1.3 final 修饰静态成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>声明的同时赋值 </li><li>静态代码块中赋值</li></ul><h5 id="1-4-final-修饰引用类型的变量："><a href="#1-4-final-修饰引用类型的变量：" class="headerlink" title="1.4 final 修饰引用类型的变量："></a>1.4 final 修饰引用类型的变量：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Student s = <span class="hljs-keyword">new</span> Student();<br><span class="hljs-comment">//编译通过,可以修改s指向对象中的属性值</span><br>s.setName(<span class="hljs-string">&quot;tom&quot;</span>);<br>s.setName(<span class="hljs-string">&quot;zs&quot;</span>);<br><span class="hljs-comment">//编译报错,不能修改引用s指向的内存地址</span><br>s = <span class="hljs-keyword">new</span> Student();<br></code></pre></td></tr></table></figure><p>此时final指的是，引用s的<strong>指向的对象不能改变</strong>，但是<strong>可以使用s来操作当前指向的对象属性和方法</strong>。</p><h4 id="2-final-方法"><a href="#2-final-方法" class="headerlink" title="2. final 方法"></a>2. final 方法</h4><p>父类中的 final 方法<strong>可以被子类继承，但是不能被子类重写</strong>。声明 final 方法的主要目的是<strong>防止该方法的内容被修改</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-comment">//编译报错</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-final-类"><a href="#3-final-类" class="headerlink" title="3. final 类"></a>3. final 类</h4><p>用final修饰的类<strong>不能被继承</strong>，也就是说这个类是没有子类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Action</span></span>&#123;<br>&#125;<br><span class="hljs-comment">//编译报错</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Go</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Action</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>final 关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>abstract 关键字的使用</title>
    <link href="/2021/06/14/8.%20abstract%20%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/06/14/8.%20abstract%20%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>abstract 方法和类的使用方式和注意事项。</p><span id="more"></span><h4 id="1-abstract-关键字"><a href="#1-abstract-关键字" class="headerlink" title="1. abstract 关键字"></a>1. abstract 关键字</h4><p>abstract修饰符，可以修饰类、方法。</p><h4 id="1-1-abstract-方法"><a href="#1-1-abstract-方法" class="headerlink" title="1.1 abstract 方法"></a>1.1 abstract 方法</h4><ul><li><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p></li><li><p>抽象方法不能被声明成 final 和 static。</p></li><li><p><strong>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</strong></p></li><li><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p></li><li><p><strong>抽象方法的声明以分号结尾。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法的声明：public void test()</span><br><span class="hljs-comment">//方法的实现：&#123;&#125;</span><br><br><span class="hljs-comment">//这就是一个普通方法，既有方法的声明，又有方法的实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br><span class="hljs-comment">//这就是一个只有声明没有实现的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">//这样的方法需要使用abstract修饰符来修饰，说明它是一个抽象方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h4 id="1-2-abstract-类"><a href="#1-2-abstract-类" class="headerlink" title="1. 2 abstract 类"></a>1. 2 abstract 类</h4><ul><li><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了<strong>将来对该类进行扩充</strong>。</p></li><li><p>一个类不能同时被 abstract 和 final 修饰。</p></li><li><p><strong>如果一个类包含抽象方法，那么该类一定要声明为抽象类</strong>，否则将出现编译错误。</p></li><li><p><strong>抽象类可以包含抽象方法和非抽象方法</strong>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><span class="hljs-comment">//子类重写父类中的run方法，这时候就变得非常明确了，就是一只猫走路的方式</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;我是一只猫，我踮起脚尖，优雅的走着猫步&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>  <span class="hljs-comment">//子类重写父类中的run方法，这时候就变得非常明确了，就是一只狗走路的方式</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;我是一只狗，我迈开抓子，悠悠晃晃的走着&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//编译报错，抽象类不能实例化创建对象</span><br>  <span class="hljs-comment">//Animal animal = new Animal();</span><br>  <br>  <span class="hljs-comment">//声明父类的引用，准备使用多态</span><br>  Animal animal;<br>  <br>  <span class="hljs-comment">//指向子类对象</span><br>  animal = <span class="hljs-keyword">new</span> Cat();<br>  <br>  <span class="hljs-comment">//调用方法，子类重写，调用到重写后的方法</span><br>  animal.run();<br>  <br>  <span class="hljs-comment">//指向子类对象</span><br>  animal = <span class="hljs-keyword">new</span> Dog();<br>  <br>  <span class="hljs-comment">//调用方法，子类重写，调用到重写后的方法</span><br>  animal.run();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h4><ul><li><p>接口的内部主要就是<strong>封装了抽象方法和静态常量</strong>。</p></li><li><p>接口的定义和类很类似，但是接口需要使用 interface 关键字来定义。</p></li><li><p>接口最终也会被编译成.class文件。</p></li><li><p>接口里面的属性，默认就是 public static final 修饰的。</p></li><li><p>接口里面的方法，默认就是 public abstract 修饰的。</p></li><li><p>JDK8中，还允许在接口中编写静态方法和默认方法。</p></li><li><p>JDK9中，还允许在接口中编写私有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用interface关键字来定义接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br>  <span class="hljs-comment">//接口中的静态常量</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String OPS_MODE = <span class="hljs-string">&quot;auto&quot;</span>;<br>  <br>  <span class="hljs-comment">//接口中的抽象方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>  <br>  <span class="hljs-comment">//接口的抽象方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-1-接口实现"><a href="#2-1-接口实现" class="headerlink" title="2.1 接口实现"></a>2.1 接口实现</h5><ul><li>类和类之间的关系是继承，类和接口之间的关系是实现。</li><li>一个类只能继承一个类，但是<strong>能实现了一个或多个接口</strong>。</li><li><strong>一个类实现了接口，那么就要实现接口中所有的抽象方法，否则这个类自己就必须声明为抽象类。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//类实现接口，并且实现了接口中所有的抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mark</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">star</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//类实现接口，并且实现了接口中所有的抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span>, <span class="hljs-title">Mark</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">star</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="2-2-接口继承"><a href="#2-2-接口继承" class="headerlink" title="2.2 接口继承"></a>2.2 接口继承</h5><p>类和类之间是单继承，接口和接口之间是多继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现该接口的类，将具有run的功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runable</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实现该接口的类，将具有fly的功能</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实现该接口的类，将具有run的功能，fly的功能，以及Action接口独有的doSomething功能</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Runable</span>,<span class="hljs-title">Flyable</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//实现类，实现Action接口，就必须要实现Action及其父接口中的所有抽象方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h5 id="2-3-接口的引用指向它的实现类对象"><a href="#2-3-接口的引用指向它的实现类对象" class="headerlink" title="2.3 接口的引用指向它的实现类对象"></a>2.3 接口的引用指向它的实现类对象</h5><p>多态的前提是继承，必须要先有子父类关系才行，而类和接口之间的实现关系，其实也是继承的一 种形式，所以在类和接口的实现关系中，也可以使用多态。</p><p>接口的引用指向它的实现类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Action</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Action</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentTest</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-comment">//声明接口的引用</span><br>      Action a;<br>      <span class="hljs-comment">//可以指向它任意一个实现类对象</span><br>      a = <span class="hljs-keyword">new</span> Student();<br>      a = <span class="hljs-keyword">new</span> Teacher();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static 关键字</title>
    <link href="/2021/06/14/6.%20static%20%E5%85%B3%E9%94%AE%E5%AD%97%20/"/>
    <url>/2021/06/14/6.%20static%20%E5%85%B3%E9%94%AE%E5%AD%97%20/</url>
    
    <content type="html"><![CDATA[<p>static修饰符可以修饰属性、方法、代码块。</p><span id="more"></span><h3 id="1-静态变量"><a href="#1-静态变量" class="headerlink" title="1. 静态变量"></a>1. 静态变量</h3><p>静态变量是属于类的，<strong>可以直接使用类名来访问</strong>，也可以使用对象访问，但推荐使用类名访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Demo.num = <span class="hljs-number">10</span>; <span class="hljs-comment">// 可以使用类名来访问</span><br>    Demo demo = <span class="hljs-keyword">new</span> Demo();<br>    demo.num = <span class="hljs-number">20</span>; <span class="hljs-comment">// 也可以对象来访问，但不推荐</span><br>&#125;<br></code></pre></td></tr></table></figure><p>static 关键字用来声明独立于对象的静态变量，<strong>无论一个类实例化多少对象，它的静态变量只有一份拷贝</strong>。 静态变量也被称为类变量、静态属性。<strong>局部变量不能被声明为静态变量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Demo.num = <span class="hljs-number">10</span>;<br>    Demo demo1 = <span class="hljs-keyword">new</span> Demo();<br>    Demo demo2 = <span class="hljs-keyword">new</span> Demo();<br>    System.out.println(demo1.num);<span class="hljs-comment">//输出结果为 10</span><br>    System.out.println(demo2.num);<span class="hljs-comment">//输出结果为 10</span><br>    Demo.num = <span class="hljs-number">20</span>;<br>   System.out.println(demo1.num);<span class="hljs-comment">//输出结果为 20</span><br>    System.out.println(demo2.num);<span class="hljs-comment">//输出结果为 20</span><br>    demo1.num = <span class="hljs-number">30</span>;<br>    System.out.println(demo1.num);<span class="hljs-comment">//输出结果为 30</span><br>    System.out.println(demo2.num);<span class="hljs-comment">//输出结果为 30</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-静态变量的初始化"><a href="#2-静态变量的初始化" class="headerlink" title="2. 静态变量的初始化"></a>2. 静态变量的初始化</h3><ul><li>非静态变量：<strong>创建对象后，系统会自动给对象中的非静态变量做初始化赋默认值</strong>，也正是因为这个原因，非静态变量只有在创建对象后，使用对象才能访问。 </li><li>静态变量：<strong>类加载到内存中（方法区）的时候，系统就会给类中的静态变量做初始化赋默认值</strong>，所以，即使还没有创建对象，只要这个类加载到了内存，就可以直接使用类名来访问静态变量，因为这个时候静态变量已经完成了初始化赋默认值的操作。</li></ul><h3 id="3-静态变量的存储位置"><a href="#3-静态变量的存储位置" class="headerlink" title="3. 静态变量的存储位置"></a>3. 静态变量的存储位置</h3><p>类中的静态变量，跟随着类，一起<strong>保存在内存中的方法区</strong>。当创建对象的时候，对象中只会保存类中定义的非静态变量的信息，而<strong>静态变量是不会进入到对象中</strong>的。即<strong>静态变量依赖于类，与对象无关</strong>。</p><img src="D:\Users\MaxSeal\Desktop\杰普实训\corejava\笔记\图片\static变量初始化.png" style="zoom: 67%;" /><ul><li>Demo类，被加载到内存的时候，静态变量 num 已经完成了默认的初始化赋值操作。</li><li>可以通过类名（Demo.num）来访问，它可以直接找到方法区中存储的静态变量 num 。</li><li>可以通过对象（demo.num）来访问，引用 demo 先找到堆区中的对象，再根据对象中存储的 Demo.class 信息，找到方法区中存储的静态变量 num 。</li><li>无论使用类名还是使用对象来访问静态变量 num，都是访问的同一个 num，但是官方推荐的是使用类名来访问更加合适。</li></ul><h3 id="4-静态方法"><a href="#4-静态方法" class="headerlink" title="4. 静态方法"></a>4. 静态方法</h3><p>static 关键字用来声明独立于对象的静态方法，即可以使用 类名.方法名的方式进行调用。<strong>静态方法不能使用类的非静态变量和方法，也不能使用 this 关键字</strong>。在类加载完成的时候，往往在内存中，还没有创建这个类的对象，没有对象（也就没有this）就不能访问类中的非静态属性和非静态方法。 正是因为这个原因，在静态方法中，才不能直接调用类中非静态属性和非静态方法。</p><p><strong>静态方法用来封装一些不需要依赖对象的功能。</strong></p><p><strong>静态方法也是可以被继承的，可以被子类调用，但不能被重写（但能被再次声明）。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  Demo.test();<span class="hljs-comment">//推荐的方式：类名.方法名</span><br>  Demo demo = <span class="hljs-keyword">new</span> Demo();<br>  demo.test();<span class="hljs-comment">//可以调用，但是不推荐</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;<br><span class="hljs-keyword">public</span> String num;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.num = <span class="hljs-number">10</span>;    <span class="hljs-comment">//编译报错，静态方法中不能使用非静态变量</span><br>        <span class="hljs-keyword">this</span>.sayHello();  <span class="hljs-comment">//编译报错</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>思考题：能否在构造器里对静态变量进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>&#123;<br>  num = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 不会报错</span><br>  &#125;<br>&#125;  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  System.out.println(Demo.num); <span class="hljs-comment">//输出结果为 0</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看出，虽然在构造器中给 num 赋值为10，但是在访问 num 的时候，看到的结果却是 0。这是因为，构造器是在创建对象的时候调用的，而在上面的代码中，我们并没有创建对象，而是直接使用类名访问了这个 num 属性，那么构造器中的代码也就没有执行，所以最后看到的结果是 0。</p><p>类中的构造器，可以给非静态属性做初始化，但是不能给静态属性做初始化。因为我们可以绕过创建对象的步骤，直接使用类名访问这个静态属性。</p><h3 id="5-静态代码块"><a href="#5-静态代码块" class="headerlink" title="5. 静态代码块"></a>5. 静态代码块</h3><p>静态代码块，也叫做静态初始化代码块，它的作用就是给类中的静态属性做初始化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num;<br>  <span class="hljs-keyword">static</span>&#123;<br>  num = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>System.out.println(Demo.num); <span class="hljs-comment">//输出结果为 10</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>静态代码块的执行时刻：由于静态代码块没有名字，我们并不能主动调用，<strong>它会在类加载的时候，自动执行</strong>。 所以静态代码块，可以更早的给类中的静态属性，进行初始化赋值操作。 并且，<strong>静态代码块只会自动被执行一次</strong>，因为JVM在一次运行中，对一个类只会加载一次！</p><h3 id="6-匿名代码块"><a href="#6-匿名代码块" class="headerlink" title="6. 匿名代码块"></a>6. 匿名代码块</h3><p>和静态代码块类似的，还有一种非静态代码块，也叫做匿名代码块，它的作用是给非静态属性做初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num;<br>  <br>  &#123;<br>  num = <span class="hljs-number">10</span>;<br>  &#125;<br>  <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Demo demo = <span class="hljs-keyword">new</span> Demo();<br>    System.out.println(demo.num);<span class="hljs-comment">//输出结果为 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类中的构造器，既能给非静态属性进行初始化，又能配合new关键字进行对象的创建，所以匿名代码块使用的场景较少，它能完成的工作，使用构造器也一样可以完成。</p><p>匿名代码块执行的时刻： 由于匿名代码块没有名字，我们并不能主动调用，它会在<strong>创建对象的时候，构造器执行之前</strong>，自动执行。 并且<strong>每次创建对象之前，匿名代码块都会被自动执行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-comment">// 静态代码块</span><br>  <span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;静态代码块执行&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 匿名代码块</span><br>  &#123;<br>    System.out.println(<span class="hljs-string">&quot;匿名代码块执行&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 构造器</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;构造器执行&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>  <span class="hljs-keyword">new</span> Demo();<br>  <span class="hljs-keyword">new</span> Demo();<br>&#125;<br><span class="hljs-comment">// 静态代码执行了一次，因为JVM只会加载Demo类一次，而匿名代码块会在每次创建对象的时候，先执行，然后再执行构造器。</span><br></code></pre></td></tr></table></figure><h3 id="7-创建和初始化对象的过程"><a href="#7-创建和初始化对象的过程" class="headerlink" title="7. 创建和初始化对象的过程"></a>7. 创建和初始化对象的过程</h3><p> <code>Student s = new Student(); </code>以这句代码为例进行说明： </p><ol><li><p>对 Student 类进行类加载，同时初始化类中静态的属性赋默认值，给静态方法分配内存空间。</p></li><li><p>执行类中的静态代码块。</p></li><li><p>堆区中分配对象的内存空间，同时初始化对象中的非静态的属性赋默认值。</p></li><li><p>调用 Student 的父类构造器。</p></li><li><p>对 Student 中的属性进行显示赋值。 </p></li><li><p>执行匿名代码块（如有多个匿名块，执行顺序与匿名块的顺序有关，且后面执行的会覆盖前面的）。</p></li><li><p>执行构造器，把对象的内存地址赋给变量 s。</p></li></ol><h3 id="8-静态导入"><a href="#8-静态导入" class="headerlink" title="8. 静态导入"></a>8. 静态导入</h3><p>在自己的类中，要使用另一个类中的静态属性和静态方法，那么可以进行静态导入，导入完成后， 可以直接使用这个类中的静态属性和静态方法，而不用在前面加上类名。<strong>只有JDK1.5及以上版本，才可以使用静态导入。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.PI;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(PI);<br>      System.out.println(random());<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类</title>
    <link href="/2021/06/08/3.%20%E7%B1%BB/"/>
    <url>/2021/06/08/3.%20%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>类是一个模板，它描述一类对象的行为和状态。</p><span id="more"></span><h4 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h4><ul><li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li><li><strong>对象</strong>：对象是类的一个实例，有状态和行为。</li></ul><h4 id="2-类中的变量类型"><a href="#2-类中的变量类型" class="headerlink" title="2.  类中的变量类型"></a>2.  类中的变量类型</h4><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，<strong>方法结束后，变量就会自动销毁</strong>。</li><li><strong>成员变量（属性、实例变量）</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量（静态变量）</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 学生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-comment">// 属性、实例变量</span><br>  String name;<br>  <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">// 类变量 （即加了 static 的属性）</span><br>  <span class="hljs-keyword">static</span> String schoolName;<br>  <br>  <span class="hljs-comment">// 方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(String book)</span></span>&#123;<br>    <span class="hljs-comment">// book 就是局部变量</span><br>    System.out.println(<span class="hljs-string">&quot;name:&quot;</span> + name + <span class="hljs-string">&quot;在学习&quot;</span> + book);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h4><p>方法定义在类中，属于类的成员，所以也可以叫做成员方法。</p><h5 id="3-1-方法定义的格式"><a href="#3-1-方法定义的格式" class="headerlink" title="3.1 方法定义的格式"></a>3.1 方法定义的格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li><li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li></ul><h4 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4. 构造方法"></a>4. 构造方法</h4><h5 id="4-1-构造方法的特点"><a href="#4-1-构造方法的特点" class="headerlink" title="4.1 构造方法的特点"></a>4.1 构造方法的特点</h5><ul><li><p>当一个对象被创建时候，构造方法用来初始化该对象。<strong>构造方法和它所在类的名字相同，但构造方法没有返回值。</strong></p></li><li><p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p></li><li><p>不管你是否自定义构造方法，<strong>所有的类都有构造方法</strong>，因为 <strong>Java 自动提供了一个默认构造方法</strong>，默认构造方法的访问修饰符和类的访问修饰符相同。</p></li><li><p><strong>一旦定义了自己的构造方法，默认构造方法就会失效。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个简单的构造函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br> <br>  <span class="hljs-comment">// 以下是构造函数</span><br>  MyClass() &#123;<br>    x = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-构造方法的作用"><a href="#4-2-构造方法的作用" class="headerlink" title="4.2 构造方法的作用"></a>4.2 构造方法的作用</h5><ul><li>使用 new 关键字来创建对象的时候，后面跟的必须是类中存在的构造方法。</li><li>构造方法中的代码，在对象创建后会被调用，从而可以完成对象的初始化工作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">//构造方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//创建对象的时候使用构造方法</span><br>    <span class="hljs-comment">//并且传参到构造方法中，构造方法中可以使用这些参数给属性进行初始化</span><br>    Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-默认构造方法"><a href="#4-3-默认构造方法" class="headerlink" title="4.3 默认构造方法"></a>4.3 默认构造方法</h5><p>即使在类中没有定义构造方法，那么在编译之后，也会自动的生成一个无参构造方法，并且构造方法中不执行任何代码。这个无参构造方法就被称为默认的构造方法。 我们也可以主动在类中定义出这个无参的默认构造方法。<strong>一旦定义了自己的构造方法，默认构造方法就会失效。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">//这个构造方法即使没有写出来，编译后也会自动生成的</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-4-构造方法的重载"><a href="#4-4-构造方法的重载" class="headerlink" title="4.4 构造方法的重载"></a>4.4 构造方法的重载</h5><p>除了默认的无参构造方法之外，在类中还可以对构造方法进行重载，让构造方法可以接收一些参数，然后使用这些参数进行对象的初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">//无参构造方法</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">//有参数构造方法，接收参数，进行对象属性的初始化</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.age = age;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.age = age;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-5-构造器之间的调用"><a href="#4-5-构造器之间的调用" class="headerlink" title="4.5 构造器之间的调用"></a>4.5 构造器之间的调用</h5><p>使用this关键字，可以在构造器中，调用另一个构造器。不能存在死循环（递归调用）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>    <span class="hljs-comment">//无参构造器</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//调用俩参的构造器</span><br>        <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-number">20</span>);   <span class="hljs-comment">// this 必须作为第一行代码。</span><br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-comment">//调用俩参的构造器</span><br>        <span class="hljs-keyword">this</span>(name,<span class="hljs-number">0</span>)<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-comment">//调用俩参的构造器</span><br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>,age);<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-参数传递"><a href="#5-参数传递" class="headerlink" title="5. 参数传递"></a>5. 参数传递</h4><h5 id="5-1-参数类型"><a href="#5-1-参数类型" class="headerlink" title="5.1 参数类型"></a>5.1 参数类型</h5><p>java方法的参数，分为形参和实参。 </p><ul><li><p>形参：形式上的参数，作用是接收外部传过来的实际参数的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;...&#125;<br><span class="hljs-comment">// a 就是一个形参。</span><br></code></pre></td></tr></table></figure></li><li><p>实参：调用方法时实际上传递的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Test t = <span class="hljs-keyword">new</span> Test();<br>      t.test(<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// x 就是一个实参。</span><br>      t.test(x);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="5-2-值传递"><a href="#5-2-值传递" class="headerlink" title="5.2 值传递"></a>5.2 值传递</h5><p><strong>方法的参数是基本类型</strong>，调用方法并传参，这时候进行的是值传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">//该方法中，改变参数当前的值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    a = <span class="hljs-number">10</span>;<br>  &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    System.out.println(<span class="hljs-string">&quot;before: a = &quot;</span> + a);<span class="hljs-comment">//传参之前，变量a的值，结果为 1。</span><br>    changeNum(a);<br>    System.out.println(<span class="hljs-string">&quot;after: a = &quot;</span> + a);<span class="hljs-comment">//传参之后，变量a 的值，结果仍然为 1。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>值传递，实参把自己存储的值（基本类型都是简单的数字）赋值给形参，之后形参如何操作，对实参一点影响没有。</strong></p><h5 id="5-3-引用传递"><a href="#5-3-引用传递" class="headerlink" title="5.3 引用传递"></a>5.3 引用传递</h5><p><strong>方法的参数是引用类型</strong>，调用方法并传参，这时候进行的是引用传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  String name;<br>  String age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">// 该方法中，改变引用 s 所指向对象的 name 属性值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeName</span><span class="hljs-params">(Student s)</span></span>&#123;<br>  s.name = <span class="hljs-string">&quot;tom&quot;</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    s.name = <span class="hljs-string">&quot;seal&quot;</span><br>    System.out.println(<span class="hljs-string">&quot;before: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之前，引用 s 所指向对象的 name 属性值，结果为 seal。</span><br>    changeName(s);<br>    System.out.println(<span class="hljs-string">&quot;after: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之后，引用 s 所指向对象的 name 属性值，结果为 tom。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br><span class="hljs-comment">// 该方法中，改变引用s所指向对象的 name 属性值。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeName</span><span class="hljs-params">(Student s)</span></span>&#123;<br>  s = <span class="hljs-keyword">new</span> Student();<br>    s.name = tom;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    Student s = <span class="hljs-keyword">new</span> Student();<br>    s.name = <span class="hljs-string">&quot;seal&quot;</span><br>    System.out.println(<span class="hljs-string">&quot;before: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之前，引用s所指向对象的name属性值，结果为 seal。</span><br>    changeName(s);<br>    System.out.println(<span class="hljs-string">&quot;after: name = &quot;</span>+s.name); <span class="hljs-comment">// 传参之后，引用s所指向对象的name属性值，结果为 seal。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于引用传递，是实参将自己存储的对象地址，赋值给了形参，这时候俩个引用（实参和形参）指 向了同一个对象，那么任何一个引用（实参或形参）操作对象，例如属性赋值，那么另一个引用 （形参或实参）都可以看到这个对象中属性的变量，因为俩个引用指向同一个对象。</p><h4 id="6-this-关键字"><a href="#6-this-关键字" class="headerlink" title="6. this 关键字"></a>6. this 关键字</h4><p>在类中的非静态方法中，可以使用this关键，来表示当前类将来的一个对象。</p><h5 id="6-1-使用场景"><a href="#6-1-使用场景" class="headerlink" title="6.1 使用场景"></a>6.1 使用场景</h5><ul><li>区别成员变量和局部变量</li><li>调用类中的其他方法 </li><li>调用类中的其他构造方法</li></ul><h5 id="6-2-区别成员变量和局部变量"><a href="#6-2-区别成员变量和局部变量" class="headerlink" title="6.2 区别成员变量和局部变量"></a>6.2 区别成员变量和局部变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-comment">// = 号左边的 this.name，表示类中的属性 name</span><br>    <span class="hljs-comment">// = 号右边的 name，表示当前方法的参数 name（就近原则）</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-3-调用类中的其它方法"><a href="#6-3-调用类中的其它方法" class="headerlink" title="6.3 调用类中的其它方法"></a>6.3 调用类中的其它方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//表示调用当前类中的 setName 方法</span><br>    <span class="hljs-comment">// 默认情况下，setName(&quot;tom&quot;) 和 this.setName(&quot;tom&quot;) 的效果是一样的，所以这里也可以省去 this.</span><br>      <span class="hljs-keyword">this</span>.setName(<span class="hljs-string">&quot;tom&quot;</span>);   <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-4-调用类中的其他构造方法"><a href="#6-4-调用类中的其他构造方法" class="headerlink" title="6.4 调用类中的其他构造方法"></a>6.4 调用类中的其他构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//调用一个参数的构造方法,参数的类型是 String</span><br>    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>this 的这种调用构造方法的用法，<strong>只能在类中的一个构造方法，调用另一个构造方法</strong>。并且不能在普通的方法中调用类的构造方法。 并且要求，<strong>this 调用构造方法的代码，是当前构造方法中的第一句代码</strong>，否则编译报错。</p><h5 id="6-5-思考题"><a href="#6-5-思考题" class="headerlink" title="6.5 思考题"></a>6.5 思考题</h5><p>如果这时候创建俩个对象，那么this又代表哪一个对象呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.show(); <span class="hljs-comment">//问题：这个 this 代表的是 stu1 还是 stu2</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Student stu1 = <span class="hljs-keyword">new</span> Student();<br>        stu1.sayHello();<br>        Student stu2 = <span class="hljs-keyword">new</span> Student();<br>        stu2.sayHello();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="D:\Users\MaxSeal\Desktop\杰普实训\corejava\上课笔记\图片\this思考题.png" style="zoom:80%;" /><p>其实每一个对象中，都有自己的this，和其他对象中的互不影响。</p><p><strong>方法被哪个对象调用，方法中的this就代表那个对象。</strong>即谁在调用，this就代表谁。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2021/06/08/4.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/06/08/4.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>面向对象思想，是一种程序设计思想，使用这种思想进行编程的语言，就是面向对象编程语言。</p><span id="more"></span><h4 id="1-面向对象-OOP"><a href="#1-面向对象-OOP" class="headerlink" title="1. 面向对象 OOP"></a>1. 面向对象 OOP</h4><ul><li><p>OOP（object oriented programming），面向对象编程把构成问题的各种事物，抽象成各个对象，这些对象具有解决问题的行为（方法），同时对象还可以具有解决很多类似问题的行为（方法），而不只是能解决一个问题。</p></li><li><p>POP（procedure oriented Programming），面向过程编程分析出，解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，然后依次调用就可以了。</p></li><li><p>FP（functional programming)，函数式编程类似于面向过程的程序设计方式，具有很高的抽象程度。JDK8中的一些特性，可以支持使用函数式编程。</p><p>面向对象的特点：封装、继承和多态。     </p></li></ul><p>​       面向对象思想，是一种程序设计思想，使用这种思想进行编程的语言，就是面向对象编程语言。面向对象中的对象，泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，定义为程序中的一种数据类型。 面向对象的思想，主要强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p><h4 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h4><p>​       封装是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。<strong>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</strong>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全。</p><h5 id="2-1-封装的优点"><a href="#2-1-封装的优点" class="headerlink" title="2.1 封装的优点"></a>2.1 封装的优点</h5><ul><li>提高代码的安全性，重要信息可以私有化，不对外暴露。</li><li>提高代码的复用性，常用的代码或者功能封装到方法中，可以在其他地方反复调用。</li><li>封装代码的实现细节，便于修改内部代码，提高可维护性。</li><li>简化外部的调用，便于调用者使用。</li></ul><h5 id="2-2-例子"><a href="#2-2-例子" class="headerlink" title="2.2  例子"></a>2.2  例子</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-comment">//使用 private 关键字来修饰属性，不允许外部直接访问该属性。</span><br>    <span class="hljs-keyword">private</span> String name;<br>  <br>    <span class="hljs-comment">//提供公共的 setName 方法，可以让外部调用该方法给 name 属性赋值。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>  <br>    <span class="hljs-comment">//提供公共的 getName 方法，可以让外部调用该方法获取 name 属性的值。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h4><p>​        继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><h5 id="3-1-继承的类型"><a href="#3-1-继承的类型" class="headerlink" title="3.1 继承的类型"></a>3.1 继承的类型</h5><p>![](D:\Users\MaxSeal\Desktop\杰普实训\corejava\笔记\图片\7. 对象和类\继承的类型.png)</p><h5 id="3-2-继承的特性"><a href="#3-2-继承的特性" class="headerlink" title="3.2 继承的特性"></a>3.2 继承的特性</h5><ul><li>子类<strong>继承了父类的非 private 的属性和方法，但没有继承父类的构造器</strong>。</li><li><strong>子类可以拥有自己的属性和方法</strong>，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法（重写）。</li><li><strong>Java 的继承是单继承，但是可以多重继承</strong>，这是 Java 继承区别于 C++ 继承的一个特性。</li><li><strong>提高了类之间的耦合性</strong>（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li><li><strong>所有类都直接或间接地继承了 Object 类</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义Person类，作为父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>  <br>  <span class="hljs-comment">// 父类的构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;hello~ I am &quot;</span>+name);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义Student类，作为子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <br> <span class="hljs-comment">//这个是子类中单独定义的方法，和父类无关</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hi</span><span class="hljs-params">()</span></span>&#123;<br>        name = <span class="hljs-string">&quot;jack&quot;</span>;  <span class="hljs-comment">//访问从父类中继承过来的方法</span><br>        sayHello();     <span class="hljs-comment">//调用从父类中继承过来的方法</span><br>        age = <span class="hljs-number">20</span>;       <span class="hljs-comment">//编译报错，age是父类中的私有属性，子类中不能访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-super-关键字"><a href="#4-super-关键字" class="headerlink" title="4. super 关键字"></a>4. super 关键字</h4><p>子类继承父类，<strong>创建子类对象的时候，会先默认调用父类的构造器</strong>。因为子类继承父类，会继承父类的属性和方法，那么就需要先调用父类的构造器对父类中的属性进行初始化，初始化完成后再给子类使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义Person类，作为父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Person类中的构造器被调用&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//定义Student类，作为子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Student类中的构造器被调用&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br><span class="hljs-keyword">new</span> Student();<br>&#125;<br><span class="hljs-comment">// main 方法执行会输出以下语句：</span><br><span class="hljs-comment">// Person类中的构造器被调用</span><br><span class="hljs-comment">// Student类中的构造器被调用</span><br></code></pre></td></tr></table></figure><p>在子类中，使用super关键字一般做以下事情： 访问父类中的属性、调用父类中的方法、调用父类中的构造器。</p><h5 id="4-1-访问父类中的属性"><a href="#4-1-访问父类中的属性" class="headerlink" title="4.1 访问父类中的属性"></a>4.1 访问父类中的属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>String name = <span class="hljs-string">&quot;zs&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-comment">//注意，这里是故意和父类中的属性重名</span><br>    String name = <span class="hljs-string">&quot;lisi&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//直接使用 name，表示 Student 中的 name 属性（就近原则）</span><br>      System.out.println(name);<br>      <span class="hljs-comment">//也可以使用 this 和 super 来区分访问的是哪个 name</span><br>      System.out.println(<span class="hljs-keyword">this</span>.name);  <span class="hljs-comment">//Student 中的 name</span><br>      System.out.println(<span class="hljs-keyword">super</span>.name); <span class="hljs-comment">//父类 Person 中的 name</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-2-调用父类中的方法"><a href="#4-2-调用父类中的方法" class="headerlink" title="4.2 调用父类中的方法"></a>4.2 调用父类中的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;person run..&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-comment">//注意，这里是故意和父类中的方法重名</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;student run..&quot;</span>);<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//直接使用 name，表示 Student 中的 run 方法（就近原则）</span><br>        run();<br>        <span class="hljs-comment">//也可以使用 this 和 super 来区分调用的是哪个 run 方法</span><br>        <span class="hljs-keyword">this</span>.run();<br>        <span class="hljs-keyword">super</span>.run();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-3-调用父类中的构造器"><a href="#4-3-调用父类中的构造器" class="headerlink" title="4.3 调用父类中的构造器"></a>4.3 调用父类中的构造器</h5><h6 id="4-3-1-子类构造器中隐式调用父类无参构造器"><a href="#4-3-1-子类构造器中隐式调用父类无参构造器" class="headerlink" title="4.3.1 子类构造器中隐式调用父类无参构造器"></a>4.3.1 子类构造器中隐式调用父类无参构造器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//这里会隐式调用（自动调用）父类的无参构造器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="4-3-2-子类构造器中显式调用父类无参构造器"><a href="#4-3-2-子类构造器中显式调用父类无参构造器" class="headerlink" title="4.3.2 子类构造器中显式调用父类无参构造器"></a>4.3.2 子类构造器中显式调用父类无参构造器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-comment">//也可以使用 super 关键字，显示调用父类的构造器（有参的无参的都可以调用）</span><br>      <span class="hljs-keyword">super</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="4-3-3-子类构造器中显式调用父类有参构造器"><a href="#4-3-3-子类构造器中显式调用父类有参构造器" class="headerlink" title="4.3.3 子类构造器中显式调用父类有参构造器"></a>4.3.3 子类构造器中显式调用父类有参构造器</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//也可以使用super关键字，显示调用父类的构造器（有参的无参的都可以调用）</span><br>    <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在构造器中，可以使用 this 调用类中其他构造器，也可以使用 super 调用父类中的构造器。 但是 this 和 super 这俩种调用构造器的代码，不能同时出现，否则会报错。 这是因为 this 调用构造器的语句和 super 调用构造器的语句，都要求自己是第一句代码，但是构造器中的第一句代码只能有一个，所以它们俩个<strong>不能同时出现</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br><span class="hljs-comment">//编译报错，在使用 this 和 super 调用构造器功能的时候，它们俩个不能同时出现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-重写"><a href="#5-重写" class="headerlink" title="5. 重写"></a>5. 重写</h4><p>方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法，就称为重写。</p><p><strong>重写规则：</strong></p><ul><li>参数列表与被重写方法的<strong>参数列表必须完全相同</strong>。</li><li>返回类型与被重写方法的<strong>返回类型可以不相同，但是必须是父类返回值的派生类</strong>。</li><li><strong>访问权限不能比父类中被重写的方法的访问权限更低。</strong></li><li>如果不能继承一个类，则不能重写该类的方法。</li><li>父类的方法只能被它的子类重写。</li><li><strong>构造方法不能被重写。</strong></li><li><strong>声明为 final 的方法不能被重写。</strong></li><li><strong>声明为 static 的方法不能被重写</strong>，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法<strong>不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常</strong>，反之则可以。</li></ul><p>子类继承父类，继承了父类中的方法，但是父类中的方法并不一定能满足子类中的功能需要，所以子类中需要把方法进行重写。</p><h4 id="6-多态"><a href="#6-多态" class="headerlink" title="6. 多态"></a>6. 多态</h4><p>多态是同一个行为具有多个不同表现形式或形态的能力。相同类型的不同对象，调用同一个方法，最终执行结果是不同的。</p><h5 id="6-1-多态的优点"><a href="#6-1-多态的优点" class="headerlink" title="6.1 多态的优点"></a>6.1 多态的优点</h5><ul><li><p>消除类型之间的耦合关系</p></li><li><p>可替换性</p></li><li><p>可扩充性</p></li><li><p>接口性</p></li><li><p>灵活性</p></li><li><p>简化性</p></li></ul><h5 id="6-2-多态存在的三个前提"><a href="#6-2-多态存在的三个前提" class="headerlink" title="6.2 多态存在的三个前提"></a>6.2 多态存在的三个前提</h5><ul><li><p>子类继承父类 </p></li><li><p>子类重写父类中的方法 </p></li><li><p>父类的引用指向子类对象</p><p>注意，类实现接口，这是一种特殊形式的继承，多态也可以体现在类和接口的关系中。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 人</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;你好！&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 学生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;hello！我是一名酷酷的学生&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 老师类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>  System.out.println(<span class="hljs-string">&quot;hi！我是一名酷酷的老师&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//声明父类的引用</span><br>  Person person;<br>  <br>  <span class="hljs-comment">//根据随机数的情况，让父类引用person指向不同的子类对象（Student对象或者Teacher对象）</span><br>  <span class="hljs-keyword">int</span> random = (<span class="hljs-keyword">int</span>) (Math.random()*<span class="hljs-number">10</span>);<br>  <br>  <span class="hljs-keyword">if</span>(random%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>  person = <span class="hljs-keyword">new</span> Student();  <span class="hljs-comment">// 一个父类型的引用，可以指向它的任何一个子类对象</span><br>  <span class="hljs-keyword">else</span><br>  person = <span class="hljs-keyword">new</span> Teacher();<br>  <br>  <span class="hljs-comment">//使用person引用，调用子类对象中重写的方法</span><br><span class="hljs-comment">//关键点在于，在调用sayHello方法的时候，引用person指向的对象是谁</span><br>person.sayHello();<br>  <br>  <span class="hljs-comment">// 同一类型（Person）的引用，指向不同的子类对象（Student 或者 Teacher），调用同一个方法（sayHello），最后是不一样的表现形式（执行结果不同）！</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-3-多态的实现方式"><a href="#6-3-多态的实现方式" class="headerlink" title="6.3 多态的实现方式"></a>6.3 多态的实现方式</h5><ul><li><p>重写</p></li><li><p>接口</p></li><li><p>抽象类</p></li></ul><h4 id="7-重载"><a href="#7-重载" class="headerlink" title="7. 重载"></a>7. 重载</h4><p>方法重载是一个类中定义了多个同名的方法，而他们的<strong>参数的数量不同</strong>或<strong>数量相同而类型和次序不同</strong>，则称为方法的重载。</p><h5 id="7-1-重载规则"><a href="#7-1-重载规则" class="headerlink" title="7.1 重载规则"></a>7.1 重载规则</h5><ul><li>被重载的方法<strong>必须改变参数列表</strong>（参数个数、类型和次序不一样)；</li><li>被重载的方法<strong>可以改变返回类型</strong>；</li><li>被重载的方法<strong>可以改变访问修饰符</strong>；</li><li>被重载的方法声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li><strong>无法以返回值类型作为重载函数的区分标准</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>  <br><span class="hljs-comment">//参数的个数不同</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s1, String s2)</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">//参数的类型不同</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">double</span> salary)</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">//参数的顺序不同</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, String s)</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>  <br>  <span class="hljs-comment">//方法的参数可以相同，也可以不同</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 可变参数和数组，编译会报错，可变参数和数组其实是一样的。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span>... i)</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span>[] a)</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-2-涉及到隐式类型转换的重载"><a href="#7-2-涉及到隐式类型转换的重载" class="headerlink" title="7.2 涉及到隐式类型转换的重载"></a>7.2 涉及到隐式类型转换的重载</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;  <br><span class="hljs-comment">//方法重载</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">long</span> b)</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">long</span> b, <span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Test t = <span class="hljs-keyword">new</span> Test();<br>        t.test(<span class="hljs-number">1</span>, <span class="hljs-number">1L</span>);  <span class="hljs-comment">//调用到第一个方法</span><br>        t.test(<span class="hljs-number">1L</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//调用到第二个方法</span><br>        t.test(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">//问题：这个会调用到哪一个test方法？</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 注意，这时候， t.test(1,1) 代码是会编译报错的，因为类中定义的俩个方法都匹配。</span><br><span class="hljs-comment">// 注意，当参数无法完全精确匹配到方法的时候，参数会尝试做自动转换，然后再去尝试匹配方法。</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-comment">//重载方法1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;&#125;<br>    <span class="hljs-comment">//重载方法2</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">short</span> a)</span></span>&#123;&#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Test t = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-keyword">byte</span> a = <span class="hljs-number">1</span>;<br>        t.test(a);  <br>      <span class="hljs-comment">// 这里会调用第二个方法，也就是 short 类型参数的 test 方法。</span><br>        <span class="hljs-comment">// 虽然byte类型数据，可以自动转换为 short，也可以转换为 int，但是 short 离 byte 更近。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-重写与重载的区别"><a href="#8-重写与重载的区别" class="headerlink" title="8. 重写与重载的区别"></a>8. 重写与重载的区别</h4><p><strong>方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。</strong></p><table><thead><tr><th align="left">区别点</th><th align="left">重载</th><th align="left">重写</th></tr></thead><tbody><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可以修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可以修改</td><td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问</td><td align="left">可以修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 中的命名规则</title>
    <link href="/2021/06/07/2.%20java%20%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>/2021/06/07/2.%20java%20%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>项目名、包名、类名、变量名、常量名和方法名的命名规范。</p><span id="more"></span><p>创建一个项目之后，子类中的东西命名规范如下：</p><ul><li><strong>项目名</strong>全部小写，多个单词中间用<code>-</code>连接</li><li><strong>包名</strong>全部小写</li><li><strong>类名</strong>首字母大写，其余组成词首字母依次大写（大驼峰命名）</li><li><strong>变量名</strong>、<strong>方法名</strong>首字母小写，其余组成词的首字母都要大写（小驼峰命名）</li><li><strong>常量名</strong>全部大写，多个单词中间用<code>_</code>连接</li></ul><p>所有命名规则必须遵循Java本身的规则：</p><ul><li>名称只能由字母、数字、下划线、$符号组成</li><li>不能以数字开头</li><li>名称不能使用 Java 中的关键字</li><li>坚决不允许出现中文及拼音命名</li></ul><table><thead><tr><th>类型</th><th>约束</th><th>举例</th></tr></thead><tbody><tr><td>项目名</td><td>全部小写，多个单词用中划线【**-**】分隔</td><td>spring-cloud</td></tr><tr><td>包名</td><td>全部小写</td><td>com.company</td></tr><tr><td>类名</td><td>单词首字母大写，其余组成词首字母依次大写（大驼峰命名）</td><td>PaintFigure</td></tr><tr><td>变量名</td><td>首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写</td><td>password、userName</td></tr><tr><td>常量名</td><td>全部大写，多个单词，用【**_**】分隔</td><td>EXAM_TIME</td></tr><tr><td>方法名</td><td>首字母小写，其余组成词的首字母都要大写（小驼峰命名）</td><td>createExam</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包装类</title>
    <link href="/2021/06/06/10.%20%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <url>/2021/06/06/10.%20%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>Number 类是 java.lang 包下的一个抽象类，提供了将包装类型拆箱成基本类型的方法，所有基本类型（数据类型）的包装类型都继承了该抽象类，并且是 final 声明不可继承改变。</p><span id="more"></span><h4 id="1-Number-类"><a href="#1-Number-类" class="headerlink" title="1. Number 类"></a>1. Number 类</h4><p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p><img src="https://i.loli.net/2021/06/06/GXh94qejMatDkO7.png" alt="number类.png" style="zoom:50%;" /><h5 id="1-1-装箱-amp-拆箱"><a href="#1-1-装箱-amp-拆箱" class="headerlink" title="1.1 装箱 &amp; 拆箱"></a>1.1 装箱 &amp; 拆箱</h5><p>这种由编译器特别支持的包装称为装箱，所以当基本数据类型被当作对象使用的时候，编译器会把它们装箱为包装类。</p><p>相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Integer x = <span class="hljs-number">5</span>;            <span class="hljs-comment">// 当 x 被赋为整型值时，由于x是一个对象，所以编译器要对x进行装箱。</span><br>      x =  x + <span class="hljs-number">10</span>;              <span class="hljs-comment">// 然后，为了使x能进行加运算，所以要对x进行拆箱。</span><br>      System.out.println(x); <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-2-常用的方法"><a href="#1-2-常用的方法" class="headerlink" title="1.2 常用的方法"></a>1.2 常用的方法</h5><ul><li><p>xxxValue()<br>将 Number 对象转换为xxx数据类型的值并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Number n = <span class="hljs-number">1</span>;<br>n.doubleValue();     <span class="hljs-comment">// 转化为 double 类型。</span><br>n.byteValue();<span class="hljs-comment">// 转化为 byte 类型。</span><br>n.floatValue();<span class="hljs-comment">// 转化为 float 类型。</span><br>n.longValue();<span class="hljs-comment">// 转化为 long 类型。</span><br>n.shortValue();<span class="hljs-comment">// 转化为 short 类型。</span><br>n.intValue();<span class="hljs-comment">// 转化为 int 类型。</span><br></code></pre></td></tr></table></figure></li><li><p>valueOf()</p><p>用于返回给定参数的原生 Number 对象值，参数可以是基本数据类型，String等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x =Integer.valueOf(<span class="hljs-number">9</span>);<br>Double c = Double.valueOf(<span class="hljs-number">5.0</span>);<br>Float a = Float.valueOf(<span class="hljs-string">&quot;80&quot;</span>);              <br>Integer b = Integer.valueOf(<span class="hljs-string">&quot;444&quot;</span>,<span class="hljs-number">16</span>);   <span class="hljs-comment">// 使用 16 进制</span><br><br>System.out.println(x);<br>System.out.println(c);<br>System.out.println(a);<br>System.out.println(b);<br></code></pre></td></tr></table></figure></li><li><p>compareTo()</p><p>用于将 Number 对象与方法的参数进行比较。参数可以是 Byte, Double, Integer, Float, Long 或 Short 类型。</p><p>该方法<strong>用于两个相同数据类型的比较</strong>，两个不同类型的数据不能用此方法来比较。</p><ul><li>如果指定的数与参数相等返回 0。</li><li>如果指定的数小于参数返回 -1。</li><li>如果指定的数大于参数返回 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>System.out.println(x.compareTo(<span class="hljs-number">3</span>));    <span class="hljs-comment">// 结果为 1</span><br>System.out.println(x.compareTo(<span class="hljs-number">5</span>));    <span class="hljs-comment">// 结果为 0</span><br>System.out.println(x.compareTo(<span class="hljs-number">8</span>));    <span class="hljs-comment">// 结果为 -1</span><br></code></pre></td></tr></table></figure></li><li><p>equals()</p><p>判断 Number 对象是否与参数相等。</p><p>如 Number 对象不为 Null，且与方法的<strong>参数类型与数值都相等</strong>返回 True，否则返回 False。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>Double y = <span class="hljs-number">5.0</span>;<br>Long z = <span class="hljs-number">5</span>;<br>Short a = <span class="hljs-number">5</span>;<br>Float b = <span class="hljs-number">5.0</span>;<br>Byte c = <span class="hljs-number">5</span>; <br><br>System.out.println(x.equals(y));  <span class="hljs-comment">// false</span><br>System.out.println(x.equals(z));  <span class="hljs-comment">// false</span><br>System.out.println(x.equals(a));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p>toString(）</p><p>返回以一个字符串表示的 Number 对象值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer x = <span class="hljs-number">5</span>;<br>System.out.println(x.toString());<br>System.out.println(Integer.toString(<span class="hljs-number">12</span>));<br>System.out.println(Integer.toString(<span class="hljs-number">12</span>, <span class="hljs-number">16</span>)); <span class="hljs-comment">// 用 16 进制 </span><br></code></pre></td></tr></table></figure></li><li><p>parseXXX() </p><p>用于将字符串参数作为有符号的十进制（默认）XXX类型进行解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x =Integer.parseInt(<span class="hljs-string">&quot;9&quot;</span>);<br><span class="hljs-keyword">double</span> c = Double.parseDouble(<span class="hljs-string">&quot;5&quot;</span>);<br><span class="hljs-keyword">int</span> b = Integer.parseInt(<span class="hljs-string">&quot;444&quot;</span>,<span class="hljs-number">16</span>);   <span class="hljs-comment">// 用 16 进制 </span><br><br>System.out.println(x);<br>System.out.println(c);<br>System.out.println(b);<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Object-类"><a href="#2-Object-类" class="headerlink" title="2. Object 类"></a>2. Object 类</h4><p>Object 类是所有类的父类型，类中定义的方法，java 中所有对象都可以调用。</p><h5 id="2-1-toString"><a href="#2-1-toString" class="headerlink" title="2.1 toString()"></a>2.1 toString()</h5><ul><li>返回对象的字符串表示形式。</li><li>默认返回格式：<strong>对象的 class 名称 + @ + hashCode 的十六进制字符串</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Object obj1 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj1.toString());<br>      <span class="hljs-comment">// java.lang.Object@d716361</span><br><br>        Object obj2 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj2.toString());<br>      <span class="hljs-comment">//java.lang.Object@6ff3c5b5</span><br> <br>        Object obj3 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj3.toString());<br>      <span class="hljs-comment">//java.lang.Object@3764951d</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-2-getClass"><a href="#2-2-getClass" class="headerlink" title="2.2 getClass()"></a>2.2 getClass()</h5><p>getClass() 方法用于获取对象的运行时对象的类类型。返回值是 Class&lt;?&gt;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> <br>    Object obj1 = <span class="hljs-keyword">new</span> Object();<br>    System.out.println(<span class="hljs-string">&quot;obj1 的类为: &quot;</span> + obj1.getClass());<br> <span class="hljs-comment">// obj1 的类为: class java.lang.Object</span><br>      <br>    String obj2 = <span class="hljs-keyword">new</span> String();<br>    System.out.println(<span class="hljs-string">&quot;obj2 的类为: &quot;</span> + obj2.getClass());<br>    <span class="hljs-comment">// obj2 的类为: class java.lang.String</span><br> <br>    ArrayList&lt;Integer&gt; obj3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    System.out.println(<span class="hljs-string">&quot;obj3 的类为: &quot;</span> + obj3.getClass());<br>    <span class="hljs-comment">// obj3 的类为: class java.util.ArrayList</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-hashCode"><a href="#2-3-hashCode" class="headerlink" title="2.3 hashCode()"></a>2.3 hashCode()</h5><p>该方法返回一个 int 值，该 int 值是 JVM 根据对象在内存的中的特征（地址值），通过hash算法计算出的一 个结果。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Hash，一般翻译做“散列”，也可以音译为“哈希”，就是把任意长度的数据输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。 一个任意长度的输入转为一个固定长度的输出，是一种压缩映射，也就是说，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以<strong>不可能从散列值来确定唯一的输入值</strong>。</p><p>我们可以认为，Object 中的 hashCode 方法默认返回的是对象的内存地址，但是实际上可能并不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Object obj1 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj1.hashCode()); <br> <br>        Object obj2 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj2.hashCode());<br> <br>        Object obj3 = <span class="hljs-keyword">new</span> Object();<br>        System.out.println(obj3.hashCode()); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于俩个对象的 hashCode 值： </p><ul><li>相等的俩个对象，hashCode 值一定相等。 </li><li>hashCode 值相同，俩个对象有可能相等，也可能不同等。 </li><li>hashCode 值不同，俩个对象一定不同。</li></ul><h5 id="2-4-equals"><a href="#2-4-equals" class="headerlink" title="2.4 equals()"></a>2.4 equals()</h5><p>用于比较两个对象是否相等。</p><p>Object 中的 equals 方法，是直接使用的 == 号进行的比较，比较俩个对象的地址值是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>equal 方法可以被重写，如 String 类重写了 equals() 方法，用于比较两个字符串是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        String obj1 = <span class="hljs-keyword">new</span> String();<br>        String obj2 = <span class="hljs-keyword">new</span> String();<br> <br>        <span class="hljs-comment">// 判断 obj1 与 obj2 是否相等</span><br>        <span class="hljs-comment">// 初始化的两个对象都为 null，所以是相等，返回 true</span><br>        System.out.println(obj1.equals(obj2)); <span class="hljs-comment">// true</span><br> <br>        <span class="hljs-comment">// 给对象赋值</span><br>        obj1 = <span class="hljs-string">&quot;Baidu&quot;</span>;<br>        obj2 = <span class="hljs-string">&quot;Google&quot;</span>;<br> <br>        <span class="hljs-comment">// 判断 obj1 与 obj2 是否相等</span><br>        <span class="hljs-comment">// 两个值不同，内存地址也不同，所以不相等，返回 false</span><br>        System.out.println(obj1.equals(obj2)); <span class="hljs-comment">// false</span><br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对equals方法重写，一般需要注意以下几点： </p><ol><li>自反性：对任意引用 obj，obj.equals(obj) 的返回值一定为 true. </li><li>对称性：对于任何引用 o1、o2，当且仅当 o1.equals(o2) 返回值为 true 时，o2.equals(o1) 的返回值一 定为 true; </li><li>传递性：如果 o1.equals(o2) 为 true, o2.equals(o3) 为 true,则 o1.equals(o3) 也一定为 true </li><li>一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变 </li><li>非空性：任何非空的引用 obj，obj.equals(null) 的返回值一定为false</li></ol>]]></content>
    
    
    <categories>
      
      <category>CoreJava</category>
      
    </categories>
    
    
    <tags>
      
      <tag>包装类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修饰符</title>
    <link href="/2021/06/06/5.%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2021/06/06/5.%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>Java 语言提供了很多修饰符，主要分为以下两类： 访问修饰符和非访问修饰符。修饰符用来定义类、方法或者变量，通常放在语句的最前端。</p><span id="more"></span><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><p>Java中，可以使用访问控制符来<strong>保护对类、变量、方法和构造方法的访问</strong>。</p><ul><li><p><strong>default（默认访问修饰符）：</strong></p><p>使用 default 的变量和方法，<strong>对同一个包内的类是可见的</strong>。</p><p>接口里的变量都隐式声明为 <strong>public static final</strong>，而接口里的方法默认情况下访问权限为 <strong>public</strong>。</p><p>使用对象：类、接口、变量、方法。</p></li><li><p><strong>public（公有访问修饰符）：</strong></p><p>被声明为 public 的类、方法、构造方法和接口<strong>能够被任何其他类访问</strong>。</p><p>使用对象：类、接口、变量、方法。</p></li><li><p><strong>private（私有访问修饰符）：</strong></p><p>被声明为 private 的方法、变量和构造方法<strong>只能被所属类访问</strong>。</p><p>使用对象：变量、方法，不能修饰类（外部类）。</p></li><li><p><strong>protected（受保护的访问修饰符）：</strong></p><ul><li>子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected 方法。 </li></ul><p>使用对象：变量、方法，不能修饰类（外部类）。</p></li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(同一包)</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">Y/N</td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left">Y</td><td align="left">N</td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><h4 id="2-非访问控制修饰符"><a href="#2-非访问控制修饰符" class="headerlink" title="2. 非访问控制修饰符"></a>2. 非访问控制修饰符</h4><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p><ul><li><p><strong>static：</strong></p><ul><li><p>static 变量：</p><p>static 关键字用来声明独立于对象的静态变量，<strong>无论一个类实例化多少对象，它的静态变量只有一份拷贝</strong>。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p></li><li><p>static 方法：</p><p>static 关键字用来声明独立于对象的静态方法，即可以使用 类名.方法名 的方式进行调用。<strong>静态方法不能使用类的非静态变量</strong>。静态方法从参数列表得到数据，然后计算这些数据。</p></li></ul></li><li><p><strong>final：</strong></p><ul><li><p>final 变量：</p><p>final 表示“最后的、最终的含义”，变量<strong>一旦赋值后，不能被重新赋值</strong>。被 final 修饰的实例变量<strong>必须显式指定初始值</strong>。final 修饰符通常和 static 修饰符一起使用来创建类常量。</p></li><li><p>final 方法：</p><p>父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是<strong>防止该方法的内容被修改</strong>。</p></li></ul></li><li><p><strong>abstract：</strong></p><ul><li><p>abstract 类：</p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了<strong>将来对该类进行扩充</strong>。</p><p>一个类不能同时被 abstract 和 final 修饰。</p><p><strong>如果一个类包含抽象方法，那么该类一定要声明为抽象类</strong>，否则将出现编译错误。</p><p><strong>抽象类可以包含抽象方法和非抽象方法</strong>。</p></li><li><p>abstract 方法：</p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p><strong>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</strong></p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p><strong>抽象方法的声明以分号结尾。</strong></p></li></ul></li><li><p><strong>synchronized：</strong></p><ul><li>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</li></ul></li><li><p><strong>transient：</strong></p><ul><li><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p></li><li><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p></li></ul></li><li><p><strong>volatile：</strong></p><ul><li>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</li><li>一个 volatile 对象引用可能是 null。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日期处理</title>
    <link href="/2021/06/06/12.%20%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <url>/2021/06/06/12.%20%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>一些常见的日期处理方式。</p><span id="more"></span><h4 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a><strong>关键类</strong></h4><ul><li>Instant：瞬时实例。</li><li>LocalDate：本地日期，不包含具体时间。例如：2014-01-14 可以用来记录生日、纪念日、加盟日等。</li><li>LocalTime：本地时间，不包含日期。</li><li>LocalDateTime：组合了日期和时间，但不包含时差和时区信息。</li><li>ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。</li></ul><p>新API还引入了 ZoneOffSet 和 ZoneId 类，使得解决时区问题更为简便。解析、格式化时间的 DateTimeFormatter 类也全部重新设计。</p><h4 id="1-获取当前日期"><a href="#1-获取当前日期" class="headerlink" title="1. 获取当前日期"></a>1. 获取当前日期</h4><p>LocalDate 用于表示当天日期。只有日期，不包含时间。当你仅需要表示日期时就用这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCurrentDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate today = LocalDate.now();  <span class="hljs-comment">// 获取当前时间</span><br>  System.out.println(date);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-获取年月日信息"><a href="#2-获取年月日信息" class="headerlink" title="2. 获取年月日信息"></a>2. 获取年月日信息</h4><p>LocalDate 提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getDetailDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate today = LocalDate.now();   <span class="hljs-comment">// 获取当前日期</span><br>  <span class="hljs-keyword">int</span> year = today.getYear();<span class="hljs-comment">// 获取年份</span><br>  <span class="hljs-keyword">int</span> month = today.getMonthValue();  <span class="hljs-comment">// 获取月份</span><br>  <span class="hljs-keyword">int</span> day = today.getDayOfMonth();   <span class="hljs-comment">// 获取日</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-获得特定日期"><a href="#3-获得特定日期" class="headerlink" title="3. 获得特定日期"></a>3. 获得特定日期</h4><p>通过 LocalDate.of() 创建任意日期，该方法需要传入年、月、日做参数，返回对应的 LocalDate实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">void</span> <span class="hljs-title">handleSpecialDate</span><span class="hljs-params">()</span></span>&#123;<br>  LocalDate dateOfBirth = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 创建特定日期</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-计算某时间段前-后的日期"><a href="#4-计算某时间段前-后的日期" class="headerlink" title="4. 计算某时间段前/后的日期"></a>4. 计算某时间段前/后的日期</h4><p>LocalDate日期不包含时间信息，它的 plus() 方法用来增加天、周、月、十年、世纪，ChronoUnit类声明了这些时间单位。minus() 方法同上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plusDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate currentDate = LocalDate.now();<br>    System.out.println(<span class="hljs-string">&quot;今天的日期是:&quot;</span> + currentDate);<br><br>    LocalDate afterDayDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.DAYS);<br>    System.out.println(<span class="hljs-string">&quot;一天以后的日期是:&quot;</span> + afterDayDate);<br><br>    LocalDate afterWeekDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.WEEKS);<br>    System.out.println(<span class="hljs-string">&quot;一个星期后的日期是:&quot;</span> + afterWeekDate);<br><br>    LocalDate afterMonthDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.MONTHS);<br>    System.out.println(<span class="hljs-string">&quot;一个月以后的日期是：&quot;</span> + afterMonthDate);<br><br>    LocalDate afterDecadeDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.DECADES);<br>    System.out.println(<span class="hljs-string">&quot;十年以后的日期是：&quot;</span> + afterDecadeDate);<br><br>    LocalDate afterCenturyDate = currentDate.plus(<span class="hljs-number">1</span>, ChronoUnit.CENTURIES);<br>    System.out.println(<span class="hljs-string">&quot;一个世纪以后的日期是：&quot;</span> + afterCenturyDate);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-判断日期是早于还是晚于另一个日期"><a href="#5-判断日期是早于还是晚于另一个日期" class="headerlink" title="5. 判断日期是早于还是晚于另一个日期"></a>5. 判断日期是早于还是晚于另一个日期</h4><p>LocalDate 类有两类方法 isBefore() 和 isAfter() 用于比较日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compareDate</span><span class="hljs-params">()</span></span>&#123;<br>       LocalDate currentDate = LocalDate.now();<br>       LocalDate anotherDate = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span> ,<span class="hljs-number">1</span>);<br><br>       <span class="hljs-comment">// isBefore()</span><br>       <span class="hljs-keyword">if</span>(currentDate.isBefore(anotherDate))&#123;<br>           System.out.println(currentDate + <span class="hljs-string">&quot;更早&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-comment">// isAfter()</span><br>       <span class="hljs-keyword">if</span>(currentDate.isAfter(anotherDate))&#123;<br>           System.out.println(currentDate + <span class="hljs-string">&quot;更晚&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="6-判断两个日期是否相等"><a href="#6-判断两个日期是否相等" class="headerlink" title="6. 判断两个日期是否相等"></a>6. 判断两个日期是否相等</h4><p>LocalDate 重载了 equal 方法。如果比较的是日期是字符型，需要先解析成日期对象再做判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">equalDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate currentDate = LocalDate.now();<br>    LocalDate anotherDate = LocalDate.of(<span class="hljs-number">2021</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span>(currentDate.equals(anotherDate))&#123;<br>        System.out.println(<span class="hljs-string">&quot;两个日期是相等的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-判断闰年"><a href="#7-判断闰年" class="headerlink" title="7. 判断闰年"></a>7. 判断闰年</h4><p>LocalDate类有一个很实用的方法 isLeapYear() 判断该实例是否是一个闰年。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">judgeLeapYear</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate today = LocalDate.now();<br>    <span class="hljs-keyword">if</span>(today.isLeapYear())&#123;<br>        System.out.println(<span class="hljs-string">&quot;是闰年&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不是闰年&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-计算两个日期之间的天数和月数"><a href="#8-计算两个日期之间的天数和月数" class="headerlink" title="8. 计算两个日期之间的天数和月数"></a>8. 计算两个日期之间的天数和月数</h4><p>有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java 8中可以用java.time.Period类来做计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculateDate</span><span class="hljs-params">()</span></span>&#123;<br>        LocalDate date1 = LocalDate.of(<span class="hljs-number">2021</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>);<br>        LocalDate date2 = LocalDate.of(<span class="hljs-number">2020</span>, <span class="hljs-number">2</span>, <span class="hljs-number">21</span>);<br>        LocalDate java8Release = LocalDate.of(<span class="hljs-number">2018</span>, Month.MAY, <span class="hljs-number">14</span>);<br><br>        Period periodBetweenD1AndD2 = Period.between(date1,date2);   <span class="hljs-comment">// 格式是 xxxY-xxxM-xxxD</span><br>        System.out.println(periodBetweenD1AndD2);<br><br>        <span class="hljs-keyword">int</span> periodYear = periodBetweenD1AndD2.getYears();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodYear + <span class="hljs-string">&quot;年&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> periodMonth = periodBetweenD1AndD2.getMonths();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodMonth + <span class="hljs-string">&quot;个月&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> periodDay = periodBetweenD1AndD2.getDays();<br>        System.out.println(<span class="hljs-string">&quot;相差&quot;</span> + periodDay + <span class="hljs-string">&quot;天&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="9-在现有的时间上增加小时"><a href="#9-在现有的时间上增加小时" class="headerlink" title="9. 在现有的时间上增加小时"></a>9. 在现有的时间上增加小时</h4><p>Java 8 提供了更好的 plusHours() 方法替换 add() ，并且是兼容的。注意，这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plusHours</span><span class="hljs-params">()</span></span>&#123;<br>    LocalTime time = LocalTime.now();<br>    LocalTime newTime = time.plusHours(<span class="hljs-number">2</span>); <span class="hljs-comment">// 增加两小时</span><br>    System.out.println(<span class="hljs-string">&quot;两个小时后的时间是 : &quot;</span> +  newTime);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-处理时区-amp-时差"><a href="#10-处理时区-amp-时差" class="headerlink" title="10. 处理时区&amp;时差"></a>10. 处理时区&amp;时差</h4><h5 id="10-1-ZoneId-amp-ZoneDateTime"><a href="#10-1-ZoneId-amp-ZoneDateTime" class="headerlink" title="10.1. ZoneId &amp; ZoneDateTime"></a>10.1. ZoneId &amp; ZoneDateTime</h5><ul><li>Zoneld 来处理特定时区</li><li>ZoneDateTime 类来表示某时区下的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getZoneTime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//设置时区</span><br>    ZoneId america = ZoneId.of(<span class="hljs-string">&quot;America/New_York&quot;</span>);<br><br>    LocalDateTime localtDateAndTime = LocalDateTime.now();<br><br>  <br>    ZonedDateTime dateAndTimeInNewYork  = ZonedDateTime.of(localtDateAndTime, america );<br>  <br>    System.out.println(<span class="hljs-string">&quot;现在的日期和时间在特定的时区 : &quot;</span> + dateAndTimeInNewYork);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="10-2-ZoneOffset"><a href="#10-2-ZoneOffset" class="headerlink" title="10.2. ZoneOffset"></a>10.2. ZoneOffset</h5><p>ZoneOffset 类用来表示时区，举例来说印度与 GMT 或 UTC 标准时区相差 +05:30，可以通过 ZoneOffset.of() 静态方法来 获取对应的时区。一旦得到了时差就可以通过传入 LocalDateTime 和 ZoneOffset 来创建一个 OffSetDateTime 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ZoneOffset</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDateTime datetime = LocalDateTime.of(<span class="hljs-number">2018</span>, Month.FEBRUARY, <span class="hljs-number">14</span>, <span class="hljs-number">19</span>, <span class="hljs-number">30</span>);<br>    ZoneOffset offset = ZoneOffset.of(<span class="hljs-string">&quot;+05:30&quot;</span>);<br>    OffsetDateTime date = OffsetDateTime.of(datetime, offset);<br>    System.out.println(<span class="hljs-string">&quot;Date and Time with timezone offset in Java : &quot;</span> + date);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-时间戳"><a href="#11-时间戳" class="headerlink" title="11. 时间戳"></a>11. 时间戳</h4><h5 id="11-1-Clock"><a href="#11-1-Clock" class="headerlink" title="11.1. Clock"></a>11.1. Clock</h5><p>Clock 时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis() 和 TimeZone.getDefault() 的地方都可用Clock替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clock</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 根据系统时间返回当前时间并设置为UTC。</span><br>    Clock clock = Clock.systemUTC();<br>    System.out.println(<span class="hljs-string">&quot;Clock : &quot;</span> + clock);<br><br>    <span class="hljs-comment">// 根据系统时钟区域返回时间</span><br>    Clock defaultClock = Clock.systemDefaultZone();<br>    System.out.println(<span class="hljs-string">&quot;Clock : &quot;</span> + clock);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="11-2-Instant"><a href="#11-2-Instant" class="headerlink" title="11.2. Instant"></a>11.2. Instant</h5><p>Instant类有一个静态工厂方法now()会返回当前的时间戳，如下所示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getTimestamp</span><span class="hljs-params">()</span></span>&#123;<br>    Instant timestamp = Instant.now();<br>    System.out.println(timestamp);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-格式转换"><a href="#12-格式转换" class="headerlink" title="12. 格式转换"></a>12. 格式转换</h4><h5 id="12-1-DateTimeFormatter"><a href="#12-1-DateTimeFormatter" class="headerlink" title="12.1. DateTimeFormatter"></a>12.1. DateTimeFormatter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">LocalDateTime rightNow=LocalDateTime.now();<br>String date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);<br>System.out.println(date);<br><br>DateTimeFormatter formatter=DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(formatter.format(rightNow));<br></code></pre></td></tr></table></figure><h4 id="13-固定日期"><a href="#13-固定日期" class="headerlink" title="13. 固定日期"></a>13. 固定日期</h4><p>YearMonth 用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到当月共有多少天，YearMonth 实例的 lengthOfMonth() 方法可以返回当月的天数，在判断 2 月有 28 天还是 29 天时非常有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkCardExpiry</span><span class="hljs-params">()</span></span>&#123;<br>      YearMonth currentYearMonth = YearMonth.now();<br>      System.out.printf(<span class="hljs-string">&quot;%s: 当月有 %d 天%n&quot;</span>, currentYearMonth, currentYearMonth.lengthOfMonth());<br><br>      YearMonth creditCardExpiry = YearMonth.of(<span class="hljs-number">2028</span>, Month.FEBRUARY);<br>      System.out.printf(<span class="hljs-string">&quot;你的信用卡将在 %s 过期&quot;</span>, creditCardExpiry);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="14-每年都会发生的周期性事件"><a href="#14-每年都会发生的周期性事件" class="headerlink" title="14. 每年都会发生的周期性事件"></a>14. 每年都会发生的周期性事件</h4><p>MonthDay 这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cycleDate</span><span class="hljs-params">()</span></span>&#123;<br>    LocalDate today = LocalDate.now();<br>    LocalDate dateOfBirth = LocalDate.of(<span class="hljs-number">2018</span>, <span class="hljs-number">01</span>, <span class="hljs-number">21</span>);<br><br>    MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());<br>    MonthDay currentMonthDay = MonthDay.from(today);<br><br>    <span class="hljs-keyword">if</span>(currentMonthDay.equals(birthday))&#123;<br>       System.out.println(<span class="hljs-string">&quot;Many Many happy returns of the day !!&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Sorry, today is not your birthday&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CoreJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
